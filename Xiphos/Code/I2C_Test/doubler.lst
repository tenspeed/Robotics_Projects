
doubler.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000044  00800200  000027c4  00002858  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000027c4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000012  00800244  00800244  0000289c  2**0
                  ALLOC
  3 .debug_aranges 00000120  00000000  00000000  0000289c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000de0  00000000  00000000  000029bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000046e9  00000000  00000000  0000379c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000011ac  00000000  00000000  00007e85  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001fff  00000000  00000000  00009031  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000008b0  00000000  00000000  0000b030  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000013e6  00000000  00000000  0000b8e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001ee0  00000000  00000000  0000ccc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000038  00000000  00000000  0000eba6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__ctors_end>
       4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
       8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
       c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      10:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      14:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      18:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      1c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      20:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      24:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      28:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      2c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      30:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      34:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      38:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      3c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      40:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      44:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      48:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      4c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      50:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      54:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      58:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      5c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      60:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      64:	0c 94 ac 07 	jmp	0xf58	; 0xf58 <__vector_25>
      68:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      6c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      70:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      74:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      78:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      7c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      80:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      84:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      88:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      8c:	0c 94 9c 0a 	jmp	0x1538	; 0x1538 <__vector_35>
      90:	0c 94 fb 07 	jmp	0xff6	; 0xff6 <__vector_36>
      94:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      98:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      9c:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      a0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      a4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      a8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      ac:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      b0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      b4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      b8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      bc:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      c0:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      c4:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>
      c8:	0c 94 0a 01 	jmp	0x214	; 0x214 <__bad_interrupt>

000000cc <str_inf.1440>:
      cc:	69 6e 66 00 49 4e 46 00                             inf.INF.

000000d4 <str_nan.1439>:
      d4:	6e 61 6e 00 4e 41 4e 00 00 40 7a 10 f3 5a 00 a0     nan.NAN..@z..Z..
      e4:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
      f4:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     104:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     114:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     124:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     134:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     144:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     154:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     164:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     174:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     184:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     194:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     1a4:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     1b4:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     1c4:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     1d4:	3d 27                                               ='

000001d6 <__ctors_end>:
     1d6:	11 24       	eor	r1, r1
     1d8:	1f be       	out	0x3f, r1	; 63
     1da:	cf ef       	ldi	r28, 0xFF	; 255
     1dc:	d1 e2       	ldi	r29, 0x21	; 33
     1de:	de bf       	out	0x3e, r29	; 62
     1e0:	cd bf       	out	0x3d, r28	; 61

000001e2 <__do_copy_data>:
     1e2:	12 e0       	ldi	r17, 0x02	; 2
     1e4:	a0 e0       	ldi	r26, 0x00	; 0
     1e6:	b2 e0       	ldi	r27, 0x02	; 2
     1e8:	e4 ec       	ldi	r30, 0xC4	; 196
     1ea:	f7 e2       	ldi	r31, 0x27	; 39
     1ec:	00 e0       	ldi	r16, 0x00	; 0
     1ee:	0b bf       	out	0x3b, r16	; 59
     1f0:	02 c0       	rjmp	.+4      	; 0x1f6 <__do_copy_data+0x14>
     1f2:	07 90       	elpm	r0, Z+
     1f4:	0d 92       	st	X+, r0
     1f6:	a4 34       	cpi	r26, 0x44	; 68
     1f8:	b1 07       	cpc	r27, r17
     1fa:	d9 f7       	brne	.-10     	; 0x1f2 <__do_copy_data+0x10>

000001fc <__do_clear_bss>:
     1fc:	12 e0       	ldi	r17, 0x02	; 2
     1fe:	a4 e4       	ldi	r26, 0x44	; 68
     200:	b2 e0       	ldi	r27, 0x02	; 2
     202:	01 c0       	rjmp	.+2      	; 0x206 <.do_clear_bss_start>

00000204 <.do_clear_bss_loop>:
     204:	1d 92       	st	X+, r1

00000206 <.do_clear_bss_start>:
     206:	a6 35       	cpi	r26, 0x56	; 86
     208:	b1 07       	cpc	r27, r17
     20a:	e1 f7       	brne	.-8      	; 0x204 <.do_clear_bss_loop>
     20c:	0e 94 0c 01 	call	0x218	; 0x218 <main>
     210:	0c 94 e0 13 	jmp	0x27c0	; 0x27c0 <_exit>

00000214 <__bad_interrupt>:
     214:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000218 <main>:
	#include "keyboard.h"						//!< Include header for the display class
	
	
	//======================================================================================
	
	int main()
     218:	cf 92       	push	r12
     21a:	df 92       	push	r13
     21c:	ef 92       	push	r14
     21e:	ff 92       	push	r15
     220:	0f 93       	push	r16
     222:	1f 93       	push	r17
     224:	df 93       	push	r29
     226:	cf 93       	push	r28
     228:	cd b7       	in	r28, 0x3d	; 61
     22a:	de b7       	in	r29, 0x3e	; 62
     22c:	a3 97       	sbiw	r28, 0x23	; 35
     22e:	0f b6       	in	r0, 0x3f	; 63
     230:	f8 94       	cli
     232:	de bf       	out	0x3e, r29	; 62
     234:	0f be       	out	0x3f, r0	; 63
     236:	cd bf       	out	0x3d, r28	; 61
	{
		char temp_var;
		rs232 the_serial_port (9600, 0); 					// Create a serial port object to communicate via serial.					
     238:	94 e1       	ldi	r25, 0x14	; 20
     23a:	c9 2e       	mov	r12, r25
     23c:	d1 2c       	mov	r13, r1
     23e:	cc 0e       	add	r12, r28
     240:	dd 1e       	adc	r13, r29
     242:	c6 01       	movw	r24, r12
     244:	60 e8       	ldi	r22, 0x80	; 128
     246:	75 e2       	ldi	r23, 0x25	; 37
     248:	40 e0       	ldi	r20, 0x00	; 0
     24a:	0e 94 4a 08 	call	0x1094	; 0x1094 <_ZN5rs232C1Ejh>
															// If serial communication doesn't work, check the port number.
		
		time_stamp interval_time (0, 25000);  			// Create a time stamp which holds the interval that each task is called.
     24e:	ce 01       	movw	r24, r28
     250:	03 96       	adiw	r24, 0x03	; 3
     252:	60 e0       	ldi	r22, 0x00	; 0
     254:	70 e0       	ldi	r23, 0x00	; 0
     256:	28 ea       	ldi	r18, 0xA8	; 168
     258:	31 e6       	ldi	r19, 0x61	; 97
     25a:	40 e0       	ldi	r20, 0x00	; 0
     25c:	50 e0       	ldi	r21, 0x00	; 0
     25e:	0e 94 32 09 	call	0x1264	; 0x1264 <_ZN10time_stampC1Ejm>
															// The time stamp is initialized with a number of seconds, then microseconds.
		
		task_timer the_timer;								// Create a microsecond-resolution timer.
     262:	ce 01       	movw	r24, r28
     264:	07 96       	adiw	r24, 0x07	; 7
     266:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <_ZN10task_timerC1Ev>
		
		utility utility_OBJ(&the_serial_port);				// Create a utility object to use handy pre-built methods like micro and
     26a:	7e 01       	movw	r14, r28
     26c:	08 94       	sec
     26e:	e1 1c       	adc	r14, r1
     270:	f1 1c       	adc	r15, r1
     272:	c7 01       	movw	r24, r14
     274:	b6 01       	movw	r22, r12
     276:	0e 94 84 01 	call	0x308	; 0x308 <_ZN7utilityC1EP16base_text_serial>
															// milli second delays.

		LCD LCD_OBJ(&the_serial_port, &utility_OBJ);		// Create an LCD object for handling output to the LCD screen.
     27a:	8e 01       	movw	r16, r28
     27c:	01 5f       	subi	r16, 0xF1	; 241
     27e:	1f 4f       	sbci	r17, 0xFF	; 255
     280:	c8 01       	movw	r24, r16
     282:	b6 01       	movw	r22, r12
     284:	a7 01       	movw	r20, r14
     286:	0e 94 47 03 	call	0x68e	; 0x68e <_ZN3LCDC1EP16base_text_serialP7utility>
		keyboard user_input(&LCD_OBJ);
     28a:	8b e0       	ldi	r24, 0x0B	; 11
     28c:	e8 2e       	mov	r14, r24
     28e:	f1 2c       	mov	r15, r1
     290:	ec 0e       	add	r14, r28
     292:	fd 1e       	adc	r15, r29
     294:	c7 01       	movw	r24, r14
     296:	b8 01       	movw	r22, r16
     298:	0e 94 cf 06 	call	0xd9e	; 0xd9e <_ZN8keyboardC1EP3LCD>
		
		LCD_OBJ.lcdInit();									// Initialize the LCD screen.
     29c:	c8 01       	movw	r24, r16
     29e:	0e 94 14 06 	call	0xc28	; 0xc28 <_ZN3LCD7lcdInitEv>
		
		LCD_OBJ.printString("input:");							// print msg1 on first row
     2a2:	c8 01       	movw	r24, r16
     2a4:	60 e0       	ldi	r22, 0x00	; 0
     2a6:	72 e0       	ldi	r23, 0x02	; 2
     2a8:	0e 94 73 05 	call	0xae6	; 0xae6 <_ZN3LCD11printStringEPKc>
		LCD_OBJ.lcdCursor(1,0);								// move cursor to start of second row
     2ac:	c8 01       	movw	r24, r16
     2ae:	61 e0       	ldi	r22, 0x01	; 1
     2b0:	40 e0       	ldi	r20, 0x00	; 0
     2b2:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN3LCD9lcdCursorEhh>
		LCD_OBJ.printString("output:");							// print msg2 on second row
     2b6:	c8 01       	movw	r24, r16
     2b8:	67 e0       	ldi	r22, 0x07	; 7
     2ba:	72 e0       	ldi	r23, 0x02	; 2
     2bc:	0e 94 73 05 	call	0xae6	; 0xae6 <_ZN3LCD11printStringEPKc>
		LCD_OBJ.lcdCursor(0,8);
     2c0:	c8 01       	movw	r24, r16
     2c2:	60 e0       	ldi	r22, 0x00	; 0
     2c4:	48 e0       	ldi	r20, 0x08	; 8
     2c6:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN3LCD9lcdCursorEhh>
		LCD_OBJ.lcdCursorOn();								// Turn cursor on
     2ca:	c8 01       	movw	r24, r16
     2cc:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <_ZN3LCD11lcdCursorOnEv>
		LCD_OBJ.lcdCursorBlink();							// Blink cursor
     2d0:	c8 01       	movw	r24, r16
     2d2:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <_ZN3LCD14lcdCursorBlinkEv>
		
		while(1) 
		{
			if(the_serial_port.check_for_char())
     2d6:	c6 01       	movw	r24, r12
     2d8:	0e 94 80 07 	call	0xf00	; 0xf00 <_ZN5rs23214check_for_charEv>
     2dc:	88 23       	and	r24, r24
     2de:	d9 f3       	breq	.-10     	; 0x2d6 <main+0xbe>
			{
				temp_var = the_serial_port.getchar();
     2e0:	c6 01       	movw	r24, r12
     2e2:	0e 94 38 07 	call	0xe70	; 0xe70 <_ZN5rs2327getcharEv>
     2e6:	68 2f       	mov	r22, r24
				if(temp_var == 0x7F) //check if backspace is pressed
     2e8:	8f 37       	cpi	r24, 0x7F	; 127
     2ea:	31 f0       	breq	.+12     	; 0x2f8 <main+0xe0>
				{
					user_input.delete_a_char();
				}
				else if(temp_var == 0x0D) //check if enter is pressed
     2ec:	8d 30       	cpi	r24, 0x0D	; 13
     2ee:	99 f3       	breq	.-26     	; 0x2d6 <main+0xbe>
				{
					// initiate data send over I2C
				}
				else
				{
					user_input.print_a_char(temp_var); //print everything else
     2f0:	c7 01       	movw	r24, r14
     2f2:	0e 94 95 06 	call	0xd2a	; 0xd2a <_ZN8keyboard12print_a_charEc>
     2f6:	ef cf       	rjmp	.-34     	; 0x2d6 <main+0xbe>
			if(the_serial_port.check_for_char())
			{
				temp_var = the_serial_port.getchar();
				if(temp_var == 0x7F) //check if backspace is pressed
				{
					user_input.delete_a_char();
     2f8:	c7 01       	movw	r24, r14
     2fa:	0e 94 64 06 	call	0xcc8	; 0xcc8 <_ZN8keyboard13delete_a_charEv>
     2fe:	eb cf       	rjmp	.-42     	; 0x2d6 <main+0xbe>

00000300 <_ZN7utilityC2EP16base_text_serial>:
output PORT:   0=drive low, 1=drive high
write to PIN:  1=toggle value of PORT
read from PIN: value on the pin
*/

utility::utility (base_text_serial* p_serial_port)  // Constructor for the LCD class
     300:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;          // Store the serial port pointer locally
     302:	71 83       	std	Z+1, r23	; 0x01
     304:	60 83       	st	Z, r22
}
     306:	08 95       	ret

00000308 <_ZN7utilityC1EP16base_text_serial>:
output PORT:   0=drive low, 1=drive high
write to PIN:  1=toggle value of PORT
read from PIN: value on the pin
*/

utility::utility (base_text_serial* p_serial_port)  // Constructor for the LCD class
     308:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;          // Store the serial port pointer locally
     30a:	71 83       	std	Z+1, r23	; 0x01
     30c:	60 83       	st	Z, r22
}
     30e:	08 95       	ret

00000310 <_ZN7utility10initializeEv>:

//! Initializes all enabled board features. Must be called in your program before using other library functions.
void utility::initialize()
{
	//configure BTN1 as an input
	cbi(DDRD, DDD4);
     310:	54 98       	cbi	0x0a, 4	; 10
	//enable pullup for BTN1
	sbi(PORTD, PD4);
     312:	5c 9a       	sbi	0x0b, 4	; 11

	//configure LED as an output
	sbi(DDRG, DDG2);
     314:	9a 9a       	sbi	0x13, 2	; 19

	//configure 74LS374 (D Flip-Flop) clock pin as an output
	sbi(DDRD, DDD5);
     316:	55 9a       	sbi	0x0a, 5	; 10

	//configure LCD/Servo bus on port C as an output
	DDRC = 0xFF;
     318:	8f ef       	ldi	r24, 0xFF	; 255
     31a:	87 b9       	out	0x07, r24	; 7

	#if USE_ADC == 1
		//initialize ADC
		adcInit();
	#endif
}
     31c:	08 95       	ret

0000031e <_ZN7utility7delayMsEj>:

//! Provides a busy wait loop for an approximate number of milliseconds.
void utility::delayMs(uint16_t num)
{
	for (; num > 0; num--)
     31e:	61 15       	cp	r22, r1
     320:	71 05       	cpc	r23, r1
     322:	41 f0       	breq	.+16     	; 0x334 <_ZN7utility7delayMsEj+0x16>
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
     324:	20 ea       	ldi	r18, 0xA0	; 160
     326:	3f e0       	ldi	r19, 0x0F	; 15
     328:	c9 01       	movw	r24, r18
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	f1 f7       	brne	.-4      	; 0x32a <_ZN7utility7delayMsEj+0xc>
     32e:	61 50       	subi	r22, 0x01	; 1
     330:	70 40       	sbci	r23, 0x00	; 0
     332:	d1 f7       	brne	.-12     	; 0x328 <_ZN7utility7delayMsEj+0xa>
     334:	08 95       	ret

00000336 <_ZN7utility7delayUsEj>:
}

//! Provides a busy wait loop for an approximate number of microseconds.
void utility::delayUs(uint16_t num)
{
	for (; num > 0; num--)
     336:	61 15       	cp	r22, r1
     338:	71 05       	cpc	r23, r1
     33a:	41 f0       	breq	.+16     	; 0x34c <_ZN7utility7delayUsEj+0x16>
     33c:	24 e0       	ldi	r18, 0x04	; 4
     33e:	30 e0       	ldi	r19, 0x00	; 0
     340:	c9 01       	movw	r24, r18
     342:	01 97       	sbiw	r24, 0x01	; 1
     344:	f1 f7       	brne	.-4      	; 0x342 <_ZN7utility7delayUsEj+0xc>
     346:	61 50       	subi	r22, 0x01	; 1
     348:	70 40       	sbci	r23, 0x00	; 0
     34a:	d1 f7       	brne	.-12     	; 0x340 <_ZN7utility7delayUsEj+0xa>
     34c:	08 95       	ret

0000034e <_ZN7utility10getButton1Ev>:
    @return 0 when the button is not pressed and 1 when the button is pressed.
    @see Use buttonWait() if you want to wait for a button press and release.
 */
uint8_t utility::getButton1()
{
	return (gbi(PIND, PIND4) == 0);
     34e:	89 b1       	in	r24, 0x09	; 9
     350:	82 95       	swap	r24
     352:	8f 70       	andi	r24, 0x0F	; 15
     354:	80 95       	com	r24
}
     356:	81 70       	andi	r24, 0x01	; 1
     358:	08 95       	ret

0000035a <_ZN7utility10buttonWaitEv>:
    @see Use getButton1() for simply checking the button state without waiting or debouncing.
 */
void utility::buttonWait()
{
	//wait for button to be pushed down
	while (!getButton1());
     35a:	4c 99       	sbic	0x09, 4	; 9
     35c:	fe cf       	rjmp	.-4      	; 0x35a <_ZN7utility10buttonWaitEv>
     35e:	2e e1       	ldi	r18, 0x1E	; 30
     360:	30 e0       	ldi	r19, 0x00	; 0
     362:	40 ea       	ldi	r20, 0xA0	; 160
     364:	5f e0       	ldi	r21, 0x0F	; 15
     366:	ca 01       	movw	r24, r20
     368:	01 97       	sbiw	r24, 0x01	; 1
     36a:	f1 f7       	brne	.-4      	; 0x368 <_ZN7utility10buttonWaitEv+0xe>
}

//! Provides a busy wait loop for an approximate number of milliseconds.
void utility::delayMs(uint16_t num)
{
	for (; num > 0; num--)
     36c:	21 50       	subi	r18, 0x01	; 1
     36e:	30 40       	sbci	r19, 0x00	; 0
     370:	d1 f7       	brne	.-12     	; 0x366 <_ZN7utility10buttonWaitEv+0xc>
	//wait for button to be pushed down
	while (!getButton1());
	//delay 30 ms for button debouncing
	delayMs(30);
	//wait for button to be released, if it is still down
	while (getButton1());
     372:	4c 9b       	sbis	0x09, 4	; 9
     374:	fe cf       	rjmp	.-4      	; 0x372 <_ZN7utility10buttonWaitEv+0x18>
     376:	2e e1       	ldi	r18, 0x1E	; 30
     378:	30 e0       	ldi	r19, 0x00	; 0
     37a:	40 ea       	ldi	r20, 0xA0	; 160
     37c:	5f e0       	ldi	r21, 0x0F	; 15
     37e:	ca 01       	movw	r24, r20
     380:	01 97       	sbiw	r24, 0x01	; 1
     382:	f1 f7       	brne	.-4      	; 0x380 <_ZN7utility10buttonWaitEv+0x26>
}

//! Provides a busy wait loop for an approximate number of milliseconds.
void utility::delayMs(uint16_t num)
{
	for (; num > 0; num--)
     384:	21 50       	subi	r18, 0x01	; 1
     386:	30 40       	sbci	r19, 0x00	; 0
     388:	d1 f7       	brne	.-12     	; 0x37e <_ZN7utility10buttonWaitEv+0x24>
	delayMs(30);
	//wait for button to be released, if it is still down
	while (getButton1());
	//delay 30 ms for button debouncing
	delayMs(30);
}
     38a:	08 95       	ret

0000038c <_ZN7utility5ledOnEv>:

//! Turns the LED on
void utility::ledOn()
{
	sbi(PORTG, PG2);
     38c:	a2 9a       	sbi	0x14, 2	; 20
}
     38e:	08 95       	ret

00000390 <_ZN7utility6ledOffEv>:

//! Turns the LED off
void utility::ledOff()
{
	cbi(PORTG, PG2);
     390:	a2 98       	cbi	0x14, 2	; 20
}
     392:	08 95       	ret

00000394 <_ZN7utility9ledToggleEv>:

//! Toggles the LED on/off
void utility::ledToggle()
{
	tbi(PORTG, PG2);
     394:	84 b3       	in	r24, 0x14	; 20
     396:	94 e0       	ldi	r25, 0x04	; 4
     398:	89 27       	eor	r24, r25
     39a:	84 bb       	out	0x14, r24	; 20
}
     39c:	08 95       	ret

0000039e <_ZN7utility16digitalDirectionEh16DigitalDirection>:
    Valid values specified by the ::DigitalDirection enumeration (::INPUT, ::INPUT_PULLUP, ::OUTPUT).
    @see Use digitalDirections() and digitalPullups() if you want to configure all 10 digital pins at once.
 */
void utility::digitalDirection(uint8_t num, const DigitalDirection direction)
{
	if (num > 1)
     39e:	62 30       	cpi	r22, 0x02	; 2
     3a0:	a0 f0       	brcs	.+40     	; 0x3ca <_ZN7utility16digitalDirectionEh16DigitalDirection+0x2c>
	{
		//adjust num offset here to simplify the code below
		num -= 2;
     3a2:	62 50       	subi	r22, 0x02	; 2
		switch (direction)
     3a4:	41 30       	cpi	r20, 0x01	; 1
     3a6:	f9 f0       	breq	.+62     	; 0x3e6 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x48>
     3a8:	41 30       	cpi	r20, 0x01	; 1
     3aa:	d0 f4       	brcc	.+52     	; 0x3e0 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x42>
		{
		case INPUT:
			cbi(DDRA, num);  //input direction
     3ac:	81 b1       	in	r24, 0x01	; 1
     3ae:	21 e0       	ldi	r18, 0x01	; 1
     3b0:	30 e0       	ldi	r19, 0x00	; 0
     3b2:	02 c0       	rjmp	.+4      	; 0x3b8 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x1a>
     3b4:	22 0f       	add	r18, r18
     3b6:	33 1f       	adc	r19, r19
     3b8:	6a 95       	dec	r22
     3ba:	e2 f7       	brpl	.-8      	; 0x3b4 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x16>
     3bc:	20 95       	com	r18
     3be:	82 23       	and	r24, r18
     3c0:	81 b9       	out	0x01, r24	; 1
			cbi(PORTA, num); //disable pullup
     3c2:	82 b1       	in	r24, 0x02	; 2
     3c4:	28 23       	and	r18, r24
     3c6:	22 b9       	out	0x02, r18	; 2
     3c8:	08 95       	ret
		case OUTPUT:
			sbi(DDRA, num);  //output direction
			break;
		}
	}
	else if (num == 1)
     3ca:	61 30       	cpi	r22, 0x01	; 1
     3cc:	39 f1       	breq	.+78     	; 0x41c <_ZN7utility16digitalDirectionEh16DigitalDirection+0x7e>
			break;
		}
	}
	else if (num == 0)
	{
		switch (direction)
     3ce:	41 30       	cpi	r20, 0x01	; 1
     3d0:	a1 f1       	breq	.+104    	; 0x43a <_ZN7utility16digitalDirectionEh16DigitalDirection+0x9c>
     3d2:	41 30       	cpi	r20, 0x01	; 1
     3d4:	60 f1       	brcs	.+88     	; 0x42e <_ZN7utility16digitalDirectionEh16DigitalDirection+0x90>
     3d6:	42 30       	cpi	r20, 0x02	; 2
     3d8:	29 f4       	brne	.+10     	; 0x3e4 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x46>
		case INPUT:
			cbi(DDRB, DDB4);  //input direction
			cbi(PORTB, PB4); //disable pullup
			break;
		case INPUT_PULLUP:
			cbi(DDRB, DDB4);  //input direction
     3da:	24 98       	cbi	0x04, 4	; 4
			sbi(PORTB, PB4); //enable pullup
     3dc:	2c 9a       	sbi	0x05, 4	; 5
     3de:	08 95       	ret
{
	if (num > 1)
	{
		//adjust num offset here to simplify the code below
		num -= 2;
		switch (direction)
     3e0:	42 30       	cpi	r20, 0x02	; 2
     3e2:	61 f0       	breq	.+24     	; 0x3fc <_ZN7utility16digitalDirectionEh16DigitalDirection+0x5e>
     3e4:	08 95       	ret
		case INPUT_PULLUP:
			cbi(DDRA, num);  //input direction
			sbi(PORTA, num); //enable pullup
			break;
		case OUTPUT:
			sbi(DDRA, num);  //output direction
     3e6:	21 b1       	in	r18, 0x01	; 1
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	02 c0       	rjmp	.+4      	; 0x3f2 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x54>
     3ee:	88 0f       	add	r24, r24
     3f0:	99 1f       	adc	r25, r25
     3f2:	6a 95       	dec	r22
     3f4:	e2 f7       	brpl	.-8      	; 0x3ee <_ZN7utility16digitalDirectionEh16DigitalDirection+0x50>
     3f6:	28 2b       	or	r18, r24
     3f8:	21 b9       	out	0x01, r18	; 1
     3fa:	08 95       	ret
		case INPUT:
			cbi(DDRA, num);  //input direction
			cbi(PORTA, num); //disable pullup
			break;
		case INPUT_PULLUP:
			cbi(DDRA, num);  //input direction
     3fc:	31 b1       	in	r19, 0x01	; 1
     3fe:	81 e0       	ldi	r24, 0x01	; 1
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	02 c0       	rjmp	.+4      	; 0x408 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x6a>
     404:	88 0f       	add	r24, r24
     406:	99 1f       	adc	r25, r25
     408:	6a 95       	dec	r22
     40a:	e2 f7       	brpl	.-8      	; 0x404 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x66>
     40c:	28 2f       	mov	r18, r24
     40e:	20 95       	com	r18
     410:	23 23       	and	r18, r19
     412:	21 b9       	out	0x01, r18	; 1
			sbi(PORTA, num); //enable pullup
     414:	22 b1       	in	r18, 0x02	; 2
     416:	82 2b       	or	r24, r18
     418:	82 b9       	out	0x02, r24	; 2
     41a:	08 95       	ret
			break;
		}
	}
	else if (num == 1)
	{
		switch (direction)
     41c:	41 30       	cpi	r20, 0x01	; 1
     41e:	79 f0       	breq	.+30     	; 0x43e <_ZN7utility16digitalDirectionEh16DigitalDirection+0xa0>
     420:	41 30       	cpi	r20, 0x01	; 1
     422:	40 f0       	brcs	.+16     	; 0x434 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x96>
     424:	42 30       	cpi	r20, 0x02	; 2
     426:	f1 f6       	brne	.-68     	; 0x3e4 <_ZN7utility16digitalDirectionEh16DigitalDirection+0x46>
		case INPUT:
			cbi(DDRB, DDB7);  //input direction
			cbi(PORTB, PB7); //disable pullup
			break;
		case INPUT_PULLUP:
			cbi(DDRB, DDB7);  //input direction
     428:	27 98       	cbi	0x04, 7	; 4
			sbi(PORTB, PB7); //enable pullup
     42a:	2f 9a       	sbi	0x05, 7	; 5
     42c:	08 95       	ret
	else if (num == 0)
	{
		switch (direction)
		{
		case INPUT:
			cbi(DDRB, DDB4);  //input direction
     42e:	24 98       	cbi	0x04, 4	; 4
			cbi(PORTB, PB4); //disable pullup
     430:	2c 98       	cbi	0x05, 4	; 5
     432:	08 95       	ret
	else if (num == 1)
	{
		switch (direction)
		{
		case INPUT:
			cbi(DDRB, DDB7);  //input direction
     434:	27 98       	cbi	0x04, 7	; 4
			cbi(PORTB, PB7); //disable pullup
     436:	2f 98       	cbi	0x05, 7	; 5
     438:	08 95       	ret
		case INPUT_PULLUP:
			cbi(DDRB, DDB4);  //input direction
			sbi(PORTB, PB4); //enable pullup
			break;
		case OUTPUT:
			sbi(DDRB, DDB4);  //output direction
     43a:	24 9a       	sbi	0x04, 4	; 4
     43c:	08 95       	ret
		case INPUT_PULLUP:
			cbi(DDRB, DDB7);  //input direction
			sbi(PORTB, PB7); //enable pullup
			break;
		case OUTPUT:
			sbi(DDRB, DDB7);  //output direction
     43e:	27 9a       	sbi	0x04, 7	; 4
     440:	08 95       	ret

00000442 <_ZN7utility17digitalDirectionsEj>:
 */
void utility::digitalDirections(const uint16_t directions)
{
	const uint8_t lower = (uint8_t)directions;
	//set digital0 as output
	if (gbi(lower, 0))
     442:	86 2f       	mov	r24, r22
     444:	60 ff       	sbrs	r22, 0
     446:	0a c0       	rjmp	.+20     	; 0x45c <_ZN7utility17digitalDirectionsEj+0x1a>
		sbi(DDRB, DDB4);
     448:	24 9a       	sbi	0x04, 4	; 4
	//else set digital0 as input
	else
		cbi(DDRB, DDB4);

	//set digital1 as output
	if (gbi(lower, 1))
     44a:	81 fd       	sbrc	r24, 1
     44c:	0a c0       	rjmp	.+20     	; 0x462 <_ZN7utility17digitalDirectionsEj+0x20>
		sbi(DDRB, DDB7);
	//else set digital1 as input
	else
		cbi(DDRB, DDB7);
     44e:	27 98       	cbi	0x04, 7	; 4

	//set directions for digital2-digital9
	DDRA = (uint8_t)(directions >> 2);
     450:	76 95       	lsr	r23
     452:	67 95       	ror	r22
     454:	76 95       	lsr	r23
     456:	67 95       	ror	r22
     458:	61 b9       	out	0x01, r22	; 1
}
     45a:	08 95       	ret
	//set digital0 as output
	if (gbi(lower, 0))
		sbi(DDRB, DDB4);
	//else set digital0 as input
	else
		cbi(DDRB, DDB4);
     45c:	24 98       	cbi	0x04, 4	; 4

	//set digital1 as output
	if (gbi(lower, 1))
     45e:	81 ff       	sbrs	r24, 1
     460:	f6 cf       	rjmp	.-20     	; 0x44e <_ZN7utility17digitalDirectionsEj+0xc>
		sbi(DDRB, DDB7);
     462:	27 9a       	sbi	0x04, 7	; 4
	//else set digital1 as input
	else
		cbi(DDRB, DDB7);

	//set directions for digital2-digital9
	DDRA = (uint8_t)(directions >> 2);
     464:	76 95       	lsr	r23
     466:	67 95       	ror	r22
     468:	76 95       	lsr	r23
     46a:	67 95       	ror	r22
     46c:	61 b9       	out	0x01, r22	; 1
}
     46e:	08 95       	ret

00000470 <_ZN7utility14digitalPullupsEj>:
    @see Use digitalDirection() if you only want to configure a single digital pin.
*/
void utility::digitalPullups(const uint16_t pullups)
{
	//digital0
	if (gbi(DDRB, DDB4) == 0)
     470:	24 99       	sbic	0x04, 4	; 4
     472:	03 c0       	rjmp	.+6      	; 0x47a <_ZN7utility14digitalPullupsEj+0xa>
	{
		if (gbi(pullups, 0))
     474:	60 ff       	sbrs	r22, 0
     476:	45 c0       	rjmp	.+138    	; 0x502 <_ZN7utility14digitalPullupsEj+0x92>
			sbi(PORTB, PB4); //enable pullup
     478:	2c 9a       	sbi	0x05, 4	; 5
		else
			cbi(PORTB, PB4); //disable pullup
	}
	//digital1
	if (gbi(DDRB, DDB7) == 0)
     47a:	27 99       	sbic	0x04, 7	; 4
     47c:	03 c0       	rjmp	.+6      	; 0x484 <_ZN7utility14digitalPullupsEj+0x14>
	{
		if (gbi(pullups, 1))
     47e:	61 ff       	sbrs	r22, 1
     480:	3e c0       	rjmp	.+124    	; 0x4fe <_ZN7utility14digitalPullupsEj+0x8e>
			sbi(PORTB, PB7); //enable pullup
     482:	2f 9a       	sbi	0x05, 7	; 5
		else
			cbi(PORTB, PB7); //disable pullup
	}
	//digital2-digital9
	uint8_t i;
	const uint8_t pullups2 = (uint8_t)(pullups >> 2);
     484:	76 95       	lsr	r23
     486:	67 95       	ror	r22
     488:	76 95       	lsr	r23
     48a:	67 95       	ror	r22
     48c:	40 e0       	ldi	r20, 0x00	; 0
     48e:	50 e0       	ldi	r21, 0x00	; 0
	for (i = 0; i < 8; i++)
	{
		if (gbi(DDRA, i) == 0)
		{
			if (gbi(pullups2, i))
     490:	70 e0       	ldi	r23, 0x00	; 0
				sbi(PORTA, i); //enable pullup
			else
				cbi(PORTA, i); //disable pullup
     492:	e1 e0       	ldi	r30, 0x01	; 1
     494:	f0 e0       	ldi	r31, 0x00	; 0
     496:	0f c0       	rjmp	.+30     	; 0x4b6 <_ZN7utility14digitalPullupsEj+0x46>
	for (i = 0; i < 8; i++)
	{
		if (gbi(DDRA, i) == 0)
		{
			if (gbi(pullups2, i))
				sbi(PORTA, i); //enable pullup
     498:	22 b1       	in	r18, 0x02	; 2
     49a:	cf 01       	movw	r24, r30
     49c:	04 2e       	mov	r0, r20
     49e:	02 c0       	rjmp	.+4      	; 0x4a4 <_ZN7utility14digitalPullupsEj+0x34>
     4a0:	88 0f       	add	r24, r24
     4a2:	99 1f       	adc	r25, r25
     4a4:	0a 94       	dec	r0
     4a6:	e2 f7       	brpl	.-8      	; 0x4a0 <_ZN7utility14digitalPullupsEj+0x30>
     4a8:	28 2b       	or	r18, r24
     4aa:	22 b9       	out	0x02, r18	; 2
			else
				cbi(PORTA, i); //disable pullup
     4ac:	4f 5f       	subi	r20, 0xFF	; 255
     4ae:	5f 4f       	sbci	r21, 0xFF	; 255
			cbi(PORTB, PB7); //disable pullup
	}
	//digital2-digital9
	uint8_t i;
	const uint8_t pullups2 = (uint8_t)(pullups >> 2);
	for (i = 0; i < 8; i++)
     4b0:	48 30       	cpi	r20, 0x08	; 8
     4b2:	51 05       	cpc	r21, r1
     4b4:	19 f1       	breq	.+70     	; 0x4fc <_ZN7utility14digitalPullupsEj+0x8c>
	{
		if (gbi(DDRA, i) == 0)
     4b6:	81 b1       	in	r24, 0x01	; 1
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	04 2e       	mov	r0, r20
     4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <_ZN7utility14digitalPullupsEj+0x52>
     4be:	95 95       	asr	r25
     4c0:	87 95       	ror	r24
     4c2:	0a 94       	dec	r0
     4c4:	e2 f7       	brpl	.-8      	; 0x4be <_ZN7utility14digitalPullupsEj+0x4e>
     4c6:	80 fd       	sbrc	r24, 0
     4c8:	f1 cf       	rjmp	.-30     	; 0x4ac <_ZN7utility14digitalPullupsEj+0x3c>
		{
			if (gbi(pullups2, i))
     4ca:	cb 01       	movw	r24, r22
     4cc:	04 2e       	mov	r0, r20
     4ce:	02 c0       	rjmp	.+4      	; 0x4d4 <_ZN7utility14digitalPullupsEj+0x64>
     4d0:	95 95       	asr	r25
     4d2:	87 95       	ror	r24
     4d4:	0a 94       	dec	r0
     4d6:	e2 f7       	brpl	.-8      	; 0x4d0 <_ZN7utility14digitalPullupsEj+0x60>
     4d8:	80 fd       	sbrc	r24, 0
     4da:	de cf       	rjmp	.-68     	; 0x498 <_ZN7utility14digitalPullupsEj+0x28>
				sbi(PORTA, i); //enable pullup
			else
				cbi(PORTA, i); //disable pullup
     4dc:	22 b1       	in	r18, 0x02	; 2
     4de:	cf 01       	movw	r24, r30
     4e0:	04 2e       	mov	r0, r20
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <_ZN7utility14digitalPullupsEj+0x78>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	0a 94       	dec	r0
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <_ZN7utility14digitalPullupsEj+0x74>
     4ec:	80 95       	com	r24
     4ee:	82 23       	and	r24, r18
     4f0:	82 b9       	out	0x02, r24	; 2
     4f2:	4f 5f       	subi	r20, 0xFF	; 255
     4f4:	5f 4f       	sbci	r21, 0xFF	; 255
			cbi(PORTB, PB7); //disable pullup
	}
	//digital2-digital9
	uint8_t i;
	const uint8_t pullups2 = (uint8_t)(pullups >> 2);
	for (i = 0; i < 8; i++)
     4f6:	48 30       	cpi	r20, 0x08	; 8
     4f8:	51 05       	cpc	r21, r1
     4fa:	e9 f6       	brne	.-70     	; 0x4b6 <_ZN7utility14digitalPullupsEj+0x46>
				sbi(PORTA, i); //enable pullup
			else
				cbi(PORTA, i); //disable pullup
		}
	}
}
     4fc:	08 95       	ret
	if (gbi(DDRB, DDB7) == 0)
	{
		if (gbi(pullups, 1))
			sbi(PORTB, PB7); //enable pullup
		else
			cbi(PORTB, PB7); //disable pullup
     4fe:	2f 98       	cbi	0x05, 7	; 5
     500:	c1 cf       	rjmp	.-126    	; 0x484 <_ZN7utility14digitalPullupsEj+0x14>
	if (gbi(DDRB, DDB4) == 0)
	{
		if (gbi(pullups, 0))
			sbi(PORTB, PB4); //enable pullup
		else
			cbi(PORTB, PB4); //disable pullup
     502:	2c 98       	cbi	0x05, 4	; 5
     504:	ba cf       	rjmp	.-140    	; 0x47a <_ZN7utility14digitalPullupsEj+0xa>

00000506 <_ZN7utility12digitalInputEh>:
    @return 1 if the input is high, 0 if the input is low.
    @see Use digitalInputs() if you want to read all 10 digital pins at once.
 */
uint8_t utility::digitalInput(const uint8_t num)
{
	if (num > 1)
     506:	62 30       	cpi	r22, 0x02	; 2
     508:	b0 f0       	brcs	.+44     	; 0x536 <_ZN7utility12digitalInputEh+0x30>
		return gbis(PINA, num - 2);
     50a:	40 b1       	in	r20, 0x00	; 0
     50c:	26 2f       	mov	r18, r22
     50e:	30 e0       	ldi	r19, 0x00	; 0
     510:	22 50       	subi	r18, 0x02	; 2
     512:	30 40       	sbci	r19, 0x00	; 0
     514:	81 e0       	ldi	r24, 0x01	; 1
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	02 2e       	mov	r0, r18
     51a:	02 c0       	rjmp	.+4      	; 0x520 <_ZN7utility12digitalInputEh+0x1a>
     51c:	88 0f       	add	r24, r24
     51e:	99 1f       	adc	r25, r25
     520:	0a 94       	dec	r0
     522:	e2 f7       	brpl	.-8      	; 0x51c <_ZN7utility12digitalInputEh+0x16>
     524:	50 e0       	ldi	r21, 0x00	; 0
     526:	84 23       	and	r24, r20
     528:	95 23       	and	r25, r21
     52a:	02 c0       	rjmp	.+4      	; 0x530 <_ZN7utility12digitalInputEh+0x2a>
     52c:	95 95       	asr	r25
     52e:	87 95       	ror	r24
     530:	2a 95       	dec	r18
     532:	e2 f7       	brpl	.-8      	; 0x52c <_ZN7utility12digitalInputEh+0x26>
     534:	08 95       	ret
	else if (num == 1)
     536:	61 30       	cpi	r22, 0x01	; 1
     538:	69 f0       	breq	.+26     	; 0x554 <_ZN7utility12digitalInputEh+0x4e>
		return gbis(PINB, PINB7);
	else if (num == 0)
		return gbis(PINB, PINB4);
     53a:	83 b1       	in	r24, 0x03	; 3
     53c:	90 e0       	ldi	r25, 0x00	; 0
     53e:	80 71       	andi	r24, 0x10	; 16
     540:	90 70       	andi	r25, 0x00	; 0
     542:	95 95       	asr	r25
     544:	87 95       	ror	r24
     546:	95 95       	asr	r25
     548:	87 95       	ror	r24
     54a:	95 95       	asr	r25
     54c:	87 95       	ror	r24
     54e:	95 95       	asr	r25
     550:	87 95       	ror	r24
}
     552:	08 95       	ret
uint8_t utility::digitalInput(const uint8_t num)
{
	if (num > 1)
		return gbis(PINA, num - 2);
	else if (num == 1)
		return gbis(PINB, PINB7);
     554:	83 b1       	in	r24, 0x03	; 3
     556:	88 1f       	adc	r24, r24
     558:	88 27       	eor	r24, r24
     55a:	88 1f       	adc	r24, r24
     55c:	08 95       	ret

0000055e <_ZN7utility13digitalOutputEhh>:
    @see Use digitalOutputs() if you want to set all 10 digital pins at once.
 */
void utility::digitalOutput(const uint8_t num, const uint8_t value)
{
	//if the output should be set
	if (value > 0)
     55e:	44 23       	and	r20, r20
     560:	89 f0       	breq	.+34     	; 0x584 <_ZN7utility13digitalOutputEhh+0x26>
	{
		if (num > 1)
     562:	62 30       	cpi	r22, 0x02	; 2
     564:	08 f1       	brcs	.+66     	; 0x5a8 <_ZN7utility13digitalOutputEhh+0x4a>
			sbi(PORTA, num - 2);
     566:	42 b1       	in	r20, 0x02	; 2
     568:	26 2f       	mov	r18, r22
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	22 50       	subi	r18, 0x02	; 2
     56e:	30 40       	sbci	r19, 0x00	; 0
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	02 c0       	rjmp	.+4      	; 0x57a <_ZN7utility13digitalOutputEhh+0x1c>
     576:	88 0f       	add	r24, r24
     578:	99 1f       	adc	r25, r25
     57a:	2a 95       	dec	r18
     57c:	e2 f7       	brpl	.-8      	; 0x576 <_ZN7utility13digitalOutputEhh+0x18>
     57e:	48 2b       	or	r20, r24
     580:	42 b9       	out	0x02, r20	; 2
     582:	08 95       	ret
			sbi(PORTB, PB4);
	}
	//else the output should be cleared
	else
	{
		if (num > 1)
     584:	62 30       	cpi	r22, 0x02	; 2
     586:	a0 f0       	brcs	.+40     	; 0x5b0 <_ZN7utility13digitalOutputEhh+0x52>
			cbi(PORTA, num - 2);
     588:	42 b1       	in	r20, 0x02	; 2
     58a:	26 2f       	mov	r18, r22
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	22 50       	subi	r18, 0x02	; 2
     590:	30 40       	sbci	r19, 0x00	; 0
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	02 c0       	rjmp	.+4      	; 0x59c <_ZN7utility13digitalOutputEhh+0x3e>
     598:	88 0f       	add	r24, r24
     59a:	99 1f       	adc	r25, r25
     59c:	2a 95       	dec	r18
     59e:	e2 f7       	brpl	.-8      	; 0x598 <_ZN7utility13digitalOutputEhh+0x3a>
     5a0:	80 95       	com	r24
     5a2:	84 23       	and	r24, r20
     5a4:	82 b9       	out	0x02, r24	; 2
     5a6:	08 95       	ret
	//if the output should be set
	if (value > 0)
	{
		if (num > 1)
			sbi(PORTA, num - 2);
		else if (num == 1)
     5a8:	61 30       	cpi	r22, 0x01	; 1
     5aa:	31 f0       	breq	.+12     	; 0x5b8 <_ZN7utility13digitalOutputEhh+0x5a>
			sbi(PORTB, PB7);
		else if (num == 0)
			sbi(PORTB, PB4);
     5ac:	2c 9a       	sbi	0x05, 4	; 5
     5ae:	08 95       	ret
	//else the output should be cleared
	else
	{
		if (num > 1)
			cbi(PORTA, num - 2);
		else if (num == 1)
     5b0:	61 30       	cpi	r22, 0x01	; 1
     5b2:	21 f0       	breq	.+8      	; 0x5bc <_ZN7utility13digitalOutputEhh+0x5e>
			cbi(PORTB, PB7);
		else if (num == 0)
			cbi(PORTB, PB4);
     5b4:	2c 98       	cbi	0x05, 4	; 5
     5b6:	08 95       	ret
	if (value > 0)
	{
		if (num > 1)
			sbi(PORTA, num - 2);
		else if (num == 1)
			sbi(PORTB, PB7);
     5b8:	2f 9a       	sbi	0x05, 7	; 5
     5ba:	08 95       	ret
	else
	{
		if (num > 1)
			cbi(PORTA, num - 2);
		else if (num == 1)
			cbi(PORTB, PB7);
     5bc:	2f 98       	cbi	0x05, 7	; 5
     5be:	08 95       	ret

000005c0 <_ZN7utility14digitalOutputsEj>:
    @param outputs Set bits to 1 to turn on corresponding outputs, or 0 to turn off corresponding outputs.
    @see Use digitalOutput() if you only want to set a single digital pin.
 */
void utility::digitalOutputs(const uint16_t outputs)
{
	PORTA = (uint8_t)(outputs>>2);
     5c0:	cb 01       	movw	r24, r22
     5c2:	96 95       	lsr	r25
     5c4:	87 95       	ror	r24
     5c6:	96 95       	lsr	r25
     5c8:	87 95       	ror	r24
     5ca:	82 b9       	out	0x02, r24	; 2
	PORTB = (PORTB & 0x6F) | ((gbis((uint8_t)outputs, 1) << PB7) | (gbi((uint8_t)outputs, 0) << PB4));
     5cc:	25 b1       	in	r18, 0x05	; 5
     5ce:	70 e0       	ldi	r23, 0x00	; 0
     5d0:	cb 01       	movw	r24, r22
     5d2:	81 70       	andi	r24, 0x01	; 1
     5d4:	90 70       	andi	r25, 0x00	; 0
     5d6:	82 95       	swap	r24
     5d8:	92 95       	swap	r25
     5da:	90 7f       	andi	r25, 0xF0	; 240
     5dc:	98 27       	eor	r25, r24
     5de:	80 7f       	andi	r24, 0xF0	; 240
     5e0:	98 27       	eor	r25, r24
     5e2:	2f 76       	andi	r18, 0x6F	; 111
     5e4:	28 2b       	or	r18, r24
     5e6:	62 70       	andi	r22, 0x02	; 2
     5e8:	70 70       	andi	r23, 0x00	; 0
     5ea:	75 95       	asr	r23
     5ec:	67 95       	ror	r22
     5ee:	76 95       	lsr	r23
     5f0:	76 2f       	mov	r23, r22
     5f2:	66 27       	eor	r22, r22
     5f4:	77 95       	ror	r23
     5f6:	67 95       	ror	r22
     5f8:	26 2b       	or	r18, r22
     5fa:	25 b9       	out	0x05, r18	; 5
}
     5fc:	08 95       	ret

000005fe <_ZN7utility13digitalInputsEv>:
    Bit 0 (LSB) matches digital0 ... bit 9 matches digital9.
    @see Use digitalInput() if you only want to read a single digital pin.
 */
uint16_t utility::digitalInputs()
{
	return (uint16_t)((PINA<<2) | (gbis(PINB, PINB7)<<1) | gbis(PINB, PINB4));
     5fe:	40 b1       	in	r20, 0x00	; 0
     600:	83 b1       	in	r24, 0x03	; 3
     602:	23 b1       	in	r18, 0x03	; 3
     604:	30 e0       	ldi	r19, 0x00	; 0
     606:	20 71       	andi	r18, 0x10	; 16
     608:	30 70       	andi	r19, 0x00	; 0
     60a:	35 95       	asr	r19
     60c:	27 95       	ror	r18
     60e:	35 95       	asr	r19
     610:	27 95       	ror	r18
     612:	35 95       	asr	r19
     614:	27 95       	ror	r18
     616:	35 95       	asr	r19
     618:	27 95       	ror	r18
     61a:	50 e0       	ldi	r21, 0x00	; 0
     61c:	44 0f       	add	r20, r20
     61e:	55 1f       	adc	r21, r21
     620:	44 0f       	add	r20, r20
     622:	55 1f       	adc	r21, r21
     624:	24 2b       	or	r18, r20
     626:	35 2b       	or	r19, r21
     628:	88 1f       	adc	r24, r24
     62a:	88 27       	eor	r24, r24
     62c:	88 1f       	adc	r24, r24
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	88 0f       	add	r24, r24
     632:	99 1f       	adc	r25, r25
     634:	28 2b       	or	r18, r24
     636:	39 2b       	or	r19, r25
}
     638:	c9 01       	movw	r24, r18
     63a:	08 95       	ret

0000063c <_ZN7utility19digitalOutputToggleEh>:
    @param num Selects the digital output (0 to 9).
 */
void utility::digitalOutputToggle(const uint8_t num)
{
	//write a 1 to PIN to toggle value of PORT
	if (num > 1)
     63c:	62 30       	cpi	r22, 0x02	; 2
     63e:	68 f0       	brcs	.+26     	; 0x65a <_ZN7utility19digitalOutputToggleEh+0x1e>
		PINA = _BV(num - 2);
     640:	26 2f       	mov	r18, r22
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	22 50       	subi	r18, 0x02	; 2
     646:	30 40       	sbci	r19, 0x00	; 0
     648:	81 e0       	ldi	r24, 0x01	; 1
     64a:	90 e0       	ldi	r25, 0x00	; 0
     64c:	02 c0       	rjmp	.+4      	; 0x652 <_ZN7utility19digitalOutputToggleEh+0x16>
     64e:	88 0f       	add	r24, r24
     650:	99 1f       	adc	r25, r25
     652:	2a 95       	dec	r18
     654:	e2 f7       	brpl	.-8      	; 0x64e <_ZN7utility19digitalOutputToggleEh+0x12>
     656:	80 b9       	out	0x00, r24	; 0
     658:	08 95       	ret
	else if (num == 1)
     65a:	61 30       	cpi	r22, 0x01	; 1
     65c:	19 f0       	breq	.+6      	; 0x664 <_ZN7utility19digitalOutputToggleEh+0x28>
		PINB = _BV(PINB7);
	else if (num == 0)
		PINB = _BV(PINB4);
     65e:	80 e1       	ldi	r24, 0x10	; 16
     660:	83 b9       	out	0x03, r24	; 3
     662:	08 95       	ret
{
	//write a 1 to PIN to toggle value of PORT
	if (num > 1)
		PINA = _BV(num - 2);
	else if (num == 1)
		PINB = _BV(PINB7);
     664:	80 e8       	ldi	r24, 0x80	; 128
     666:	83 b9       	out	0x03, r24	; 3
     668:	08 95       	ret

0000066a <_ZN7utility9softResetEv>:
    Therefore if the USB cable is providing power, the bootloader will do a 10 second countdown.
	@bug This function is correct but is not working properly, probably an issue with the current bootloader or fuse settings.
 */
void utility::softReset()
{
	wdt_enable(WDTO_15MS);
     66a:	28 e0       	ldi	r18, 0x08	; 8
     66c:	88 e1       	ldi	r24, 0x18	; 24
     66e:	90 e0       	ldi	r25, 0x00	; 0
     670:	0f b6       	in	r0, 0x3f	; 63
     672:	f8 94       	cli
     674:	a8 95       	wdr
     676:	80 93 60 00 	sts	0x0060, r24
     67a:	0f be       	out	0x3f, r0	; 63
     67c:	20 93 60 00 	sts	0x0060, r18
     680:	ff cf       	rjmp	.-2      	; 0x680 <_ZN7utility9softResetEv+0x16>

00000682 <_ZN3LCDC2EP16base_text_serialP7utility>:
  a=((a>>1)&0x55)|((a<<1)&0xAA);          \
  a=((a>>2)&0x33)|((a<<2)&0xCC);          \
  asm volatile("swap %0":"=r"(a):"0"(a)); \
} while (0)

LCD::LCD(base_text_serial* p_serial_port, utility* utility_object)  // Constructor for the LCD class
     682:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;          // Store the serial port pointer locally
     684:	71 83       	std	Z+1, r23	; 0x01
     686:	60 83       	st	Z, r22
	
	utility_function = utility_object;
     688:	53 83       	std	Z+3, r21	; 0x03
     68a:	42 83       	std	Z+2, r20	; 0x02
}
     68c:	08 95       	ret

0000068e <_ZN3LCDC1EP16base_text_serialP7utility>:
  a=((a>>1)&0x55)|((a<<1)&0xAA);          \
  a=((a>>2)&0x33)|((a<<2)&0xCC);          \
  asm volatile("swap %0":"=r"(a):"0"(a)); \
} while (0)

LCD::LCD(base_text_serial* p_serial_port, utility* utility_object)  // Constructor for the LCD class
     68e:	fc 01       	movw	r30, r24
{
	ptr_to_serial = p_serial_port;          // Store the serial port pointer locally
     690:	71 83       	std	Z+1, r23	; 0x01
     692:	60 83       	st	Z, r22
	
	utility_function = utility_object;
     694:	53 83       	std	Z+3, r21	; 0x03
     696:	42 83       	std	Z+2, r20	; 0x02
}
     698:	08 95       	ret

0000069a <_ZN3LCD13CursorAddressEv>:
	writeLcd(data);
	//wait for the instruction to be executed
	utility_function->delayUs(100);
}

uint8_t LCD::CursorAddress()
     69a:	ff 92       	push	r15
     69c:	0f 93       	push	r16
     69e:	1f 93       	push	r17
     6a0:	8c 01       	movw	r16, r24
{

	//Disable interrupts to prevent the servo ISR (which shares the same data bus)
	//from interrupting in the middle of the sequence and messing with the bus.
	cli();
     6a2:	f8 94       	cli
	// configure PORTC for input
	DDRC = 0X00;
     6a4:	17 b8       	out	0x07, r1	; 7
	// enable pull-up resistors
	PORTC = 0XFF;
     6a6:	ff 24       	eor	r15, r15
     6a8:	fa 94       	dec	r15
     6aa:	f8 b8       	out	0x08, r15	; 8
	//set RS (Register Select) line low to select command register
	cbi(PORTD, PD7);
     6ac:	5f 98       	cbi	0x0b, 7	; 11
	// set the LCD's R/W line to high to read from the data registers
	sbi(PORTA, PA7);
     6ae:	17 9a       	sbi	0x02, 7	; 2
	//set the LCD's E (Enable) line high, so it can fall later
	sbi(PORTD, PD6);
     6b0:	5e 9a       	sbi	0x0b, 6	; 11
	//wait for the instruction to be executed
	utility_function->delayUs(1);
     6b2:	fc 01       	movw	r30, r24
     6b4:	82 81       	ldd	r24, Z+2	; 0x02
     6b6:	93 81       	ldd	r25, Z+3	; 0x03
     6b8:	61 e0       	ldi	r22, 0x01	; 1
     6ba:	70 e0       	ldi	r23, 0x00	; 0
     6bc:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
	//store the cursor address
	address = PORTC;
     6c0:	88 b1       	in	r24, 0x08	; 8
	//set the LCD's E (Enable) line low
	cbi(PORTD, PD6);
     6c2:	5e 98       	cbi	0x0b, 6	; 11
	//Reverse the bit order of the data, due to LCD connections to the data bus being backwards.
	//This line doesn't affect the bus, so this can be done before the interrupts are disabled.
	REVERSE(address);
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	9c 01       	movw	r18, r24
     6c8:	22 0f       	add	r18, r18
     6ca:	33 1f       	adc	r19, r19
     6cc:	2a 7a       	andi	r18, 0xAA	; 170
     6ce:	95 95       	asr	r25
     6d0:	87 95       	ror	r24
     6d2:	85 75       	andi	r24, 0x55	; 85
     6d4:	28 2b       	or	r18, r24
     6d6:	30 e0       	ldi	r19, 0x00	; 0
     6d8:	c9 01       	movw	r24, r18
     6da:	88 0f       	add	r24, r24
     6dc:	99 1f       	adc	r25, r25
     6de:	88 0f       	add	r24, r24
     6e0:	99 1f       	adc	r25, r25
     6e2:	8c 7c       	andi	r24, 0xCC	; 204
     6e4:	35 95       	asr	r19
     6e6:	27 95       	ror	r18
     6e8:	35 95       	asr	r19
     6ea:	27 95       	ror	r18
     6ec:	23 73       	andi	r18, 0x33	; 51
     6ee:	82 2b       	or	r24, r18
     6f0:	82 95       	swap	r24
     6f2:	f8 01       	movw	r30, r16
     6f4:	84 83       	std	Z+4, r24	; 0x04
	// configure PORTC for output so we can print to the LCD again
	DDRC = 0xFF;
     6f6:	f7 b8       	out	0x07, r15	; 7
	// disable pull-up resistors
	PORTC = 0X00;
     6f8:	18 b8       	out	0x08, r1	; 8
	//set the LCD's R/W line to low so the LCD returns to write mode.
	cbi(PORTA, PA7);
     6fa:	17 98       	cbi	0x02, 7	; 2
	//re-enable interrupts
	sei();
     6fc:	78 94       	sei
	return(address);
	
}
     6fe:	f8 01       	movw	r30, r16
     700:	84 81       	ldd	r24, Z+4	; 0x04
     702:	1f 91       	pop	r17
     704:	0f 91       	pop	r16
     706:	ff 90       	pop	r15
     708:	08 95       	ret

0000070a <_ZN3LCD8writeLcdEh>:
	
	utility_function = utility_object;
}

//! Writes a byte of data to the LCD.
void LCD::writeLcd(uint8_t data)
     70a:	fc 01       	movw	r30, r24
{
	//Reverse the bit order of the data, due to LCD connections to the data bus being backwards.
	//This line doesn't affect the bus, so this can be done before the interrupts are disabled.
	REVERSE(data);
     70c:	70 e0       	ldi	r23, 0x00	; 0
     70e:	cb 01       	movw	r24, r22
     710:	88 0f       	add	r24, r24
     712:	99 1f       	adc	r25, r25
     714:	8a 7a       	andi	r24, 0xAA	; 170
     716:	75 95       	asr	r23
     718:	67 95       	ror	r22
     71a:	65 75       	andi	r22, 0x55	; 85
     71c:	86 2b       	or	r24, r22
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	9c 01       	movw	r18, r24
     722:	22 0f       	add	r18, r18
     724:	33 1f       	adc	r19, r19
     726:	22 0f       	add	r18, r18
     728:	33 1f       	adc	r19, r19
     72a:	2c 7c       	andi	r18, 0xCC	; 204
     72c:	95 95       	asr	r25
     72e:	87 95       	ror	r24
     730:	95 95       	asr	r25
     732:	87 95       	ror	r24
     734:	83 73       	andi	r24, 0x33	; 51
     736:	28 2b       	or	r18, r24
     738:	22 95       	swap	r18
	//Disable interrupts to prevent the servo ISR (which shares the same data bus)
	//from interrupting in the middle of the sequence and messing with the bus.
	cli();
     73a:	f8 94       	cli
	//set the LCD's R/W line low to put the LCD in write mode.
	cbi(PORTA, PA7);
     73c:	17 98       	cbi	0x02, 7	; 2
	//set the LCD's E (Enable) line high, so it can fall later
	sbi(PORTD, PD6);
     73e:	5e 9a       	sbi	0x0b, 6	; 11
	//write the data to the bus
	PORTC = data;
     740:	28 b9       	out	0x08, r18	; 8
	//delay to allow the data to fully propagate to the LCD
	utility_function->delayUs(1);
     742:	82 81       	ldd	r24, Z+2	; 0x02
     744:	93 81       	ldd	r25, Z+3	; 0x03
     746:	61 e0       	ldi	r22, 0x01	; 1
     748:	70 e0       	ldi	r23, 0x00	; 0
     74a:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
	//set the LCD's E (Enable) line low to latch in the data
	cbi(PORTD, PD6);
     74e:	5e 98       	cbi	0x0b, 6	; 11
	//re-enable interrupts
	sei();
     750:	78 94       	sei
}
     752:	08 95       	ret

00000754 <_ZN3LCD9printCharEh>:
}

/*! Prints a single character specified by its ASCII code to the display.
    Most LCDs can also print some special characters, such as those in LCDSpecialChars.h.
 */
void LCD::printChar(const uint8_t data)
     754:	0f 93       	push	r16
     756:	1f 93       	push	r17
     758:	8c 01       	movw	r16, r24
{
	//set RS (Register Select) line high to select data register
	sbi(PORTD, PD7);
     75a:	5f 9a       	sbi	0x0b, 7	; 11
	writeLcd(data);
     75c:	0e 94 85 03 	call	0x70a	; 0x70a <_ZN3LCD8writeLcdEh>
	utility_function->delayUs(50);
     760:	f8 01       	movw	r30, r16
     762:	82 81       	ldd	r24, Z+2	; 0x02
     764:	93 81       	ldd	r25, Z+3	; 0x03
     766:	62 e3       	ldi	r22, 0x32	; 50
     768:	70 e0       	ldi	r23, 0x00	; 0
     76a:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
}
     76e:	1f 91       	pop	r17
     770:	0f 91       	pop	r16
     772:	08 95       	ret

00000774 <_ZN3LCD13printHexDigitEh>:

//! Prints a single uppercase hex digit representing the lower 4 bits of the argument.
void LCD::printHexDigit(uint8_t nibble)
{
	//strip off everything except the lower nibble (4 bits)
	nibble &= 0x0F;
     774:	6f 70       	andi	r22, 0x0F	; 15
	//check what ASCII character offset we need to add
	if (nibble < 10)
     776:	6a 30       	cpi	r22, 0x0A	; 10
     778:	20 f0       	brcs	.+8      	; 0x782 <_ZN3LCD13printHexDigitEh+0xe>
	else
	{
		//print A through F. You can change to lowercase if you want by using 'a' instead.
		//'A' (ASCII char 65) - 10 = 55
		//'a' (ASCII char 97) - 10 = 87
		printChar(nibble + ('A' - 10));
     77a:	69 5c       	subi	r22, 0xC9	; 201
     77c:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
     780:	08 95       	ret
	nibble &= 0x0F;
	//check what ASCII character offset we need to add
	if (nibble < 10)
	{
		//print 0 through 9. ASCII char '0' evaluates to 48.
		printChar(nibble + '0');
     782:	60 5d       	subi	r22, 0xD0	; 208
     784:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
     788:	08 95       	ret

0000078a <_ZN3LCD17printHex_uint16_tEj>:
	//print the lower nibble
	printHexDigit(number);
}

//! Prints a 16-bit unsigned integer as 4 hex digits. Example(65535): "FFFF"
void LCD::printHex_uint16_t(const uint16_t number)
     78a:	ef 92       	push	r14
     78c:	ff 92       	push	r15
     78e:	0f 93       	push	r16
     790:	1f 93       	push	r17
     792:	8c 01       	movw	r16, r24
     794:	7b 01       	movw	r14, r22
{
	//print the high nibble
	printHexDigit((uint8_t)(number >> 12));
     796:	6f 2d       	mov	r22, r15
     798:	62 95       	swap	r22
     79a:	6f 70       	andi	r22, 0x0F	; 15
     79c:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
	//print the upper middle nibble
	printHexDigit((uint8_t)(number >> 8));
     7a0:	c8 01       	movw	r24, r16
     7a2:	6f 2d       	mov	r22, r15
     7a4:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
	//print the lower middle nibble
	printHexDigit(((uint8_t)number) >> 4);
     7a8:	6e 2d       	mov	r22, r14
     7aa:	70 e0       	ldi	r23, 0x00	; 0
     7ac:	75 95       	asr	r23
     7ae:	67 95       	ror	r22
     7b0:	75 95       	asr	r23
     7b2:	67 95       	ror	r22
     7b4:	75 95       	asr	r23
     7b6:	67 95       	ror	r22
     7b8:	75 95       	asr	r23
     7ba:	67 95       	ror	r22
     7bc:	c8 01       	movw	r24, r16
     7be:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
	//print the low nibble
	printHexDigit((uint8_t)number);
     7c2:	c8 01       	movw	r24, r16
     7c4:	6e 2d       	mov	r22, r14
     7c6:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
}
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	08 95       	ret

000007d4 <_ZN3LCD16printHex_uint8_tEh>:
		printChar(nibble + ('A' - 10));
	}
}

//! Prints an 8-bit unsigned integer as 2 hex digits. Example(255): "FF"
void LCD::printHex_uint8_t(const uint8_t number)
     7d4:	ff 92       	push	r15
     7d6:	0f 93       	push	r16
     7d8:	1f 93       	push	r17
     7da:	8c 01       	movw	r16, r24
     7dc:	f6 2e       	mov	r15, r22
{
	//print the upper nibble
	printHexDigit(number >> 4);
     7de:	70 e0       	ldi	r23, 0x00	; 0
     7e0:	75 95       	asr	r23
     7e2:	67 95       	ror	r22
     7e4:	75 95       	asr	r23
     7e6:	67 95       	ror	r22
     7e8:	75 95       	asr	r23
     7ea:	67 95       	ror	r22
     7ec:	75 95       	asr	r23
     7ee:	67 95       	ror	r22
     7f0:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
	//print the lower nibble
	printHexDigit(number);
     7f4:	c8 01       	movw	r24, r16
     7f6:	6f 2d       	mov	r22, r15
     7f8:	0e 94 ba 03 	call	0x774	; 0x774 <_ZN3LCD13printHexDigitEh>
}
     7fc:	1f 91       	pop	r17
     7fe:	0f 91       	pop	r16
     800:	ff 90       	pop	r15
     802:	08 95       	ret

00000804 <_ZN3LCD19printPlain_uint16_tEj>:
	//print the ones digit
	printChar((number % 10) + 48);
}

//! Prints a 16-bit unsigned integer as 1-5 digits (no padding). Example: "42"
void LCD::printPlain_uint16_t(const uint16_t number)
     804:	0f 93       	push	r16
     806:	1f 93       	push	r17
     808:	cf 93       	push	r28
     80a:	df 93       	push	r29
     80c:	8c 01       	movw	r16, r24
     80e:	eb 01       	movw	r28, r22
{
	//if there is a digit in the tens place
	if (number >= 10)
     810:	6a 30       	cpi	r22, 0x0A	; 10
     812:	71 05       	cpc	r23, r1
     814:	80 f0       	brcs	.+32     	; 0x836 <_ZN3LCD19printPlain_uint16_tEj+0x32>
	{
		//if there is a digit in the hundreds place
		if (number >= 100)
     816:	64 36       	cpi	r22, 0x64	; 100
     818:	71 05       	cpc	r23, r1
     81a:	e0 f4       	brcc	.+56     	; 0x854 <_ZN3LCD19printPlain_uint16_tEj+0x50>
			}
			//print the hundreds digit
			printChar(((number % 1000) / 100) + 48);
		}
		//print the tens digit
		printChar(((number % 100 ) / 10) + 48);
     81c:	ce 01       	movw	r24, r28
     81e:	64 e6       	ldi	r22, 0x64	; 100
     820:	70 e0       	ldi	r23, 0x00	; 0
     822:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     826:	6a e0       	ldi	r22, 0x0A	; 10
     828:	70 e0       	ldi	r23, 0x00	; 0
     82a:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     82e:	60 5d       	subi	r22, 0xD0	; 208
     830:	c8 01       	movw	r24, r16
     832:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	}
	//always print the ones digit
	printChar((number % 10) + 48);
     836:	ce 01       	movw	r24, r28
     838:	6a e0       	ldi	r22, 0x0A	; 10
     83a:	70 e0       	ldi	r23, 0x00	; 0
     83c:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     840:	68 2f       	mov	r22, r24
     842:	60 5d       	subi	r22, 0xD0	; 208
     844:	c8 01       	movw	r24, r16
     846:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
}
     84a:	df 91       	pop	r29
     84c:	cf 91       	pop	r28
     84e:	1f 91       	pop	r17
     850:	0f 91       	pop	r16
     852:	08 95       	ret
	{
		//if there is a digit in the hundreds place
		if (number >= 100)
		{
			//if there is a digit in the thousands place
			if (number >= 1000)
     854:	83 e0       	ldi	r24, 0x03	; 3
     856:	68 3e       	cpi	r22, 0xE8	; 232
     858:	78 07       	cpc	r23, r24
     85a:	88 f0       	brcs	.+34     	; 0x87e <_ZN3LCD19printPlain_uint16_tEj+0x7a>
			{
				//if there is a digit in the ten-thousands place
				if (number >= 10000)
     85c:	87 e2       	ldi	r24, 0x27	; 39
     85e:	60 31       	cpi	r22, 0x10	; 16
     860:	78 07       	cpc	r23, r24
     862:	d8 f4       	brcc	.+54     	; 0x89a <_ZN3LCD19printPlain_uint16_tEj+0x96>
				{
					//print the ten-thousands digit
					printChar((number / 10000) + 48);
				}
				//print the thousands digit
				printChar(((number % 10000) / 1000) + 48);
     864:	ce 01       	movw	r24, r28
     866:	60 e1       	ldi	r22, 0x10	; 16
     868:	77 e2       	ldi	r23, 0x27	; 39
     86a:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     86e:	68 ee       	ldi	r22, 0xE8	; 232
     870:	73 e0       	ldi	r23, 0x03	; 3
     872:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     876:	60 5d       	subi	r22, 0xD0	; 208
     878:	c8 01       	movw	r24, r16
     87a:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
			}
			//print the hundreds digit
			printChar(((number % 1000) / 100) + 48);
     87e:	ce 01       	movw	r24, r28
     880:	68 ee       	ldi	r22, 0xE8	; 232
     882:	73 e0       	ldi	r23, 0x03	; 3
     884:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     888:	64 e6       	ldi	r22, 0x64	; 100
     88a:	70 e0       	ldi	r23, 0x00	; 0
     88c:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     890:	60 5d       	subi	r22, 0xD0	; 208
     892:	c8 01       	movw	r24, r16
     894:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
     898:	c1 cf       	rjmp	.-126    	; 0x81c <_ZN3LCD19printPlain_uint16_tEj+0x18>
			{
				//if there is a digit in the ten-thousands place
				if (number >= 10000)
				{
					//print the ten-thousands digit
					printChar((number / 10000) + 48);
     89a:	cb 01       	movw	r24, r22
     89c:	60 e1       	ldi	r22, 0x10	; 16
     89e:	77 e2       	ldi	r23, 0x27	; 39
     8a0:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     8a4:	60 5d       	subi	r22, 0xD0	; 208
     8a6:	c8 01       	movw	r24, r16
     8a8:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
     8ac:	db cf       	rjmp	.-74     	; 0x864 <_ZN3LCD19printPlain_uint16_tEj+0x60>

000008ae <_ZN3LCD18printPlain_int16_tEi>:
		print_uint16_t((uint16_t)(-number));
	}
}

//! Prints a 16-bit signed integer as +/- and 1-5 digits (no padding). Example: "+42"
void LCD::printPlain_int16_t(const int16_t number)
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	8c 01       	movw	r16, r24
     8b8:	eb 01       	movw	r28, r22
{
	if (number >= 0)
     8ba:	77 fd       	sbrc	r23, 7
     8bc:	0c c0       	rjmp	.+24     	; 0x8d6 <_ZN3LCD18printPlain_int16_tEi+0x28>
	{
		//print plus
		printChar('+');
     8be:	6b e2       	ldi	r22, 0x2B	; 43
     8c0:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//cast to print the number as a u16
		printPlain_uint16_t((uint16_t)number);
     8c4:	c8 01       	movw	r24, r16
     8c6:	be 01       	movw	r22, r28
     8c8:	0e 94 02 04 	call	0x804	; 0x804 <_ZN3LCD19printPlain_uint16_tEj>
		//print minus
		printChar('-');
		//make the number positive and print it as a u16
		printPlain_uint16_t((uint16_t)(-number));
	}
}
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	1f 91       	pop	r17
     8d2:	0f 91       	pop	r16
     8d4:	08 95       	ret
		printPlain_uint16_t((uint16_t)number);
	}
	else
	{
		//print minus
		printChar('-');
     8d6:	6d e2       	ldi	r22, 0x2D	; 45
     8d8:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//make the number positive and print it as a u16
		printPlain_uint16_t((uint16_t)(-number));
     8dc:	66 27       	eor	r22, r22
     8de:	77 27       	eor	r23, r23
     8e0:	6c 1b       	sub	r22, r28
     8e2:	7d 0b       	sbc	r23, r29
     8e4:	c8 01       	movw	r24, r16
     8e6:	0e 94 02 04 	call	0x804	; 0x804 <_ZN3LCD19printPlain_uint16_tEj>
	}
}
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	1f 91       	pop	r17
     8f0:	0f 91       	pop	r16
     8f2:	08 95       	ret

000008f4 <_ZN3LCD14print_uint16_tEj>:
		printPlain_uint8_t((uint8_t)(-number));
	}
}

//! Prints a 16-bit unsigned integer as 5 digits (with '0' padding in front). Example: "00042"
void LCD::print_uint16_t(const uint16_t number)
     8f4:	ef 92       	push	r14
     8f6:	ff 92       	push	r15
     8f8:	0f 93       	push	r16
     8fa:	1f 93       	push	r17
     8fc:	7c 01       	movw	r14, r24
     8fe:	8b 01       	movw	r16, r22
{
	//print the ten-thousands digit
	printChar((number / 10000) + 48);
     900:	cb 01       	movw	r24, r22
     902:	60 e1       	ldi	r22, 0x10	; 16
     904:	77 e2       	ldi	r23, 0x27	; 39
     906:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     90a:	60 5d       	subi	r22, 0xD0	; 208
     90c:	c7 01       	movw	r24, r14
     90e:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print the thousands digit
	printChar(((number % 10000) / 1000) + 48);
     912:	c8 01       	movw	r24, r16
     914:	60 e1       	ldi	r22, 0x10	; 16
     916:	77 e2       	ldi	r23, 0x27	; 39
     918:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     91c:	68 ee       	ldi	r22, 0xE8	; 232
     91e:	73 e0       	ldi	r23, 0x03	; 3
     920:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     924:	60 5d       	subi	r22, 0xD0	; 208
     926:	c7 01       	movw	r24, r14
     928:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print the hundreds digit
	printChar(((number % 1000) / 100) + 48);
     92c:	c8 01       	movw	r24, r16
     92e:	68 ee       	ldi	r22, 0xE8	; 232
     930:	73 e0       	ldi	r23, 0x03	; 3
     932:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     936:	64 e6       	ldi	r22, 0x64	; 100
     938:	70 e0       	ldi	r23, 0x00	; 0
     93a:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     93e:	60 5d       	subi	r22, 0xD0	; 208
     940:	c7 01       	movw	r24, r14
     942:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print the tens digit
	printChar(((number % 100 ) / 10) + 48);
     946:	c8 01       	movw	r24, r16
     948:	64 e6       	ldi	r22, 0x64	; 100
     94a:	70 e0       	ldi	r23, 0x00	; 0
     94c:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     950:	6a e0       	ldi	r22, 0x0A	; 10
     952:	70 e0       	ldi	r23, 0x00	; 0
     954:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     958:	60 5d       	subi	r22, 0xD0	; 208
     95a:	c7 01       	movw	r24, r14
     95c:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print the ones digit
	printChar((number % 10) + 48);
     960:	c8 01       	movw	r24, r16
     962:	6a e0       	ldi	r22, 0x0A	; 10
     964:	70 e0       	ldi	r23, 0x00	; 0
     966:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
     96a:	68 2f       	mov	r22, r24
     96c:	60 5d       	subi	r22, 0xD0	; 208
     96e:	c7 01       	movw	r24, r14
     970:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
}
     974:	1f 91       	pop	r17
     976:	0f 91       	pop	r16
     978:	ff 90       	pop	r15
     97a:	ef 90       	pop	r14
     97c:	08 95       	ret

0000097e <_ZN3LCD13print_int16_tEi>:
	//always print the ones digit
	printChar((number % 10) + 48);
}

//! Prints a 16-bit signed integer as +/- and 5 digits (with '0' padding in front). Example: "+00042"
void LCD::print_int16_t(const int16_t number)
     97e:	0f 93       	push	r16
     980:	1f 93       	push	r17
     982:	cf 93       	push	r28
     984:	df 93       	push	r29
     986:	8c 01       	movw	r16, r24
     988:	eb 01       	movw	r28, r22
{
	if (number >= 0)
     98a:	77 fd       	sbrc	r23, 7
     98c:	0c c0       	rjmp	.+24     	; 0x9a6 <_ZN3LCD13print_int16_tEi+0x28>
	{
		//print plus
		printChar('+');
     98e:	6b e2       	ldi	r22, 0x2B	; 43
     990:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//cast to print the number as a u16
		print_uint16_t((uint16_t)number);
     994:	c8 01       	movw	r24, r16
     996:	be 01       	movw	r22, r28
     998:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <_ZN3LCD14print_uint16_tEj>
		//print minus
		printChar('-');
		//make the number positive and print it as a u16
		print_uint16_t((uint16_t)(-number));
	}
}
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	08 95       	ret
		print_uint16_t((uint16_t)number);
	}
	else
	{
		//print minus
		printChar('-');
     9a6:	6d e2       	ldi	r22, 0x2D	; 45
     9a8:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//make the number positive and print it as a u16
		print_uint16_t((uint16_t)(-number));
     9ac:	66 27       	eor	r22, r22
     9ae:	77 27       	eor	r23, r23
     9b0:	6c 1b       	sub	r22, r28
     9b2:	7d 0b       	sbc	r23, r29
     9b4:	c8 01       	movw	r24, r16
     9b6:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <_ZN3LCD14print_uint16_tEj>
	}
}
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	1f 91       	pop	r17
     9c0:	0f 91       	pop	r16
     9c2:	08 95       	ret

000009c4 <_ZN3LCD18printPlain_uint8_tEh>:
	//print ones digit
	printChar((number % 10) + 48);
}

//! Prints an 8-bit unsigned integer as 1-3 digits (no padding). Example: "7"
void LCD::printPlain_uint8_t(const uint8_t number)
     9c4:	1f 93       	push	r17
     9c6:	cf 93       	push	r28
     9c8:	df 93       	push	r29
     9ca:	ec 01       	movw	r28, r24
     9cc:	16 2f       	mov	r17, r22
{
	//if there is a digit in the tens place
	if (number >= 10)
     9ce:	6a 30       	cpi	r22, 0x0A	; 10
     9d0:	78 f0       	brcs	.+30     	; 0x9f0 <_ZN3LCD18printPlain_uint8_tEh+0x2c>
	{
		//if there is a digit in the hundreds place
		if (number >= 100)
     9d2:	64 36       	cpi	r22, 0x64	; 100
     9d4:	d0 f4       	brcc	.+52     	; 0xa0a <_ZN3LCD18printPlain_uint8_tEh+0x46>
		{
			//print the hundreds digit
			printChar((number / 100) + 48);
		}
		//print the tens digit
		printChar(((number % 100 ) / 10) + 48);
     9d6:	81 2f       	mov	r24, r17
     9d8:	64 e6       	ldi	r22, 0x64	; 100
     9da:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     9de:	89 2f       	mov	r24, r25
     9e0:	6a e0       	ldi	r22, 0x0A	; 10
     9e2:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     9e6:	68 2f       	mov	r22, r24
     9e8:	60 5d       	subi	r22, 0xD0	; 208
     9ea:	ce 01       	movw	r24, r28
     9ec:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	}
	//always print the ones digit
	printChar((number % 10) + 48);
     9f0:	81 2f       	mov	r24, r17
     9f2:	6a e0       	ldi	r22, 0x0A	; 10
     9f4:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     9f8:	69 2f       	mov	r22, r25
     9fa:	60 5d       	subi	r22, 0xD0	; 208
     9fc:	ce 01       	movw	r24, r28
     9fe:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	1f 91       	pop	r17
     a08:	08 95       	ret
	{
		//if there is a digit in the hundreds place
		if (number >= 100)
		{
			//print the hundreds digit
			printChar((number / 100) + 48);
     a0a:	86 2f       	mov	r24, r22
     a0c:	64 e6       	ldi	r22, 0x64	; 100
     a0e:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     a12:	68 2f       	mov	r22, r24
     a14:	60 5d       	subi	r22, 0xD0	; 208
     a16:	ce 01       	movw	r24, r28
     a18:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
     a1c:	dc cf       	rjmp	.-72     	; 0x9d6 <_ZN3LCD18printPlain_uint8_tEh+0x12>

00000a1e <_ZN3LCD17printPlain_int8_tEa>:
		print_uint8_t((uint8_t)(-number));
	}
}

//! Prints an 8-bit signed integer as +/- and 1-3 digits (no padding). Example: "+7"
void LCD::printPlain_int8_t(const int8_t number)
     a1e:	1f 93       	push	r17
     a20:	cf 93       	push	r28
     a22:	df 93       	push	r29
     a24:	ec 01       	movw	r28, r24
     a26:	16 2f       	mov	r17, r22
{
	if (number >= 0)
     a28:	67 fd       	sbrc	r22, 7
     a2a:	0b c0       	rjmp	.+22     	; 0xa42 <_ZN3LCD17printPlain_int8_tEa+0x24>
	{
		//print plus
		printChar('+');
     a2c:	6b e2       	ldi	r22, 0x2B	; 43
     a2e:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//cast to print the number as a u08
		printPlain_uint8_t((uint8_t)number);
     a32:	ce 01       	movw	r24, r28
     a34:	61 2f       	mov	r22, r17
     a36:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <_ZN3LCD18printPlain_uint8_tEh>
		//print minus
		printChar('-');
		//make the number positive and print it as a u08
		printPlain_uint8_t((uint8_t)(-number));
	}
}
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	1f 91       	pop	r17
     a40:	08 95       	ret
		printPlain_uint8_t((uint8_t)number);
	}
	else
	{
		//print minus
		printChar('-');
     a42:	6d e2       	ldi	r22, 0x2D	; 45
     a44:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//make the number positive and print it as a u08
		printPlain_uint8_t((uint8_t)(-number));
     a48:	11 95       	neg	r17
     a4a:	ce 01       	movw	r24, r28
     a4c:	61 2f       	mov	r22, r17
     a4e:	0e 94 e2 04 	call	0x9c4	; 0x9c4 <_ZN3LCD18printPlain_uint8_tEh>
	}
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	08 95       	ret

00000a5a <_ZN3LCD13print_uint8_tEh>:
		printChar(string[i++]);
	}
}

//! Prints an 8-bit unsigned integer as 3 digits (with '0' padding in front). Example: "007"
void LCD::print_uint8_t(const uint8_t number)
     a5a:	ff 92       	push	r15
     a5c:	0f 93       	push	r16
     a5e:	1f 93       	push	r17
     a60:	8c 01       	movw	r16, r24
     a62:	f6 2e       	mov	r15, r22
{
	//print hundreds digit
	printChar((number / 100) + 48);
     a64:	86 2f       	mov	r24, r22
     a66:	64 e6       	ldi	r22, 0x64	; 100
     a68:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     a6c:	68 2f       	mov	r22, r24
     a6e:	60 5d       	subi	r22, 0xD0	; 208
     a70:	c8 01       	movw	r24, r16
     a72:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print tens digit
	printChar(((number % 100 ) / 10) + 48);
     a76:	8f 2d       	mov	r24, r15
     a78:	64 e6       	ldi	r22, 0x64	; 100
     a7a:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     a7e:	89 2f       	mov	r24, r25
     a80:	6a e0       	ldi	r22, 0x0A	; 10
     a82:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     a86:	68 2f       	mov	r22, r24
     a88:	60 5d       	subi	r22, 0xD0	; 208
     a8a:	c8 01       	movw	r24, r16
     a8c:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
	//print ones digit
	printChar((number % 10) + 48);
     a90:	8f 2d       	mov	r24, r15
     a92:	6a e0       	ldi	r22, 0x0A	; 10
     a94:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     a98:	69 2f       	mov	r22, r25
     a9a:	60 5d       	subi	r22, 0xD0	; 208
     a9c:	c8 01       	movw	r24, r16
     a9e:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
}
     aa2:	1f 91       	pop	r17
     aa4:	0f 91       	pop	r16
     aa6:	ff 90       	pop	r15
     aa8:	08 95       	ret

00000aaa <_ZN3LCD12print_int8_tEa>:
	//always print the ones digit
	printChar((number % 10) + 48);
}

//! Prints an 8-bit signed integer as +/- and 3 digits (with '0' padding in front). Example: "+007"
void LCD::print_int8_t(const int8_t number)
     aaa:	1f 93       	push	r17
     aac:	cf 93       	push	r28
     aae:	df 93       	push	r29
     ab0:	ec 01       	movw	r28, r24
     ab2:	16 2f       	mov	r17, r22
{
	if (number >= 0)
     ab4:	67 fd       	sbrc	r22, 7
     ab6:	0b c0       	rjmp	.+22     	; 0xace <_ZN3LCD12print_int8_tEa+0x24>
	{
		//print plus
		printChar('+');
     ab8:	6b e2       	ldi	r22, 0x2B	; 43
     aba:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//cast to print the number as a u08
		print_uint8_t((uint8_t)number);
     abe:	ce 01       	movw	r24, r28
     ac0:	61 2f       	mov	r22, r17
     ac2:	0e 94 2d 05 	call	0xa5a	; 0xa5a <_ZN3LCD13print_uint8_tEh>
		//print minus
		printChar('-');
		//make the number positive and print it as a u08
		print_uint8_t((uint8_t)(-number));
	}
}
     ac6:	df 91       	pop	r29
     ac8:	cf 91       	pop	r28
     aca:	1f 91       	pop	r17
     acc:	08 95       	ret
		print_uint8_t((uint8_t)number);
	}
	else
	{
		//print minus
		printChar('-');
     ace:	6d e2       	ldi	r22, 0x2D	; 45
     ad0:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		//make the number positive and print it as a u08
		print_uint8_t((uint8_t)(-number));
     ad4:	11 95       	neg	r17
     ad6:	ce 01       	movw	r24, r28
     ad8:	61 2f       	mov	r22, r17
     ada:	0e 94 2d 05 	call	0xa5a	; 0xa5a <_ZN3LCD13print_uint8_tEh>
	}
}
     ade:	df 91       	pop	r29
     ae0:	cf 91       	pop	r28
     ae2:	1f 91       	pop	r17
     ae4:	08 95       	ret

00000ae6 <_ZN3LCD11printStringEPKc>:
/*! Prints a null-terminated string starting at the current cursor position.
    Strings exceeding the length of the display go into the display's buffer.
    This is useful if you are using the scrolling option, but wastes write time otherwise.
    Once the buffer for the first line has been filled, the cursor wraps to the next line.
 */
void LCD::printString(const char *const string)
     ae6:	ef 92       	push	r14
     ae8:	ff 92       	push	r15
     aea:	1f 93       	push	r17
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	7c 01       	movw	r14, r24
     af2:	eb 01       	movw	r28, r22
{
	uint8_t i = 0;
	//keep printing until we encounter a null terminator
	while (string[i] != 0)
     af4:	68 81       	ld	r22, Y
     af6:	66 23       	and	r22, r22
     af8:	59 f0       	breq	.+22     	; 0xb10 <_ZN3LCD11printStringEPKc+0x2a>
     afa:	10 e0       	ldi	r17, 0x00	; 0
	{
		printChar(string[i++]);
     afc:	1f 5f       	subi	r17, 0xFF	; 255
     afe:	c7 01       	movw	r24, r14
     b00:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
 */
void LCD::printString(const char *const string)
{
	uint8_t i = 0;
	//keep printing until we encounter a null terminator
	while (string[i] != 0)
     b04:	fe 01       	movw	r30, r28
     b06:	e1 0f       	add	r30, r17
     b08:	f1 1d       	adc	r31, r1
     b0a:	60 81       	ld	r22, Z
     b0c:	66 23       	and	r22, r22
     b0e:	b1 f7       	brne	.-20     	; 0xafc <_ZN3LCD11printStringEPKc+0x16>
	{
		printChar(string[i++]);
	}
}
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28
     b14:	1f 91       	pop	r17
     b16:	ff 90       	pop	r15
     b18:	ef 90       	pop	r14
     b1a:	08 95       	ret

00000b1c <_ZN3LCD10printFloatEf>:
	//print the low nibble
	printHexDigit((uint8_t)number);
}

//! Prints a floating point number.
void LCD::printFloat(const float number)
     b1c:	cf 92       	push	r12
     b1e:	df 92       	push	r13
     b20:	ef 92       	push	r14
     b22:	ff 92       	push	r15
     b24:	0f 93       	push	r16
     b26:	df 93       	push	r29
     b28:	cf 93       	push	r28
     b2a:	cd b7       	in	r28, 0x3d	; 61
     b2c:	de b7       	in	r29, 0x3e	; 62
     b2e:	2a 97       	sbiw	r28, 0x0a	; 10
     b30:	0f b6       	in	r0, 0x3f	; 63
     b32:	f8 94       	cli
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	cd bf       	out	0x3d, r28	; 61
     b3a:	7c 01       	movw	r14, r24
{
	char s[10];
	dtostre(number, s, 3, 0);
     b3c:	cb 01       	movw	r24, r22
     b3e:	ba 01       	movw	r22, r20
     b40:	6e 01       	movw	r12, r28
     b42:	08 94       	sec
     b44:	c1 1c       	adc	r12, r1
     b46:	d1 1c       	adc	r13, r1
     b48:	a6 01       	movw	r20, r12
     b4a:	23 e0       	ldi	r18, 0x03	; 3
     b4c:	00 e0       	ldi	r16, 0x00	; 0
     b4e:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <dtostre>
	printString(s);
     b52:	c7 01       	movw	r24, r14
     b54:	b6 01       	movw	r22, r12
     b56:	0e 94 73 05 	call	0xae6	; 0xae6 <_ZN3LCD11printStringEPKc>
}
     b5a:	2a 96       	adiw	r28, 0x0a	; 10
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	cd bf       	out	0x3d, r28	; 61
     b66:	cf 91       	pop	r28
     b68:	df 91       	pop	r29
     b6a:	0f 91       	pop	r16
     b6c:	ff 90       	pop	r15
     b6e:	ef 90       	pop	r14
     b70:	df 90       	pop	r13
     b72:	cf 90       	pop	r12
     b74:	08 95       	ret

00000b76 <_ZN3LCD12writeControlEh>:
	//re-enable interrupts
	sei();
}

//! Writes a command byte to the LCD.
void LCD::writeControl(const uint8_t data)
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	8c 01       	movw	r16, r24
{
	//set RS (Register Select) line low to select command register
	cbi(PORTD, PD7);
     b7c:	5f 98       	cbi	0x0b, 7	; 11
	writeLcd(data);
     b7e:	0e 94 85 03 	call	0x70a	; 0x70a <_ZN3LCD8writeLcdEh>
	//wait for the instruction to be executed
	utility_function->delayUs(100);
     b82:	f8 01       	movw	r30, r16
     b84:	82 81       	ldd	r24, Z+2	; 0x02
     b86:	93 81       	ldd	r25, Z+3	; 0x03
     b88:	64 e6       	ldi	r22, 0x64	; 100
     b8a:	70 e0       	ldi	r23, 0x00	; 0
     b8c:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
}
     b90:	1f 91       	pop	r17
     b92:	0f 91       	pop	r16
     b94:	08 95       	ret

00000b96 <_ZN3LCD9lcdCursorEhh>:

/*! Moves the LCD cursor position directly to the specified row and column.
    @param row Valid row values are 0 to 1.
    @param column Valid column values are 0 to 15.
 */
void LCD::lcdCursor(const uint8_t row, const uint8_t column)
     b96:	9c 01       	movw	r18, r24
     b98:	56 2f       	mov	r21, r22
     b9a:	84 2f       	mov	r24, r20
{
	writeControl(HOME | (row << 6) | (column % 17));
     b9c:	52 95       	swap	r21
     b9e:	55 0f       	add	r21, r21
     ba0:	55 0f       	add	r21, r21
     ba2:	50 7c       	andi	r21, 0xC0	; 192
     ba4:	61 e1       	ldi	r22, 0x11	; 17
     ba6:	0e 94 90 10 	call	0x2120	; 0x2120 <__udivmodqi4>
     baa:	59 2b       	or	r21, r25
     bac:	50 68       	ori	r21, 0x80	; 128
     bae:	c9 01       	movw	r24, r18
     bb0:	65 2f       	mov	r22, r21
     bb2:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bb6:	08 95       	ret

00000bb8 <_ZN3LCD9lowerLineEv>:
}

//! Moves the LCD cursor to the beginning of the second line of the display (row 1, col 0).
void LCD::lowerLine()
{
	writeControl(SECOND_LINE);
     bb8:	60 ec       	ldi	r22, 0xC0	; 192
     bba:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bbe:	08 95       	ret

00000bc0 <_ZN3LCD12upperLineEndEv>:
	writeControl(HOME);
}

void LCD::upperLineEnd()
{
	writeControl(FIRST_LINE_END);
     bc0:	6f e8       	ldi	r22, 0x8F	; 143
     bc2:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bc6:	08 95       	ret

00000bc8 <_ZN3LCD9upperLineEv>:
}

//! Moves the LCD cursor to the beginning of the first line of the display (row 0, col 0).
void LCD::upperLine()
{
	writeControl(HOME);
     bc8:	60 e8       	ldi	r22, 0x80	; 128
     bca:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bce:	08 95       	ret

00000bd0 <_ZN3LCD18lcdCursorDecrementEv>:
	writeControl(0x06);
}

void LCD::lcdCursorDecrement()
{
	writeControl(0x04);
     bd0:	64 e0       	ldi	r22, 0x04	; 4
     bd2:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bd6:	08 95       	ret

00000bd8 <_ZN3LCD18lcdCursorIncrementEv>:
	writeControl(0x0D);
}

void LCD::lcdCursorIncrement()
{
	writeControl(0x06);
     bd8:	66 e0       	ldi	r22, 0x06	; 6
     bda:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bde:	08 95       	ret

00000be0 <_ZN3LCD14lcdCursorBlinkEv>:
	writeControl(0x0C);
}

void LCD::lcdCursorBlink()
{
	writeControl(0x0D);
     be0:	6d e0       	ldi	r22, 0x0D	; 13
     be2:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     be6:	08 95       	ret

00000be8 <_ZN3LCD12lcdCursorOffEv>:
	writeControl(0x0E);
}

void LCD::lcdCursorOff()
{
	writeControl(0x0C);
     be8:	6c e0       	ldi	r22, 0x0C	; 12
     bea:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bee:	08 95       	ret

00000bf0 <_ZN3LCD11lcdCursorOnEv>:
	writeControl(0x08);
}

void LCD::lcdCursorOn()
{
	writeControl(0x0E);
     bf0:	6e e0       	ldi	r22, 0x0E	; 14
     bf2:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bf6:	08 95       	ret

00000bf8 <_ZN3LCD6lcdOffEv>:
}

//! Hides the characters on the screen. Can be unhidden again with lcdOn().
void LCD::lcdOff()
{
	writeControl(0x08);
     bf8:	68 e0       	ldi	r22, 0x08	; 8
     bfa:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     bfe:	08 95       	ret

00000c00 <_ZN3LCD5lcdOnEv>:
}

//! Shows the characters on the screen, if they were hidden with lcdOff().
void LCD::lcdOn()
{
	writeControl(0x0C);
     c00:	6c e0       	ldi	r22, 0x0C	; 12
     c02:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
}
     c06:	08 95       	ret

00000c08 <_ZN3LCD11clearScreenEv>:
	return(address);
	
}

//! Clears all characters on the display and resets the cursor to the home position.
void LCD::clearScreen()
     c08:	0f 93       	push	r16
     c0a:	1f 93       	push	r17
     c0c:	8c 01       	movw	r16, r24
{
	writeControl(0x01);
     c0e:	61 e0       	ldi	r22, 0x01	; 1
     c10:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
	utility_function->delayUs(3300);
     c14:	f8 01       	movw	r30, r16
     c16:	82 81       	ldd	r24, Z+2	; 0x02
     c18:	93 81       	ldd	r25, Z+3	; 0x03
     c1a:	64 ee       	ldi	r22, 0xE4	; 228
     c1c:	7c e0       	ldi	r23, 0x0C	; 12
     c1e:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
}
     c22:	1f 91       	pop	r17
     c24:	0f 91       	pop	r16
     c26:	08 95       	ret

00000c28 <_ZN3LCD7lcdInitEv>:
	writeControl(0x04);
}
/*! Initializes the LCD as described in the HD44780 datasheet.
    Normally called only by the initialize() function in utility.cpp
 */
void LCD::lcdInit()
     c28:	0f 93       	push	r16
     c2a:	1f 93       	push	r17
     c2c:	8c 01       	movw	r16, r24
{
	//configure LCD E (Enable) control pin as an output
	sbi(DDRD, DDD6);
     c2e:	56 9a       	sbi	0x0a, 6	; 10
	//configure LCD RS (Register Select) control pin as an output
	sbi(DDRD, DDD7);
     c30:	57 9a       	sbi	0x0a, 7	; 10
	//configure LCD R/W (Read/Write) control pin as an output
	sbi(DDRA, DDA7);
     c32:	0f 9a       	sbi	0x01, 7	; 1
	//set LCD R/W (Read/Write) control pin low initially
	cbi(PORTA, PA7);
     c34:	17 98       	cbi	0x02, 7	; 2
	//set LCD E (Enable) line low inititally, so it can rise later
	cbi(PORTD, PD6);
     c36:	5e 98       	cbi	0x0b, 6	; 11

	//wait 15ms after power on
	utility_function->delayMs(15);
     c38:	fc 01       	movw	r30, r24
     c3a:	82 81       	ldd	r24, Z+2	; 0x02
     c3c:	93 81       	ldd	r25, Z+3	; 0x03
     c3e:	6f e0       	ldi	r22, 0x0F	; 15
     c40:	70 e0       	ldi	r23, 0x00	; 0
     c42:	0e 94 8f 01 	call	0x31e	; 0x31e <_ZN7utility7delayMsEj>

	//Issue 'Function Set' commands to initialize LCD for 8-bit interface mode
	writeControl(0x38);
     c46:	c8 01       	movw	r24, r16
     c48:	68 e3       	ldi	r22, 0x38	; 56
     c4a:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
	utility_function->delayUs(4900); //+100us in writeControl = 5000us or 5ms total
     c4e:	f8 01       	movw	r30, r16
     c50:	82 81       	ldd	r24, Z+2	; 0x02
     c52:	93 81       	ldd	r25, Z+3	; 0x03
     c54:	64 e2       	ldi	r22, 0x24	; 36
     c56:	73 e1       	ldi	r23, 0x13	; 19
     c58:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
	writeControl(0x38);
     c5c:	c8 01       	movw	r24, r16
     c5e:	68 e3       	ldi	r22, 0x38	; 56
     c60:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>
	utility_function->delayUs(50); //+100us in writeControl = 150us total
     c64:	f8 01       	movw	r30, r16
     c66:	82 81       	ldd	r24, Z+2	; 0x02
     c68:	93 81       	ldd	r25, Z+3	; 0x03
     c6a:	62 e3       	ldi	r22, 0x32	; 50
     c6c:	70 e0       	ldi	r23, 0x00	; 0
     c6e:	0e 94 9b 01 	call	0x336	; 0x336 <_ZN7utility7delayUsEj>
	writeControl(0x38);
     c72:	c8 01       	movw	r24, r16
     c74:	68 e3       	ldi	r22, 0x38	; 56
     c76:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>

	//Function Set command to specify 2 display lines and character font
	writeControl(0x38);
     c7a:	c8 01       	movw	r24, r16
     c7c:	68 e3       	ldi	r22, 0x38	; 56
     c7e:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>

	//Display off
	lcdOff();
     c82:	c8 01       	movw	r24, r16
     c84:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <_ZN3LCD6lcdOffEv>

	//Clear display
	clearScreen();
     c88:	c8 01       	movw	r24, r16
     c8a:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3LCD11clearScreenEv>

	//Set entry mode
	writeControl(0x06);
     c8e:	c8 01       	movw	r24, r16
     c90:	66 e0       	ldi	r22, 0x06	; 6
     c92:	0e 94 bb 05 	call	0xb76	; 0xb76 <_ZN3LCD12writeControlEh>

	//Display on
	lcdOn();
     c96:	c8 01       	movw	r24, r16
     c98:	0e 94 00 06 	call	0xc00	; 0xc00 <_ZN3LCD5lcdOnEv>
}
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	08 95       	ret

00000ca2 <_ZN8keyboard12clear_screenEv>:
		LCD_function->printChar(0x20);
		LCD_function->lcdCursor(r1, c1);
		return;
	}
}	
void keyboard::clear_screen()
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	8c 01       	movw	r16, r24
{
	LCD_function->clearScreen();
     ca8:	fc 01       	movw	r30, r24
     caa:	80 81       	ld	r24, Z
     cac:	91 81       	ldd	r25, Z+1	; 0x01
     cae:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3LCD11clearScreenEv>
	LCD_function->upperLine();
     cb2:	f8 01       	movw	r30, r16
     cb4:	80 81       	ld	r24, Z
     cb6:	91 81       	ldd	r25, Z+1	; 0x01
     cb8:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <_ZN3LCD9upperLineEv>
	c1 = 0;
     cbc:	f8 01       	movw	r30, r16
     cbe:	13 82       	std	Z+3, r1	; 0x03
	r1 = 0;
     cc0:	12 82       	std	Z+2, r1	; 0x02
	return;
}
     cc2:	1f 91       	pop	r17
     cc4:	0f 91       	pop	r16
     cc6:	08 95       	ret

00000cc8 <_ZN8keyboard13delete_a_charEv>:
			LCD_function->lowerLine();
			return;
		}
	}
}
void keyboard::delete_a_char()
     cc8:	cf 93       	push	r28
     cca:	df 93       	push	r29
     ccc:	ec 01       	movw	r28, r24
{
	if (c1 == 0 && r1 == 0)
     cce:	4b 81       	ldd	r20, Y+3	; 0x03
     cd0:	44 23       	and	r20, r20
     cd2:	29 f4       	brne	.+10     	; 0xcde <_ZN8keyboard13delete_a_charEv+0x16>
     cd4:	8a 81       	ldd	r24, Y+2	; 0x02
     cd6:	88 23       	and	r24, r24
     cd8:	a1 f0       	breq	.+40     	; 0xd02 <_ZN8keyboard13delete_a_charEv+0x3a>
	{
		return;
	}
	else if (c1 == 0 && r1 == 1)
     cda:	81 30       	cpi	r24, 0x01	; 1
     cdc:	a9 f0       	breq	.+42     	; 0xd08 <_ZN8keyboard13delete_a_charEv+0x40>
		LCD_function->upperLineEnd();
		return;
	}
	else
	{
		c1--;
     cde:	41 50       	subi	r20, 0x01	; 1
     ce0:	4b 83       	std	Y+3, r20	; 0x03
		LCD_function->lcdCursor(r1, c1);
     ce2:	88 81       	ld	r24, Y
     ce4:	99 81       	ldd	r25, Y+1	; 0x01
     ce6:	6a 81       	ldd	r22, Y+2	; 0x02
     ce8:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN3LCD9lcdCursorEhh>
		LCD_function->printChar(0x20);
     cec:	88 81       	ld	r24, Y
     cee:	99 81       	ldd	r25, Y+1	; 0x01
     cf0:	60 e2       	ldi	r22, 0x20	; 32
     cf2:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		LCD_function->lcdCursor(r1, c1);
     cf6:	88 81       	ld	r24, Y
     cf8:	99 81       	ldd	r25, Y+1	; 0x01
     cfa:	6a 81       	ldd	r22, Y+2	; 0x02
     cfc:	4b 81       	ldd	r20, Y+3	; 0x03
     cfe:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN3LCD9lcdCursorEhh>
		return;
	}
}	
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	08 95       	ret
	{
		return;
	}
	else if (c1 == 0 && r1 == 1)
	{
		c1 = 15;
     d08:	8f e0       	ldi	r24, 0x0F	; 15
     d0a:	8b 83       	std	Y+3, r24	; 0x03
		r1 = 0;
     d0c:	1a 82       	std	Y+2, r1	; 0x02
		LCD_function->upperLineEnd();
     d0e:	88 81       	ld	r24, Y
     d10:	99 81       	ldd	r25, Y+1	; 0x01
     d12:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <_ZN3LCD12upperLineEndEv>
		LCD_function->printChar(0x20);
     d16:	88 81       	ld	r24, Y
     d18:	99 81       	ldd	r25, Y+1	; 0x01
     d1a:	60 e2       	ldi	r22, 0x20	; 32
     d1c:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		LCD_function->upperLineEnd();
     d20:	88 81       	ld	r24, Y
     d22:	99 81       	ldd	r25, Y+1	; 0x01
     d24:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <_ZN3LCD12upperLineEndEv>
     d28:	ec cf       	rjmp	.-40     	; 0xd02 <_ZN8keyboard13delete_a_charEv+0x3a>

00000d2a <_ZN8keyboard12print_a_charEc>:
			LCD_function->clearScreen();
			LCD_function->lcdCursorBlink();
			c1 = 0;
			r1 = 0;
}
void keyboard::print_a_char(char input) //print user input to the LCD screen
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	ec 01       	movw	r28, r24
{
	if (c1 == 16 && r1 == 1)
     d30:	9b 81       	ldd	r25, Y+3	; 0x03
     d32:	90 31       	cpi	r25, 0x10	; 16
     d34:	19 f4       	brne	.+6      	; 0xd3c <_ZN8keyboard12print_a_charEc+0x12>
     d36:	8a 81       	ldd	r24, Y+2	; 0x02
     d38:	81 30       	cpi	r24, 0x01	; 1
     d3a:	49 f0       	breq	.+18     	; 0xd4e <_ZN8keyboard12print_a_charEc+0x24>
	{
		return;
	}
	else
	{
		c1++; //increment collumn counter
     d3c:	9f 5f       	subi	r25, 0xFF	; 255
     d3e:	9b 83       	std	Y+3, r25	; 0x03
		LCD_function->printChar(input);
     d40:	88 81       	ld	r24, Y
     d42:	99 81       	ldd	r25, Y+1	; 0x01
     d44:	0e 94 aa 03 	call	0x754	; 0x754 <_ZN3LCD9printCharEh>
		if (c1 == 16 && r1 == 0)
     d48:	8b 81       	ldd	r24, Y+3	; 0x03
     d4a:	80 31       	cpi	r24, 0x10	; 16
     d4c:	19 f0       	breq	.+6      	; 0xd54 <_ZN8keyboard12print_a_charEc+0x2a>
			r1 = 1;
			LCD_function->lowerLine();
			return;
		}
	}
}
     d4e:	df 91       	pop	r29
     d50:	cf 91       	pop	r28
     d52:	08 95       	ret
	}
	else
	{
		c1++; //increment collumn counter
		LCD_function->printChar(input);
		if (c1 == 16 && r1 == 0)
     d54:	8a 81       	ldd	r24, Y+2	; 0x02
     d56:	88 23       	and	r24, r24
     d58:	d1 f7       	brne	.-12     	; 0xd4e <_ZN8keyboard12print_a_charEc+0x24>
		{
			c1 = 0;
     d5a:	1b 82       	std	Y+3, r1	; 0x03
			r1 = 1;
     d5c:	81 e0       	ldi	r24, 0x01	; 1
     d5e:	8a 83       	std	Y+2, r24	; 0x02
			LCD_function->lowerLine();
     d60:	88 81       	ld	r24, Y
     d62:	99 81       	ldd	r25, Y+1	; 0x01
     d64:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <_ZN3LCD9lowerLineEv>
			return;
		}
	}
}
     d68:	df 91       	pop	r29
     d6a:	cf 91       	pop	r28
     d6c:	08 95       	ret

00000d6e <_ZN8keyboard10initializeEv>:
	LCD_function->clearScreen();
	LCD_function->lcdCursorBlink();
	uint8_t r1 = 0;					// initialize cursor row counter
	uint8_t c1 = 0;				// initialize cursor collumn counter
}
void keyboard::initialize()	//initializes the LCD screen for character input
     d6e:	0f 93       	push	r16
     d70:	1f 93       	push	r17
     d72:	8c 01       	movw	r16, r24
{
	LCD_function->upperLine();
     d74:	fc 01       	movw	r30, r24
     d76:	80 81       	ld	r24, Z
     d78:	91 81       	ldd	r25, Z+1	; 0x01
     d7a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <_ZN3LCD9upperLineEv>
			LCD_function->clearScreen();
     d7e:	f8 01       	movw	r30, r16
     d80:	80 81       	ld	r24, Z
     d82:	91 81       	ldd	r25, Z+1	; 0x01
     d84:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3LCD11clearScreenEv>
			LCD_function->lcdCursorBlink();
     d88:	f8 01       	movw	r30, r16
     d8a:	80 81       	ld	r24, Z
     d8c:	91 81       	ldd	r25, Z+1	; 0x01
     d8e:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <_ZN3LCD14lcdCursorBlinkEv>
			c1 = 0;
     d92:	f8 01       	movw	r30, r16
     d94:	13 82       	std	Z+3, r1	; 0x03
			r1 = 0;
     d96:	12 82       	std	Z+2, r1	; 0x02
}
     d98:	1f 91       	pop	r17
     d9a:	0f 91       	pop	r16
     d9c:	08 95       	ret

00000d9e <_ZN8keyboardC1EP3LCD>:
#include "utility.h"
#include "LCD.h"
#include "keyboard.h"

// Constructor for the keyboard class
keyboard::keyboard(LCD* LCD_object)
     d9e:	0f 93       	push	r16
     da0:	1f 93       	push	r17
     da2:	8c 01       	movw	r16, r24
     da4:	cb 01       	movw	r24, r22
{
	LCD_function = LCD_object;				// Pointer to the LCD object
     da6:	f8 01       	movw	r30, r16
     da8:	71 83       	std	Z+1, r23	; 0x01
     daa:	60 83       	st	Z, r22
	
	LCD_function->clearScreen();
     dac:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3LCD11clearScreenEv>
	LCD_function->lcdCursorBlink();
     db0:	f8 01       	movw	r30, r16
     db2:	80 81       	ld	r24, Z
     db4:	91 81       	ldd	r25, Z+1	; 0x01
     db6:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <_ZN3LCD14lcdCursorBlinkEv>
	uint8_t r1 = 0;					// initialize cursor row counter
	uint8_t c1 = 0;				// initialize cursor collumn counter
}
     dba:	1f 91       	pop	r17
     dbc:	0f 91       	pop	r16
     dbe:	08 95       	ret

00000dc0 <_ZN8keyboardC2EP3LCD>:
#include "utility.h"
#include "LCD.h"
#include "keyboard.h"

// Constructor for the keyboard class
keyboard::keyboard(LCD* LCD_object)
     dc0:	0f 93       	push	r16
     dc2:	1f 93       	push	r17
     dc4:	8c 01       	movw	r16, r24
     dc6:	cb 01       	movw	r24, r22
{
	LCD_function = LCD_object;				// Pointer to the LCD object
     dc8:	f8 01       	movw	r30, r16
     dca:	71 83       	std	Z+1, r23	; 0x01
     dcc:	60 83       	st	Z, r22
	
	LCD_function->clearScreen();
     dce:	0e 94 04 06 	call	0xc08	; 0xc08 <_ZN3LCD11clearScreenEv>
	LCD_function->lcdCursorBlink();
     dd2:	f8 01       	movw	r30, r16
     dd4:	80 81       	ld	r24, Z
     dd6:	91 81       	ldd	r25, Z+1	; 0x01
     dd8:	0e 94 f0 05 	call	0xbe0	; 0xbe0 <_ZN3LCD14lcdCursorBlinkEv>
	uint8_t r1 = 0;					// initialize cursor row counter
	uint8_t c1 = 0;				// initialize cursor collumn counter
}
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	08 95       	ret

00000de2 <_ZN5rs2327putcharEc>:
 *  Note 2:  Fixed!  The count is now an integer and it works at lower baud rates.
 *  @param chout The character to be sent out
 *  @return True if everything was OK and false if there was a timeout
 */

bool rs232::putchar (char chout)
     de2:	dc 01       	movw	r26, r24
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (unsigned int count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     de4:	18 96       	adiw	r26, 0x08	; 8
     de6:	ed 91       	ld	r30, X+
     de8:	fc 91       	ld	r31, X
     dea:	19 97       	sbiw	r26, 0x09	; 9
     dec:	80 81       	ld	r24, Z
     dee:	1c 96       	adiw	r26, 0x0c	; 12
     df0:	2c 91       	ld	r18, X
     df2:	1c 97       	sbiw	r26, 0x0c	; 12
     df4:	30 e0       	ldi	r19, 0x00	; 0
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	82 23       	and	r24, r18
     dfa:	93 23       	and	r25, r19
     dfc:	89 2b       	or	r24, r25
     dfe:	79 f4       	brne	.+30     	; 0xe1e <_ZN5rs2327putcharEc+0x3c>
     e00:	40 e0       	ldi	r20, 0x00	; 0
     e02:	50 e0       	ldi	r21, 0x00	; 0
     e04:	06 c0       	rjmp	.+12     	; 0xe12 <_ZN5rs2327putcharEc+0x30>
     e06:	4f 5f       	subi	r20, 0xFF	; 255
     e08:	5f 4f       	sbci	r21, 0xFF	; 255
	{
		if (count > UART_TX_TOUT)
     e0a:	8e e4       	ldi	r24, 0x4E	; 78
     e0c:	41 32       	cpi	r20, 0x21	; 33
     e0e:	58 07       	cpc	r21, r24
     e10:	99 f0       	breq	.+38     	; 0xe38 <_ZN5rs2327putcharEc+0x56>
 */

bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (unsigned int count = 0; ((*p_USR & mask_UDRE) == 0); count++)
     e12:	80 81       	ld	r24, Z
     e14:	90 e0       	ldi	r25, 0x00	; 0
     e16:	82 23       	and	r24, r18
     e18:	93 23       	and	r25, r19
     e1a:	89 2b       	or	r24, r25
     e1c:	a1 f3       	breq	.-24     	; 0xe06 <_ZN5rs2327putcharEc+0x24>
	}

	// Clear the TXCn bit so it can be used to check if the serial port is busy.  This
	// check needs to be done prior to putting the processor into sleep mode.  Oddly,
	// the TXCn bit is cleared by writing a one to its bit location
	*p_USR |= mask_TXC;
     e1e:	80 81       	ld	r24, Z
     e20:	1e 96       	adiw	r26, 0x0e	; 14
     e22:	9c 91       	ld	r25, X
     e24:	1e 97       	sbiw	r26, 0x0e	; 14
     e26:	89 2b       	or	r24, r25
     e28:	80 83       	st	Z, r24

	// The CTS line is 0 and the transmitter buffer is empty, so send the character
	*p_UDR = chout;
     e2a:	16 96       	adiw	r26, 0x06	; 6
     e2c:	ed 91       	ld	r30, X+
     e2e:	fc 91       	ld	r31, X
     e30:	17 97       	sbiw	r26, 0x07	; 7
     e32:	60 83       	st	Z, r22
     e34:	81 e0       	ldi	r24, 0x01	; 1
	return (true);
}
     e36:	08 95       	ret
bool rs232::putchar (char chout)
{
	// Now wait for the serial port transmitter buffer to be empty	 
	for (unsigned int count = 0; ((*p_USR & mask_UDRE) == 0); count++)
	{
		if (count > UART_TX_TOUT)
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	08 95       	ret

00000e3c <_ZN5rs2324putsEPKc>:
/** This method writes all the characters in a string until it gets to the '\\0' at 
 *  the end. Warning: This function blocks until it's finished. 
 *  @param str The string to be written 
 */

void rs232::puts (char const* str)
     e3c:	0f 93       	push	r16
     e3e:	1f 93       	push	r17
     e40:	cf 93       	push	r28
     e42:	df 93       	push	r29
     e44:	8c 01       	movw	r16, r24
     e46:	eb 01       	movw	r28, r22
{
	while (*str) putchar (*str++);
     e48:	68 81       	ld	r22, Y
     e4a:	66 23       	and	r22, r22
     e4c:	61 f0       	breq	.+24     	; 0xe66 <_ZN5rs2324putsEPKc+0x2a>
     e4e:	21 96       	adiw	r28, 0x01	; 1
     e50:	d8 01       	movw	r26, r16
     e52:	ed 91       	ld	r30, X+
     e54:	fc 91       	ld	r31, X
     e56:	02 80       	ldd	r0, Z+2	; 0x02
     e58:	f3 81       	ldd	r31, Z+3	; 0x03
     e5a:	e0 2d       	mov	r30, r0
     e5c:	c8 01       	movw	r24, r16
     e5e:	09 95       	icall
     e60:	68 81       	ld	r22, Y
     e62:	66 23       	and	r22, r22
     e64:	a1 f7       	brne	.-24     	; 0xe4e <_ZN5rs2324putsEPKc+0x12>
}
     e66:	df 91       	pop	r29
     e68:	cf 91       	pop	r28
     e6a:	1f 91       	pop	r17
     e6c:	0f 91       	pop	r16
     e6e:	08 95       	ret

00000e70 <_ZN5rs2327getcharEv>:
{
	uint8_t recv_char;						// Character read from the queue

	// Wait until there's a character in the receiver queue
	#ifdef UCSR0A  // If this is a dual-port chip
		if (port_num == 0)
     e70:	fc 01       	movw	r30, r24
     e72:	87 85       	ldd	r24, Z+15	; 0x0f
     e74:	88 23       	and	r24, r24
     e76:	09 f5       	brne	.+66     	; 0xeba <_ZN5rs2327getcharEv+0x4a>
		{
			while (rcv0_read_index == rcv0_write_index);
     e78:	20 91 46 02 	lds	r18, 0x0246
     e7c:	30 91 47 02 	lds	r19, 0x0247
     e80:	80 91 48 02 	lds	r24, 0x0248
     e84:	90 91 49 02 	lds	r25, 0x0249
     e88:	28 17       	cp	r18, r24
     e8a:	39 07       	cpc	r19, r25
     e8c:	c1 f1       	breq	.+112    	; 0xefe <_ZN5rs2327getcharEv+0x8e>
			recv_char = rcv0_buffer[rcv0_read_index];
     e8e:	e0 91 44 02 	lds	r30, 0x0244
     e92:	f0 91 45 02 	lds	r31, 0x0245
     e96:	e2 0f       	add	r30, r18
     e98:	f3 1f       	adc	r31, r19
     e9a:	e0 81       	ld	r30, Z
			if (++rcv0_read_index >= RSINT_BUF_SIZE)
     e9c:	c9 01       	movw	r24, r18
     e9e:	01 96       	adiw	r24, 0x01	; 1
     ea0:	90 93 47 02 	sts	0x0247, r25
     ea4:	80 93 46 02 	sts	0x0246, r24
     ea8:	80 38       	cpi	r24, 0x80	; 128
     eaa:	91 05       	cpc	r25, r1
     eac:	20 f0       	brcs	.+8      	; 0xeb6 <_ZN5rs2327getcharEv+0x46>
				rcv0_read_index = 0;
     eae:	10 92 47 02 	sts	0x0247, r1
     eb2:	10 92 46 02 	sts	0x0246, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     eb6:	8e 2f       	mov	r24, r30
     eb8:	08 95       	ret
				rcv0_read_index = 0;
		}
		else  // This is port 1 of a dual-port chip
		{
		#if defined UCSR1A
			while (rcv1_read_index == rcv1_write_index);
     eba:	20 91 4c 02 	lds	r18, 0x024C
     ebe:	30 91 4d 02 	lds	r19, 0x024D
     ec2:	80 91 4e 02 	lds	r24, 0x024E
     ec6:	90 91 4f 02 	lds	r25, 0x024F
     eca:	28 17       	cp	r18, r24
     ecc:	39 07       	cpc	r19, r25
     ece:	b1 f0       	breq	.+44     	; 0xefc <_ZN5rs2327getcharEv+0x8c>
			recv_char = rcv1_buffer[rcv1_read_index];
     ed0:	e0 91 4a 02 	lds	r30, 0x024A
     ed4:	f0 91 4b 02 	lds	r31, 0x024B
     ed8:	e2 0f       	add	r30, r18
     eda:	f3 1f       	adc	r31, r19
     edc:	e0 81       	ld	r30, Z
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
     ede:	c9 01       	movw	r24, r18
     ee0:	01 96       	adiw	r24, 0x01	; 1
     ee2:	90 93 4d 02 	sts	0x024D, r25
     ee6:	80 93 4c 02 	sts	0x024C, r24
     eea:	80 38       	cpi	r24, 0x80	; 128
     eec:	91 05       	cpc	r25, r1
     eee:	18 f3       	brcs	.-58     	; 0xeb6 <_ZN5rs2327getcharEv+0x46>
				rcv1_read_index = 0;
     ef0:	10 92 4d 02 	sts	0x024D, r1
     ef4:	10 92 4c 02 	sts	0x024C, r1
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
	#endif

	return (recv_char);
}
     ef8:	8e 2f       	mov	r24, r30
     efa:	08 95       	ret
     efc:	ff cf       	rjmp	.-2      	; 0xefc <_ZN5rs2327getcharEv+0x8c>
     efe:	ff cf       	rjmp	.-2      	; 0xefe <_ZN5rs2327getcharEv+0x8e>

00000f00 <_ZN5rs23214check_for_charEv>:
 */

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
     f00:	fc 01       	movw	r30, r24
     f02:	87 85       	ldd	r24, Z+15	; 0x0f
     f04:	88 23       	and	r24, r24
     f06:	79 f0       	breq	.+30     	; 0xf26 <_ZN5rs23214check_for_charEv+0x26>
			return (rcv0_read_index != rcv0_write_index);
		else
			return (rcv1_read_index != rcv1_write_index);
     f08:	40 e0       	ldi	r20, 0x00	; 0
     f0a:	20 91 4c 02 	lds	r18, 0x024C
     f0e:	30 91 4d 02 	lds	r19, 0x024D
     f12:	80 91 4e 02 	lds	r24, 0x024E
     f16:	90 91 4f 02 	lds	r25, 0x024F
     f1a:	28 17       	cp	r18, r24
     f1c:	39 07       	cpc	r19, r25
     f1e:	09 f0       	breq	.+2      	; 0xf22 <_ZN5rs23214check_for_charEv+0x22>
     f20:	41 e0       	ldi	r20, 0x01	; 1
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f22:	84 2f       	mov	r24, r20
     f24:	08 95       	ret

bool rs232::check_for_char (void)
{
	#ifdef UCSR1A							// If this is a dual-port chip
		if (port_num == 0)
			return (rcv0_read_index != rcv0_write_index);
     f26:	40 e0       	ldi	r20, 0x00	; 0
     f28:	20 91 46 02 	lds	r18, 0x0246
     f2c:	30 91 47 02 	lds	r19, 0x0247
     f30:	80 91 48 02 	lds	r24, 0x0248
     f34:	90 91 49 02 	lds	r25, 0x0249
     f38:	28 17       	cp	r18, r24
     f3a:	39 07       	cpc	r19, r25
     f3c:	89 f7       	brne	.-30     	; 0xf20 <_ZN5rs23214check_for_charEv+0x20>
		else
			return (rcv1_read_index != rcv1_write_index);
	#else									// This chip has only one serial port
		return (rcv0_read_index != rcv0_write_index);
	#endif
}
     f3e:	84 2f       	mov	r24, r20
     f40:	08 95       	ret

00000f42 <_ZN5rs23212clear_screenEv>:
//-------------------------------------------------------------------------------------
/** This method sends the ASCII code to clear a display screen. It is called when the
 *  format modifier 'clrscr' is inserted in a line of "<<" stuff.
 */

void rs232::clear_screen (void)
     f42:	fc 01       	movw	r30, r24
{
	putchar (CLRSCR_STYLE);
     f44:	a0 81       	ld	r26, Z
     f46:	b1 81       	ldd	r27, Z+1	; 0x01
     f48:	12 96       	adiw	r26, 0x02	; 2
     f4a:	2d 91       	ld	r18, X+
     f4c:	3c 91       	ld	r19, X
     f4e:	13 97       	sbiw	r26, 0x03	; 3
     f50:	6c e0       	ldi	r22, 0x0C	; 12
     f52:	f9 01       	movw	r30, r18
     f54:	09 95       	icall
}
     f56:	08 95       	ret

00000f58 <__vector_25>:
/** \cond NOT_ENABLED  (This ISR is not to be documented by Doxygen)
 *  This interrupt service routine runs whenever a character has been received by the
 *  first serial port (number 0).  It saves that character into the receiver buffer.
 */

ISR (RSI_CHAR_RECV_INT_0)
     f58:	1f 92       	push	r1
     f5a:	0f 92       	push	r0
     f5c:	0f b6       	in	r0, 0x3f	; 63
     f5e:	0f 92       	push	r0
     f60:	0b b6       	in	r0, 0x3b	; 59
     f62:	0f 92       	push	r0
     f64:	11 24       	eor	r1, r1
     f66:	2f 93       	push	r18
     f68:	3f 93       	push	r19
     f6a:	8f 93       	push	r24
     f6c:	9f 93       	push	r25
     f6e:	ef 93       	push	r30
     f70:	ff 93       	push	r31
{
	// When this ISR is triggered, there's a character waiting in the USART data reg-
	// ister, and the write index indexes the place where that character should go

	#if defined UCSR0A  // If this is a dual-serial-port chip (ATmega324P, 128, etc.)
		rcv0_buffer[rcv0_write_index] = UDR0;
     f72:	80 91 c6 00 	lds	r24, 0x00C6
     f76:	e0 91 44 02 	lds	r30, 0x0244
     f7a:	f0 91 45 02 	lds	r31, 0x0245
     f7e:	20 91 48 02 	lds	r18, 0x0248
     f82:	30 91 49 02 	lds	r19, 0x0249
     f86:	e2 0f       	add	r30, r18
     f88:	f3 1f       	adc	r31, r19
     f8a:	80 83       	st	Z, r24
	#else  // If this chip has only a single serial port (ATmega8, 32, etc.)
		rcv0_buffer[rcv0_write_index] = UDR;
	#endif

	// Increment the write pointer
	if (++rcv0_write_index >= RSINT_BUF_SIZE)
     f8c:	20 91 48 02 	lds	r18, 0x0248
     f90:	30 91 49 02 	lds	r19, 0x0249
     f94:	2f 5f       	subi	r18, 0xFF	; 255
     f96:	3f 4f       	sbci	r19, 0xFF	; 255
     f98:	30 93 49 02 	sts	0x0249, r19
     f9c:	20 93 48 02 	sts	0x0248, r18
     fa0:	20 38       	cpi	r18, 0x80	; 128
     fa2:	31 05       	cpc	r19, r1
     fa4:	30 f0       	brcs	.+12     	; 0xfb2 <__vector_25+0x5a>
		rcv0_write_index = 0;
     fa6:	10 92 49 02 	sts	0x0249, r1
     faa:	10 92 48 02 	sts	0x0248, r1
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e0       	ldi	r19, 0x00	; 0

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
     fb2:	80 91 46 02 	lds	r24, 0x0246
     fb6:	90 91 47 02 	lds	r25, 0x0247
     fba:	28 17       	cp	r18, r24
     fbc:	39 07       	cpc	r19, r25
     fbe:	69 f0       	breq	.+26     	; 0xfda <__vector_25+0x82>
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
			rcv0_read_index = 0;
}
     fc0:	ff 91       	pop	r31
     fc2:	ef 91       	pop	r30
     fc4:	9f 91       	pop	r25
     fc6:	8f 91       	pop	r24
     fc8:	3f 91       	pop	r19
     fca:	2f 91       	pop	r18
     fcc:	0f 90       	pop	r0
     fce:	0b be       	out	0x3b, r0	; 59
     fd0:	0f 90       	pop	r0
     fd2:	0f be       	out	0x3f, r0	; 63
     fd4:	0f 90       	pop	r0
     fd6:	1f 90       	pop	r1
     fd8:	18 95       	reti

	// If the write pointer is now equal to the read pointer, that means we've just
	// overwritten the oldest data. Increment the read pointer so that it doesn't seem
	// as if the buffer is empty
	if (rcv0_write_index == rcv0_read_index)
		if (++rcv0_read_index >= RSINT_BUF_SIZE)
     fda:	c9 01       	movw	r24, r18
     fdc:	01 96       	adiw	r24, 0x01	; 1
     fde:	90 93 47 02 	sts	0x0247, r25
     fe2:	80 93 46 02 	sts	0x0246, r24
     fe6:	80 38       	cpi	r24, 0x80	; 128
     fe8:	91 05       	cpc	r25, r1
     fea:	50 f3       	brcs	.-44     	; 0xfc0 <__vector_25+0x68>
			rcv0_read_index = 0;
     fec:	10 92 47 02 	sts	0x0247, r1
     ff0:	10 92 46 02 	sts	0x0246, r1
     ff4:	e5 cf       	rjmp	.-54     	; 0xfc0 <__vector_25+0x68>

00000ff6 <__vector_36>:
	//-------------------------------------------------------------------------------------
	/** This interrupt service routine runs whenever a character has been received by the
	*  first serial port (number 0).  It saves that character into the receiver buffer.
	*/

	ISR (RSI_CHAR_RECV_INT_1)
     ff6:	1f 92       	push	r1
     ff8:	0f 92       	push	r0
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	0f 92       	push	r0
     ffe:	0b b6       	in	r0, 0x3b	; 59
    1000:	0f 92       	push	r0
    1002:	11 24       	eor	r1, r1
    1004:	2f 93       	push	r18
    1006:	3f 93       	push	r19
    1008:	8f 93       	push	r24
    100a:	9f 93       	push	r25
    100c:	ef 93       	push	r30
    100e:	ff 93       	push	r31
	{
		// Read the character from the serial port receiver buffer
		rcv1_buffer[rcv1_write_index] = UDR1;
    1010:	80 91 ce 00 	lds	r24, 0x00CE
    1014:	e0 91 4a 02 	lds	r30, 0x024A
    1018:	f0 91 4b 02 	lds	r31, 0x024B
    101c:	20 91 4e 02 	lds	r18, 0x024E
    1020:	30 91 4f 02 	lds	r19, 0x024F
    1024:	e2 0f       	add	r30, r18
    1026:	f3 1f       	adc	r31, r19
    1028:	80 83       	st	Z, r24

		// Increment the write pointer
		if (++rcv1_write_index >= RSINT_BUF_SIZE)
    102a:	20 91 4e 02 	lds	r18, 0x024E
    102e:	30 91 4f 02 	lds	r19, 0x024F
    1032:	2f 5f       	subi	r18, 0xFF	; 255
    1034:	3f 4f       	sbci	r19, 0xFF	; 255
    1036:	30 93 4f 02 	sts	0x024F, r19
    103a:	20 93 4e 02 	sts	0x024E, r18
    103e:	20 38       	cpi	r18, 0x80	; 128
    1040:	31 05       	cpc	r19, r1
    1042:	30 f0       	brcs	.+12     	; 0x1050 <__vector_36+0x5a>
			rcv1_write_index = 0;
    1044:	10 92 4f 02 	sts	0x024F, r1
    1048:	10 92 4e 02 	sts	0x024E, r1
    104c:	20 e0       	ldi	r18, 0x00	; 0
    104e:	30 e0       	ldi	r19, 0x00	; 0

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
    1050:	80 91 4c 02 	lds	r24, 0x024C
    1054:	90 91 4d 02 	lds	r25, 0x024D
    1058:	28 17       	cp	r18, r24
    105a:	39 07       	cpc	r19, r25
    105c:	69 f0       	breq	.+26     	; 0x1078 <__vector_36+0x82>
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
				rcv1_read_index = 0;
	}
    105e:	ff 91       	pop	r31
    1060:	ef 91       	pop	r30
    1062:	9f 91       	pop	r25
    1064:	8f 91       	pop	r24
    1066:	3f 91       	pop	r19
    1068:	2f 91       	pop	r18
    106a:	0f 90       	pop	r0
    106c:	0b be       	out	0x3b, r0	; 59
    106e:	0f 90       	pop	r0
    1070:	0f be       	out	0x3f, r0	; 63
    1072:	0f 90       	pop	r0
    1074:	1f 90       	pop	r1
    1076:	18 95       	reti

		// If the write pointer is now equal to the read pointer, that means we've just
		// overwritten the oldest data. Increment the read pointer so that it doesn't seem
		// as if the buffer is empty
		if (rcv1_write_index == rcv1_read_index)
			if (++rcv1_read_index >= RSINT_BUF_SIZE)
    1078:	c9 01       	movw	r24, r18
    107a:	01 96       	adiw	r24, 0x01	; 1
    107c:	90 93 4d 02 	sts	0x024D, r25
    1080:	80 93 4c 02 	sts	0x024C, r24
    1084:	80 38       	cpi	r24, 0x80	; 128
    1086:	91 05       	cpc	r25, r1
    1088:	50 f3       	brcs	.-44     	; 0x105e <__vector_36+0x68>
				rcv1_read_index = 0;
    108a:	10 92 4d 02 	sts	0x024D, r1
    108e:	10 92 4c 02 	sts	0x024C, r1
    1092:	e5 cf       	rjmp	.-54     	; 0x105e <__vector_36+0x68>

00001094 <_ZN5rs232C1Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (unsigned int baud_rate, unsigned char port_number)
    1094:	df 92       	push	r13
    1096:	ef 92       	push	r14
    1098:	ff 92       	push	r15
    109a:	0f 93       	push	r16
    109c:	1f 93       	push	r17
    109e:	8c 01       	movw	r16, r24
    10a0:	7b 01       	movw	r14, r22
    10a2:	d4 2e       	mov	r13, r20
	: base_text_serial (), base232 (baud_rate, port_number)
    10a4:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <_ZN16base_text_serialC2Ev>
    10a8:	c8 01       	movw	r24, r16
    10aa:	06 96       	adiw	r24, 0x06	; 6
    10ac:	b7 01       	movw	r22, r14
    10ae:	4d 2d       	mov	r20, r13
    10b0:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_ZN7base232C2Ejh>
    10b4:	83 e1       	ldi	r24, 0x13	; 19
    10b6:	92 e0       	ldi	r25, 0x02	; 2
    10b8:	f8 01       	movw	r30, r16
    10ba:	91 83       	std	Z+1, r25	; 0x01
    10bc:	80 83       	st	Z, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
    10be:	d7 86       	std	Z+15, r13	; 0x0f

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
    10c0:	dd 20       	and	r13, r13
    10c2:	d9 f0       	breq	.+54     	; 0x10fa <_ZN5rs232C1Ejh+0x66>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
    10c4:	80 91 c9 00 	lds	r24, 0x00C9
    10c8:	80 68       	ori	r24, 0x80	; 128
    10ca:	80 93 c9 00 	sts	0x00C9, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
    10ce:	80 e8       	ldi	r24, 0x80	; 128
    10d0:	90 e0       	ldi	r25, 0x00	; 0
    10d2:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <_Znaj>
    10d6:	90 93 4b 02 	sts	0x024B, r25
    10da:	80 93 4a 02 	sts	0x024A, r24
			rcv1_read_index = 0;
    10de:	10 92 4d 02 	sts	0x024D, r1
    10e2:	10 92 4c 02 	sts	0x024C, r1
			rcv1_write_index = 0;
    10e6:	10 92 4f 02 	sts	0x024F, r1
    10ea:	10 92 4e 02 	sts	0x024E, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    10ee:	1f 91       	pop	r17
    10f0:	0f 91       	pop	r16
    10f2:	ff 90       	pop	r15
    10f4:	ef 90       	pop	r14
    10f6:	df 90       	pop	r13
    10f8:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
    10fa:	80 91 c1 00 	lds	r24, 0x00C1
    10fe:	80 68       	ori	r24, 0x80	; 128
    1100:	80 93 c1 00 	sts	0x00C1, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
    1104:	80 e8       	ldi	r24, 0x80	; 128
    1106:	90 e0       	ldi	r25, 0x00	; 0
    1108:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <_Znaj>
    110c:	90 93 45 02 	sts	0x0245, r25
    1110:	80 93 44 02 	sts	0x0244, r24
			rcv0_read_index = 0;
    1114:	10 92 47 02 	sts	0x0247, r1
    1118:	10 92 46 02 	sts	0x0246, r1
			rcv0_write_index = 0;
    111c:	10 92 49 02 	sts	0x0249, r1
    1120:	10 92 48 02 	sts	0x0248, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    1124:	1f 91       	pop	r17
    1126:	0f 91       	pop	r16
    1128:	ff 90       	pop	r15
    112a:	ef 90       	pop	r14
    112c:	df 90       	pop	r13
    112e:	08 95       	ret

00001130 <_ZN5rs232C2Ejh>:
 *  @param baud_rate The desired baud rate for serial communications. Default is 9600
 *  @param port_number The number of the serial port, 0 or 1 (the second port numbered
 *                     1 only exists on some processors). The default is port 0 
 */

rs232::rs232 (unsigned int baud_rate, unsigned char port_number)
    1130:	df 92       	push	r13
    1132:	ef 92       	push	r14
    1134:	ff 92       	push	r15
    1136:	0f 93       	push	r16
    1138:	1f 93       	push	r17
    113a:	8c 01       	movw	r16, r24
    113c:	7b 01       	movw	r14, r22
    113e:	d4 2e       	mov	r13, r20
	: base_text_serial (), base232 (baud_rate, port_number)
    1140:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <_ZN16base_text_serialC2Ev>
    1144:	c8 01       	movw	r24, r16
    1146:	06 96       	adiw	r24, 0x06	; 6
    1148:	b7 01       	movw	r22, r14
    114a:	4d 2d       	mov	r20, r13
    114c:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <_ZN7base232C2Ejh>
    1150:	83 e1       	ldi	r24, 0x13	; 19
    1152:	92 e0       	ldi	r25, 0x02	; 2
    1154:	f8 01       	movw	r30, r16
    1156:	91 83       	std	Z+1, r25	; 0x01
    1158:	80 83       	st	Z, r24
{
	// Save the number of the serial port, 0 or 1
	port_num = port_number;
    115a:	d7 86       	std	Z+15, r13	; 0x0f

	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
    115c:	dd 20       	and	r13, r13
    115e:	d9 f0       	breq	.+54     	; 0x1196 <_ZN5rs232C2Ejh+0x66>
			rcv0_write_index = 0;
		}
		else  // Serial port number 1
		{
		#if defined UCSR1A
			UCSR1B |= (1 << RXCIE1);		// Receive complete interrupt enable
    1160:	80 91 c9 00 	lds	r24, 0x00C9
    1164:	80 68       	ori	r24, 0x80	; 128
    1166:	80 93 c9 00 	sts	0x00C9, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv1_buffer = new uint8_t[RSINT_BUF_SIZE];
    116a:	80 e8       	ldi	r24, 0x80	; 128
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <_Znaj>
    1172:	90 93 4b 02 	sts	0x024B, r25
    1176:	80 93 4a 02 	sts	0x024A, r24
			rcv1_read_index = 0;
    117a:	10 92 4d 02 	sts	0x024D, r1
    117e:	10 92 4c 02 	sts	0x024C, r1
			rcv1_write_index = 0;
    1182:	10 92 4f 02 	sts	0x024F, r1
    1186:	10 92 4e 02 	sts	0x024E, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    118a:	1f 91       	pop	r17
    118c:	0f 91       	pop	r16
    118e:	ff 90       	pop	r15
    1190:	ef 90       	pop	r14
    1192:	df 90       	pop	r13
    1194:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A // Serial port number 0
		if (port_number == 0)
		{
			UCSR0B |= (1 << RXCIE0);		// Receive complete interrupt enable
    1196:	80 91 c1 00 	lds	r24, 0x00C1
    119a:	80 68       	ori	r24, 0x80	; 128
    119c:	80 93 c1 00 	sts	0x00C1, r24

			// Allocate some memory for the receiver buffer and reset the indices
			rcv0_buffer = new uint8_t[RSINT_BUF_SIZE];
    11a0:	80 e8       	ldi	r24, 0x80	; 128
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <_Znaj>
    11a8:	90 93 45 02 	sts	0x0245, r25
    11ac:	80 93 44 02 	sts	0x0244, r24
			rcv0_read_index = 0;
    11b0:	10 92 47 02 	sts	0x0247, r1
    11b4:	10 92 46 02 	sts	0x0246, r1
			rcv0_write_index = 0;
    11b8:	10 92 49 02 	sts	0x0249, r1
    11bc:	10 92 48 02 	sts	0x0248, r1
	// use the XBee radio module
	#ifdef XIPHOS_HACKS
		if (port_number == 1)
			PORTD |= 0x04;
	#endif
}
    11c0:	1f 91       	pop	r17
    11c2:	0f 91       	pop	r16
    11c4:	ff 90       	pop	r15
    11c6:	ef 90       	pop	r14
    11c8:	df 90       	pop	r13
    11ca:	08 95       	ret

000011cc <_ZN10time_stampC2Ev>:

//--------------------------------------------------------------------------------------
/** This constructor creates a time stamp object, with the time set to zero. 
 */

time_stamp::time_stamp (void)
    11cc:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    11ce:	10 82       	st	Z, r1
    11d0:	11 82       	std	Z+1, r1	; 0x01
    11d2:	12 82       	std	Z+2, r1	; 0x02
    11d4:	13 82       	std	Z+3, r1	; 0x03
 */

time_stamp::time_stamp (void)
{
	set_time (0L);
}
    11d6:	08 95       	ret

000011d8 <_ZN10time_stampC1Ev>:

//--------------------------------------------------------------------------------------
/** This constructor creates a time stamp object, with the time set to zero. 
 */

time_stamp::time_stamp (void)
    11d8:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    11da:	10 82       	st	Z, r1
    11dc:	11 82       	std	Z+1, r1	; 0x01
    11de:	12 82       	std	Z+2, r1	; 0x02
    11e0:	13 82       	std	Z+3, r1	; 0x03
 */

time_stamp::time_stamp (void)
{
	set_time (0L);
}
    11e2:	08 95       	ret

000011e4 <_ZN10time_stampC2Em>:
/** This constructor creates a time stamp object and fills the time stamp's variables
 *  with the given values.
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

time_stamp::time_stamp (uint32_t a_time)
    11e4:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    11e6:	40 83       	st	Z, r20
    11e8:	51 83       	std	Z+1, r21	; 0x01
    11ea:	62 83       	std	Z+2, r22	; 0x02
    11ec:	73 83       	std	Z+3, r23	; 0x03
 */

time_stamp::time_stamp (uint32_t a_time)
{
	set_time (a_time);
}
    11ee:	08 95       	ret

000011f0 <_ZN10time_stampC1Em>:
/** This constructor creates a time stamp object and fills the time stamp's variables
 *  with the given values.
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

time_stamp::time_stamp (uint32_t a_time)
    11f0:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    11f2:	40 83       	st	Z, r20
    11f4:	51 83       	std	Z+1, r21	; 0x01
    11f6:	62 83       	std	Z+2, r22	; 0x02
    11f8:	73 83       	std	Z+3, r23	; 0x03
 */

time_stamp::time_stamp (uint32_t a_time)
{
	set_time (a_time);
}
    11fa:	08 95       	ret

000011fc <_ZN10time_stamp8set_timeEm>:
//--------------------------------------------------------------------------------------
/** This method fills the time stamp with the given value.
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
    11fc:	fc 01       	movw	r30, r24
{
	data.whole = a_time;
    11fe:	40 83       	st	Z, r20
    1200:	51 83       	std	Z+1, r21	; 0x01
    1202:	62 83       	std	Z+2, r22	; 0x02
    1204:	73 83       	std	Z+3, r23	; 0x03
}
    1206:	08 95       	ret

00001208 <_ZN10time_stamp8set_timeEjm>:
/** This method fills the time stamp with the given numbers of seconds and microseconds.
 *  @param sec A 16-bit number of seconds to preload into the time stamp
 *  @param microsec A 32-bit number of microseconds to preload into the time stamp
 */

void time_stamp::set_time (uint16_t sec, uint32_t microsec)
    1208:	cf 92       	push	r12
    120a:	df 92       	push	r13
    120c:	ef 92       	push	r14
    120e:	ff 92       	push	r15
    1210:	0f 93       	push	r16
    1212:	1f 93       	push	r17
    1214:	6c 01       	movw	r12, r24
    1216:	79 01       	movw	r14, r18
    1218:	8a 01       	movw	r16, r20
{
	data.whole = (microsec * (F_CPU / 1000000UL)) / 8UL;
	data.whole += (uint16_t)sec * (F_CPU / 8UL);
    121a:	ee 0c       	add	r14, r14
    121c:	ff 1c       	adc	r15, r15
    121e:	00 1f       	adc	r16, r16
    1220:	11 1f       	adc	r17, r17
    1222:	8e ef       	ldi	r24, 0xFE	; 254
    1224:	9f ef       	ldi	r25, 0xFF	; 255
    1226:	af ef       	ldi	r26, 0xFF	; 255
    1228:	bf e1       	ldi	r27, 0x1F	; 31
    122a:	e8 22       	and	r14, r24
    122c:	f9 22       	and	r15, r25
    122e:	0a 23       	and	r16, r26
    1230:	1b 23       	and	r17, r27
    1232:	80 e0       	ldi	r24, 0x00	; 0
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	20 e8       	ldi	r18, 0x80	; 128
    1238:	34 e8       	ldi	r19, 0x84	; 132
    123a:	4e e1       	ldi	r20, 0x1E	; 30
    123c:	50 e0       	ldi	r21, 0x00	; 0
    123e:	0e 94 71 10 	call	0x20e2	; 0x20e2 <__mulsi3>
    1242:	e6 0e       	add	r14, r22
    1244:	f7 1e       	adc	r15, r23
    1246:	08 1f       	adc	r16, r24
    1248:	19 1f       	adc	r17, r25
    124a:	d6 01       	movw	r26, r12
    124c:	ed 92       	st	X+, r14
    124e:	fd 92       	st	X+, r15
    1250:	0d 93       	st	X+, r16
    1252:	1c 93       	st	X, r17
    1254:	13 97       	sbiw	r26, 0x03	; 3
}
    1256:	1f 91       	pop	r17
    1258:	0f 91       	pop	r16
    125a:	ff 90       	pop	r15
    125c:	ef 90       	pop	r14
    125e:	df 90       	pop	r13
    1260:	cf 90       	pop	r12
    1262:	08 95       	ret

00001264 <_ZN10time_stampC1Ejm>:
 *  @param microsec A 32-bit number of microseconds to preload into the time stamp
 */

time_stamp::time_stamp (uint16_t sec, uint32_t microsec)
{
	set_time (sec, microsec);
    1264:	0e 94 04 09 	call	0x1208	; 0x1208 <_ZN10time_stamp8set_timeEjm>
}
    1268:	08 95       	ret

0000126a <_ZN10time_stampC2Ejm>:
 *  @param microsec A 32-bit number of microseconds to preload into the time stamp
 */

time_stamp::time_stamp (uint16_t sec, uint32_t microsec)
{
	set_time (sec, microsec);
    126a:	0e 94 04 09 	call	0x1208	; 0x1208 <_ZN10time_stamp8set_timeEjm>
}
    126e:	08 95       	ret

00001270 <_ZN10time_stamp12get_raw_timeEv>:
/** This method allows one to get the time reading from this time stamp as a long 
 *  integer containing the number of time ticks. 
 *  @return The time stamp's raw data
 */

uint32_t time_stamp::get_raw_time (void)
    1270:	fc 01       	movw	r30, r24
    1272:	60 81       	ld	r22, Z
    1274:	71 81       	ldd	r23, Z+1	; 0x01
{
	return (data.whole);
}
    1276:	82 81       	ldd	r24, Z+2	; 0x02
    1278:	93 81       	ldd	r25, Z+3	; 0x03
    127a:	08 95       	ret

0000127c <_ZN10time_stamp11get_secondsEv>:
//--------------------------------------------------------------------------------------
/** This method returns the number of seconds in the time stamp.
 *  @return The number of whole seconds in the time stamp
 */

uint16_t time_stamp::get_seconds (void)
    127c:	fc 01       	movw	r30, r24
    127e:	60 81       	ld	r22, Z
    1280:	71 81       	ldd	r23, Z+1	; 0x01
    1282:	82 81       	ldd	r24, Z+2	; 0x02
    1284:	93 81       	ldd	r25, Z+3	; 0x03
    1286:	20 e8       	ldi	r18, 0x80	; 128
    1288:	34 e8       	ldi	r19, 0x84	; 132
    128a:	4e e1       	ldi	r20, 0x1E	; 30
    128c:	50 e0       	ldi	r21, 0x00	; 0
    128e:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    1292:	c9 01       	movw	r24, r18
{
	return ((uint16_t)(data.whole / (F_CPU / 8)));
}
    1294:	08 95       	ret

00001296 <_ZN10time_stamp12get_microsecEv>:
/** This method returns the number of microseconds in the time stamp, after the seconds
 *  are subtracted out. 
 *  @return The number of microseconds, that is, the fractional part of the time stamp
 */

uint32_t time_stamp::get_microsec (void)
    1296:	fc 01       	movw	r30, r24
    1298:	60 81       	ld	r22, Z
    129a:	71 81       	ldd	r23, Z+1	; 0x01
    129c:	82 81       	ldd	r24, Z+2	; 0x02
    129e:	93 81       	ldd	r25, Z+3	; 0x03
    12a0:	20 e8       	ldi	r18, 0x80	; 128
    12a2:	34 e8       	ldi	r19, 0x84	; 132
    12a4:	4e e1       	ldi	r20, 0x1E	; 30
    12a6:	50 e0       	ldi	r21, 0x00	; 0
    12a8:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    12ac:	9b 01       	movw	r18, r22
    12ae:	ac 01       	movw	r20, r24
    12b0:	56 95       	lsr	r21
    12b2:	47 95       	ror	r20
    12b4:	37 95       	ror	r19
    12b6:	27 95       	ror	r18
    12b8:	5f 70       	andi	r21, 0x0F	; 15
{
	return ((data.whole % (F_CPU / 8UL)) * 8 / (F_CPU / 1000000UL));
}
    12ba:	b9 01       	movw	r22, r18
    12bc:	ca 01       	movw	r24, r20
    12be:	08 95       	ret

000012c0 <_ZN10time_stampplERKS_>:
 *  happen, such as the next time a task is supposed to run. 
 *  @param addend The other time stamp which is to be added to this one
 *  @return The newly created time stamp
 */

time_stamp time_stamp::operator + (const time_stamp& addend)
    12c0:	dc 01       	movw	r26, r24
    12c2:	fb 01       	movw	r30, r22
{
	time_stamp ret_stamp;
	ret_stamp.data.whole = this->data.whole + addend.data.whole;
    12c4:	20 81       	ld	r18, Z
    12c6:	31 81       	ldd	r19, Z+1	; 0x01
    12c8:	42 81       	ldd	r20, Z+2	; 0x02
    12ca:	53 81       	ldd	r21, Z+3	; 0x03
    12cc:	8d 91       	ld	r24, X+
    12ce:	9d 91       	ld	r25, X+
    12d0:	0d 90       	ld	r0, X+
    12d2:	bc 91       	ld	r27, X
    12d4:	a0 2d       	mov	r26, r0
    12d6:	28 0f       	add	r18, r24
    12d8:	39 1f       	adc	r19, r25
    12da:	4a 1f       	adc	r20, r26
    12dc:	5b 1f       	adc	r21, r27

	return ret_stamp;
}
    12de:	b9 01       	movw	r22, r18
    12e0:	ca 01       	movw	r24, r20
    12e2:	08 95       	ret

000012e4 <_ZN10time_stampmiERKS_>:
 *  recorded time and a previous one. 
 *  @param previous An earlier time stamp to be compared to the current one 
 *  @return The newly created time stamp
 */

time_stamp time_stamp::operator - (const time_stamp& previous)
    12e4:	fc 01       	movw	r30, r24
    12e6:	db 01       	movw	r26, r22
{
	time_stamp ret_stamp;
	ret_stamp.data.whole = this->data.whole - previous.data.whole;
    12e8:	20 81       	ld	r18, Z
    12ea:	31 81       	ldd	r19, Z+1	; 0x01
    12ec:	42 81       	ldd	r20, Z+2	; 0x02
    12ee:	53 81       	ldd	r21, Z+3	; 0x03
    12f0:	8d 91       	ld	r24, X+
    12f2:	9d 91       	ld	r25, X+
    12f4:	0d 90       	ld	r0, X+
    12f6:	bc 91       	ld	r27, X
    12f8:	a0 2d       	mov	r26, r0
    12fa:	28 1b       	sub	r18, r24
    12fc:	39 0b       	sbc	r19, r25
    12fe:	4a 0b       	sbc	r20, r26
    1300:	5b 0b       	sbc	r21, r27

	return ret_stamp;
}
    1302:	b9 01       	movw	r22, r18
    1304:	ca 01       	movw	r24, r20
    1306:	08 95       	ret

00001308 <_ZN10time_stamppLERKS_>:
 *  can be used to find the time in the future at which some event is to be caused to 
 *  happen, such as the next time a task is supposed to run. 
 *  @param addend The other time stamp which is to be added to this one
 */

void time_stamp::operator += (const time_stamp& addend)
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	cf 93       	push	r28
    130e:	df 93       	push	r29
    1310:	8c 01       	movw	r16, r24
    1312:	fb 01       	movw	r30, r22
{
	data.whole += addend.data.whole;
    1314:	ec 01       	movw	r28, r24
    1316:	88 81       	ld	r24, Y
    1318:	99 81       	ldd	r25, Y+1	; 0x01
    131a:	aa 81       	ldd	r26, Y+2	; 0x02
    131c:	bb 81       	ldd	r27, Y+3	; 0x03
    131e:	20 81       	ld	r18, Z
    1320:	31 81       	ldd	r19, Z+1	; 0x01
    1322:	42 81       	ldd	r20, Z+2	; 0x02
    1324:	53 81       	ldd	r21, Z+3	; 0x03
    1326:	82 0f       	add	r24, r18
    1328:	93 1f       	adc	r25, r19
    132a:	a4 1f       	adc	r26, r20
    132c:	b5 1f       	adc	r27, r21
    132e:	f8 01       	movw	r30, r16
    1330:	80 83       	st	Z, r24
    1332:	91 83       	std	Z+1, r25	; 0x01
    1334:	a2 83       	std	Z+2, r26	; 0x02
    1336:	b3 83       	std	Z+3, r27	; 0x03
}
    1338:	df 91       	pop	r29
    133a:	cf 91       	pop	r28
    133c:	1f 91       	pop	r17
    133e:	0f 91       	pop	r16
    1340:	08 95       	ret

00001342 <_ZN10time_stampmIERKS_>:
 *  recorded time and a previous one. Note that the data in this timestamp is 
 *  replaced with that duration. 
 *  @param previous An earlier time stamp to be compared to the current one 
 */

void time_stamp::operator -= (const time_stamp& previous)
    1342:	0f 93       	push	r16
    1344:	1f 93       	push	r17
    1346:	cf 93       	push	r28
    1348:	df 93       	push	r29
    134a:	8c 01       	movw	r16, r24
    134c:	fb 01       	movw	r30, r22
{
	data.whole -= previous.data.whole;
    134e:	ec 01       	movw	r28, r24
    1350:	88 81       	ld	r24, Y
    1352:	99 81       	ldd	r25, Y+1	; 0x01
    1354:	aa 81       	ldd	r26, Y+2	; 0x02
    1356:	bb 81       	ldd	r27, Y+3	; 0x03
    1358:	20 81       	ld	r18, Z
    135a:	31 81       	ldd	r19, Z+1	; 0x01
    135c:	42 81       	ldd	r20, Z+2	; 0x02
    135e:	53 81       	ldd	r21, Z+3	; 0x03
    1360:	82 1b       	sub	r24, r18
    1362:	93 0b       	sbc	r25, r19
    1364:	a4 0b       	sbc	r26, r20
    1366:	b5 0b       	sbc	r27, r21
    1368:	f8 01       	movw	r30, r16
    136a:	80 83       	st	Z, r24
    136c:	91 83       	std	Z+1, r25	; 0x01
    136e:	a2 83       	std	Z+2, r26	; 0x02
    1370:	b3 83       	std	Z+3, r27	; 0x03
}
    1372:	df 91       	pop	r29
    1374:	cf 91       	pop	r28
    1376:	1f 91       	pop	r17
    1378:	0f 91       	pop	r16
    137a:	08 95       	ret

0000137c <_ZN10time_stampdVERKm>:
/** This overloaded division operator divides a time stamp by the given integer. Note 
 *  that the data in this timestamp is replaced by the quotient. 
 *  @param divisor The number by which the time stamp is to be divided
 */

void time_stamp::operator /= (const uint32_t& divisor)
    137c:	0f 93       	push	r16
    137e:	1f 93       	push	r17
    1380:	8c 01       	movw	r16, r24
    1382:	fb 01       	movw	r30, r22
{
	data.whole /= divisor;
    1384:	dc 01       	movw	r26, r24
    1386:	6d 91       	ld	r22, X+
    1388:	7d 91       	ld	r23, X+
    138a:	8d 91       	ld	r24, X+
    138c:	9c 91       	ld	r25, X
    138e:	20 81       	ld	r18, Z
    1390:	31 81       	ldd	r19, Z+1	; 0x01
    1392:	42 81       	ldd	r20, Z+2	; 0x02
    1394:	53 81       	ldd	r21, Z+3	; 0x03
    1396:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    139a:	f8 01       	movw	r30, r16
    139c:	20 83       	st	Z, r18
    139e:	31 83       	std	Z+1, r19	; 0x01
    13a0:	42 83       	std	Z+2, r20	; 0x02
    13a2:	53 83       	std	Z+3, r21	; 0x03
}
    13a4:	1f 91       	pop	r17
    13a6:	0f 91       	pop	r16
    13a8:	08 95       	ret

000013aa <_ZN10time_stampeqERKS_>:
 *  other time stamp are equal to those in this one. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if the time stamps contain equal data, false if they don't
 */

bool time_stamp::operator == (const time_stamp& other)
    13aa:	dc 01       	movw	r26, r24
    13ac:	fb 01       	movw	r30, r22
    13ae:	60 e0       	ldi	r22, 0x00	; 0
    13b0:	20 81       	ld	r18, Z
    13b2:	31 81       	ldd	r19, Z+1	; 0x01
    13b4:	42 81       	ldd	r20, Z+2	; 0x02
    13b6:	53 81       	ldd	r21, Z+3	; 0x03
    13b8:	8d 91       	ld	r24, X+
    13ba:	9d 91       	ld	r25, X+
    13bc:	0d 90       	ld	r0, X+
    13be:	bc 91       	ld	r27, X
    13c0:	a0 2d       	mov	r26, r0
    13c2:	28 17       	cp	r18, r24
    13c4:	39 07       	cpc	r19, r25
    13c6:	4a 07       	cpc	r20, r26
    13c8:	5b 07       	cpc	r21, r27
    13ca:	11 f0       	breq	.+4      	; 0x13d0 <_ZN10time_stampeqERKS_+0x26>
	}
	else
	{
		return (false);
	}
}
    13cc:	86 2f       	mov	r24, r22
    13ce:	08 95       	ret
 *  other time stamp are equal to those in this one. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if the time stamps contain equal data, false if they don't
 */

bool time_stamp::operator == (const time_stamp& other)
    13d0:	61 e0       	ldi	r22, 0x01	; 1
	}
	else
	{
		return (false);
	}
}
    13d2:	86 2f       	mov	r24, r22
    13d4:	08 95       	ret

000013d6 <_ZN10time_stampgeERKS_>:
 *  which case this time is greater) or not. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is greater than or equal to the other one
 */

bool time_stamp::operator >= (const time_stamp& other)
    13d6:	fc 01       	movw	r30, r24
    13d8:	9b 01       	movw	r18, r22
    13da:	60 e0       	ldi	r22, 0x00	; 0
    13dc:	80 81       	ld	r24, Z
    13de:	91 81       	ldd	r25, Z+1	; 0x01
    13e0:	a2 81       	ldd	r26, Z+2	; 0x02
    13e2:	b3 81       	ldd	r27, Z+3	; 0x03
    13e4:	f9 01       	movw	r30, r18
    13e6:	20 81       	ld	r18, Z
    13e8:	31 81       	ldd	r19, Z+1	; 0x01
    13ea:	42 81       	ldd	r20, Z+2	; 0x02
    13ec:	53 81       	ldd	r21, Z+3	; 0x03
    13ee:	82 1b       	sub	r24, r18
    13f0:	93 0b       	sbc	r25, r19
    13f2:	a4 0b       	sbc	r26, r20
    13f4:	b5 0b       	sbc	r27, r21
    13f6:	b7 ff       	sbrs	r27, 7
    13f8:	61 e0       	ldi	r22, 0x01	; 1
	}
	else
	{
		return (false);
	}
}
    13fa:	86 2f       	mov	r24, r22
    13fc:	08 95       	ret

000013fe <_ZN10time_stampgtERKS_>:
 *  other time stamp from this time stamp, then checks if the result is positive. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is greater than the other one
 */

bool time_stamp::operator > (const time_stamp& other)
    13fe:	fc 01       	movw	r30, r24
    1400:	9b 01       	movw	r18, r22
    1402:	60 e0       	ldi	r22, 0x00	; 0
    1404:	80 81       	ld	r24, Z
    1406:	91 81       	ldd	r25, Z+1	; 0x01
    1408:	a2 81       	ldd	r26, Z+2	; 0x02
    140a:	b3 81       	ldd	r27, Z+3	; 0x03
    140c:	f9 01       	movw	r30, r18
    140e:	20 81       	ld	r18, Z
    1410:	31 81       	ldd	r19, Z+1	; 0x01
    1412:	42 81       	ldd	r20, Z+2	; 0x02
    1414:	53 81       	ldd	r21, Z+3	; 0x03
    1416:	82 1b       	sub	r24, r18
    1418:	93 0b       	sbc	r25, r19
    141a:	a4 0b       	sbc	r26, r20
    141c:	b5 0b       	sbc	r27, r21
    141e:	18 16       	cp	r1, r24
    1420:	19 06       	cpc	r1, r25
    1422:	1a 06       	cpc	r1, r26
    1424:	1b 06       	cpc	r1, r27
    1426:	0c f4       	brge	.+2      	; 0x142a <_ZN10time_stampgtERKS_+0x2c>
    1428:	61 e0       	ldi	r22, 0x01	; 1
	}
	else
	{
		return (false);
	}
}
    142a:	86 2f       	mov	r24, r22
    142c:	08 95       	ret

0000142e <_ZN10time_stampleERKS_>:
 *  positive. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is less than or equal to the other one
 */

bool time_stamp::operator <= (const time_stamp& other)
    142e:	fc 01       	movw	r30, r24
    1430:	9b 01       	movw	r18, r22
    1432:	60 e0       	ldi	r22, 0x00	; 0
    1434:	80 81       	ld	r24, Z
    1436:	91 81       	ldd	r25, Z+1	; 0x01
    1438:	a2 81       	ldd	r26, Z+2	; 0x02
    143a:	b3 81       	ldd	r27, Z+3	; 0x03
    143c:	f9 01       	movw	r30, r18
    143e:	20 81       	ld	r18, Z
    1440:	31 81       	ldd	r19, Z+1	; 0x01
    1442:	42 81       	ldd	r20, Z+2	; 0x02
    1444:	53 81       	ldd	r21, Z+3	; 0x03
    1446:	82 1b       	sub	r24, r18
    1448:	93 0b       	sbc	r25, r19
    144a:	a4 0b       	sbc	r26, r20
    144c:	b5 0b       	sbc	r27, r21
    144e:	18 16       	cp	r1, r24
    1450:	19 06       	cpc	r1, r25
    1452:	1a 06       	cpc	r1, r26
    1454:	1b 06       	cpc	r1, r27
    1456:	14 f4       	brge	.+4      	; 0x145c <_ZN10time_stampleERKS_+0x2e>
	}
	else
	{
		return (false);
	}
}
    1458:	86 2f       	mov	r24, r22
    145a:	08 95       	ret
 *  positive. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is less than or equal to the other one
 */

bool time_stamp::operator <= (const time_stamp& other)
    145c:	61 e0       	ldi	r22, 0x01	; 1
	}
	else
	{
		return (false);
	}
}
    145e:	86 2f       	mov	r24, r22
    1460:	08 95       	ret

00001462 <_ZN10time_stampltERKS_>:
 *  other time stamp from this time stamp, then checks if the result is negative. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is less than the other one
 */

bool time_stamp::operator < (const time_stamp& other)
    1462:	fc 01       	movw	r30, r24
    1464:	9b 01       	movw	r18, r22
    1466:	60 e0       	ldi	r22, 0x00	; 0
    1468:	80 81       	ld	r24, Z
    146a:	91 81       	ldd	r25, Z+1	; 0x01
    146c:	a2 81       	ldd	r26, Z+2	; 0x02
    146e:	b3 81       	ldd	r27, Z+3	; 0x03
    1470:	f9 01       	movw	r30, r18
    1472:	20 81       	ld	r18, Z
    1474:	31 81       	ldd	r19, Z+1	; 0x01
    1476:	42 81       	ldd	r20, Z+2	; 0x02
    1478:	53 81       	ldd	r21, Z+3	; 0x03
    147a:	82 1b       	sub	r24, r18
    147c:	93 0b       	sbc	r25, r19
    147e:	a4 0b       	sbc	r26, r20
    1480:	b5 0b       	sbc	r27, r21
    1482:	b7 fd       	sbrc	r27, 7
    1484:	02 c0       	rjmp	.+4      	; 0x148a <_ZN10time_stampltERKS_+0x28>
	}
	else
	{
		return (false);
	}
}
    1486:	86 2f       	mov	r24, r22
    1488:	08 95       	ret
 *  other time stamp from this time stamp, then checks if the result is negative. 
 *  @param other A time stamp to be compared to this one 
 *  @return True if this time stamp is less than the other one
 */

bool time_stamp::operator < (const time_stamp& other)
    148a:	61 e0       	ldi	r22, 0x01	; 1
	}
	else
	{
		return (false);
	}
}
    148c:	86 2f       	mov	r24, r22
    148e:	08 95       	ret

00001490 <_ZN10task_timerC2Ev>:
 *  to count at ~1 MHz and interrupt on overflow. Note that this method does not enable
 *  interrupts globally, so the user must call sei() at some point to enable the timer
 *  interrupts to run and time to actually be measured. 
 */

task_timer::task_timer (void)
    1490:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    1492:	10 82       	st	Z, r1
    1494:	11 82       	std	Z+1, r1	; 0x01
    1496:	12 82       	std	Z+2, r1	; 0x02
    1498:	13 82       	std	Z+3, r1	; 0x03
 */

task_timer::task_timer (void)
{
	#ifdef TCNT3							// If Timer 3 exists, we'll use it
		TCCR3A = 0x00;						// Set to normal 16-bit counting mode
    149a:	10 92 90 00 	sts	0x0090, r1
		TCCR3B = (1 << CS31);				// Set prescaler to main clock / 8
    149e:	82 e0       	ldi	r24, 0x02	; 2
    14a0:	80 93 91 00 	sts	0x0091, r24
		#ifdef ETIMSK						// For ATmega128
			ETIMSK |= (1 << TOIE3);			// Set Timer 3 overflow interrupt enable
		#endif
		#ifdef TIMSK3						// For ATmega1281
			TIMSK3 |= (1 << TOIE3);			// Set Timer 3 overflow interrupt enable
    14a4:	e1 e7       	ldi	r30, 0x71	; 113
    14a6:	f0 e0       	ldi	r31, 0x00	; 0
    14a8:	80 81       	ld	r24, Z
    14aa:	81 60       	ori	r24, 0x01	; 1
    14ac:	80 83       	st	Z, r24
			TIMSK1 |= (1 << TOIE1);			// Enable Timer 1 overflow interrupt
		#else								// If no TIMSK1, there's a TIMSK
			TIMSK |= (1 << TOIE1);			// Enable Timer 1 overflow interrupt
		#endif
	#endif
}
    14ae:	08 95       	ret

000014b0 <_ZN10task_timerC1Ev>:
 *  to count at ~1 MHz and interrupt on overflow. Note that this method does not enable
 *  interrupts globally, so the user must call sei() at some point to enable the timer
 *  interrupts to run and time to actually be measured. 
 */

task_timer::task_timer (void)
    14b0:	fc 01       	movw	r30, r24
 *  @param a_time A 32-bit time number with which the time stamp is filled
 */

void time_stamp::set_time (uint32_t a_time)
{
	data.whole = a_time;
    14b2:	10 82       	st	Z, r1
    14b4:	11 82       	std	Z+1, r1	; 0x01
    14b6:	12 82       	std	Z+2, r1	; 0x02
    14b8:	13 82       	std	Z+3, r1	; 0x03
 */

task_timer::task_timer (void)
{
	#ifdef TCNT3							// If Timer 3 exists, we'll use it
		TCCR3A = 0x00;						// Set to normal 16-bit counting mode
    14ba:	10 92 90 00 	sts	0x0090, r1
		TCCR3B = (1 << CS31);				// Set prescaler to main clock / 8
    14be:	82 e0       	ldi	r24, 0x02	; 2
    14c0:	80 93 91 00 	sts	0x0091, r24
		#ifdef ETIMSK						// For ATmega128
			ETIMSK |= (1 << TOIE3);			// Set Timer 3 overflow interrupt enable
		#endif
		#ifdef TIMSK3						// For ATmega1281
			TIMSK3 |= (1 << TOIE3);			// Set Timer 3 overflow interrupt enable
    14c4:	e1 e7       	ldi	r30, 0x71	; 113
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	80 81       	ld	r24, Z
    14ca:	81 60       	ori	r24, 0x01	; 1
    14cc:	80 83       	st	Z, r24
			TIMSK1 |= (1 << TOIE1);			// Enable Timer 1 overflow interrupt
		#else								// If no TIMSK1, there's a TIMSK
			TIMSK |= (1 << TOIE1);			// Enable Timer 1 overflow interrupt
		#endif
	#endif
}
    14ce:	08 95       	ret

000014d0 <_ZN10task_timer15save_time_stampER10time_stamp>:
 *  would cause invalid data to be saved), interrupts are disabled while the time data 
 *  is being copied. 
 *  @param the_stamp Reference to a time stamp variable which will hold the time
 */

void task_timer::save_time_stamp (time_stamp& the_stamp)
    14d0:	fb 01       	movw	r30, r22
{
	uint8_t temp_sreg = SREG;				// Store interrupt flag status
    14d2:	2f b7       	in	r18, 0x3f	; 63
	the_stamp.data.half[0] = TMR_TCNT_REG;	// Get hardware count
    14d4:	80 91 94 00 	lds	r24, 0x0094
    14d8:	90 91 95 00 	lds	r25, 0x0095
    14dc:	91 83       	std	Z+1, r25	; 0x01
    14de:	80 83       	st	Z, r24
	cli ();									// Prevent interruption
    14e0:	f8 94       	cli
	the_stamp.data.half[1] = ust_overflows;	// Get overflow counter data
    14e2:	80 91 50 02 	lds	r24, 0x0250
    14e6:	90 91 51 02 	lds	r25, 0x0251
    14ea:	93 83       	std	Z+3, r25	; 0x03
    14ec:	82 83       	std	Z+2, r24	; 0x02
	SREG = temp_sreg;						// Re-enable interrupts if they were on
    14ee:	2f bf       	out	0x3f, r18	; 63
}
    14f0:	08 95       	ret

000014f2 <_ZN10task_timer12get_time_nowEv>:
/** This method saves the current time in the internal time stamp belonging to this 
 *  object, then returns a reference to the time stamp so that the caller can use it as
 *  a measurement of what the time is now. 
 */

time_stamp& task_timer::get_time_now (void)
    14f2:	fc 01       	movw	r30, r24
{
	uint8_t temp_sreg = SREG;				// Store interrupt flag status
    14f4:	2f b7       	in	r18, 0x3f	; 63
	now_time.data.half[0] = TMR_TCNT_REG;	// Get hardware count
    14f6:	80 91 94 00 	lds	r24, 0x0094
    14fa:	90 91 95 00 	lds	r25, 0x0095
    14fe:	91 83       	std	Z+1, r25	; 0x01
    1500:	80 83       	st	Z, r24
	cli ();									// Prevent interruption
    1502:	f8 94       	cli
	now_time.data.half[1] = ust_overflows;	// Get overflow counter data
    1504:	80 91 50 02 	lds	r24, 0x0250
    1508:	90 91 51 02 	lds	r25, 0x0251
    150c:	93 83       	std	Z+3, r25	; 0x03
    150e:	82 83       	std	Z+2, r24	; 0x02
	SREG = temp_sreg;						// Re-enable interrupts if they were on
    1510:	2f bf       	out	0x3f, r18	; 63

	return (now_time);						// Return a reference to the current time
}
    1512:	cf 01       	movw	r24, r30
    1514:	08 95       	ret

00001516 <_ZN10task_timer8set_timeER10time_stamp>:
 *  that measure times of day (in hours, minutes, and seconds) and do need to be set by
 *  user programs. 
 *  @param t_stamp A reference to a time stamp containing the time to be set
 */

bool task_timer::set_time (time_stamp& t_stamp)
    1516:	fb 01       	movw	r30, r22
{
	uint8_t temp_sreg = SREG;				// Store interrupt flag status
    1518:	2f b7       	in	r18, 0x3f	; 63
	cli ();									// Prevent interruption
    151a:	f8 94       	cli
	ust_overflows = t_stamp.data.half[1];
    151c:	82 81       	ldd	r24, Z+2	; 0x02
    151e:	93 81       	ldd	r25, Z+3	; 0x03
    1520:	90 93 51 02 	sts	0x0251, r25
    1524:	80 93 50 02 	sts	0x0250, r24
	TMR_TCNT_REG = t_stamp.data.half[0];
    1528:	80 81       	ld	r24, Z
    152a:	91 81       	ldd	r25, Z+1	; 0x01
    152c:	90 93 95 00 	sts	0x0095, r25
    1530:	80 93 94 00 	sts	0x0094, r24
	SREG = temp_sreg;						// Re-enable interrupts if they were on
    1534:	2f bf       	out	0x3f, r18	; 63
}
    1536:	08 95       	ret

00001538 <__vector_35>:
/** This is the interrupt service routine which is called whenever there is a compare
 *  match on the 16-bit timer's counter. Nearly all AVR processors have a 16-bit timer
 *  called Timer 1, and this is the one we use here. 
 */

ISR (TMR_intr_vect)
    1538:	1f 92       	push	r1
    153a:	0f 92       	push	r0
    153c:	0f b6       	in	r0, 0x3f	; 63
    153e:	0f 92       	push	r0
    1540:	11 24       	eor	r1, r1
    1542:	8f 93       	push	r24
    1544:	9f 93       	push	r25
{
	ust_overflows++;
    1546:	80 91 50 02 	lds	r24, 0x0250
    154a:	90 91 51 02 	lds	r25, 0x0251
    154e:	01 96       	adiw	r24, 0x01	; 1
    1550:	90 93 51 02 	sts	0x0251, r25
    1554:	80 93 50 02 	sts	0x0250, r24
}
    1558:	9f 91       	pop	r25
    155a:	8f 91       	pop	r24
    155c:	0f 90       	pop	r0
    155e:	0f be       	out	0x3f, r0	; 63
    1560:	0f 90       	pop	r0
    1562:	1f 90       	pop	r1
    1564:	18 95       	reti

00001566 <_ZlsR16base_text_serialR10time_stamp>:
 *  up in the style of 'cout.' The timestamp is always printed as a decimal number. 
 *  @param serial A reference to the serial-type object to which to print
 *  @param stamp A reference to the time stamp to be displayed
 */

base_text_serial& operator<< (base_text_serial& serial, time_stamp& stamp)
    1566:	6f 92       	push	r6
    1568:	7f 92       	push	r7
    156a:	8f 92       	push	r8
    156c:	9f 92       	push	r9
    156e:	af 92       	push	r10
    1570:	bf 92       	push	r11
    1572:	cf 92       	push	r12
    1574:	df 92       	push	r13
    1576:	ef 92       	push	r14
    1578:	ff 92       	push	r15
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	ec 01       	movw	r28, r24
    1584:	8b 01       	movw	r16, r22
{
	// Get the time in seconds and microseconds
	uint16_t seconds = stamp.get_seconds ();
    1586:	cb 01       	movw	r24, r22
    1588:	0e 94 3e 09 	call	0x127c	; 0x127c <_ZN10time_stamp11get_secondsEv>
    158c:	7c 01       	movw	r14, r24
	uint32_t microseconds = stamp.get_microsec ();
    158e:	c8 01       	movw	r24, r16
    1590:	0e 94 4b 09 	call	0x1296	; 0x1296 <_ZN10time_stamp12get_microsecEv>
    1594:	3b 01       	movw	r6, r22
    1596:	4c 01       	movw	r8, r24

	serial << seconds;
    1598:	ce 01       	movw	r24, r28
    159a:	b7 01       	movw	r22, r14
    159c:	0e 94 de 0e 	call	0x1dbc	; 0x1dbc <_ZN16base_text_seriallsEj>
	serial.putchar ('.');
    15a0:	e8 81       	ld	r30, Y
    15a2:	f9 81       	ldd	r31, Y+1	; 0x01
    15a4:	02 80       	ldd	r0, Z+2	; 0x02
    15a6:	f3 81       	ldd	r31, Z+3	; 0x03
    15a8:	e0 2d       	mov	r30, r0
    15aa:	ce 01       	movw	r24, r28
    15ac:	6e e2       	ldi	r22, 0x2E	; 46
    15ae:	09 95       	icall
    15b0:	20 ea       	ldi	r18, 0xA0	; 160
    15b2:	c2 2e       	mov	r12, r18
    15b4:	26 e8       	ldi	r18, 0x86	; 134
    15b6:	d2 2e       	mov	r13, r18
    15b8:	21 e0       	ldi	r18, 0x01	; 1
    15ba:	e2 2e       	mov	r14, r18
    15bc:	f1 2c       	mov	r15, r1
    15be:	aa 24       	eor	r10, r10
    15c0:	bb 24       	eor	r11, r11

	// For the digits in the fractional part, write 'em in backwards order. We can't
	// use itoa here because we need leading zeros
	for (uint32_t divisor = 100000; divisor > 0; divisor /= 10)
	{
		serial.putchar (microseconds / divisor + '0');
    15c2:	08 81       	ld	r16, Y
    15c4:	19 81       	ldd	r17, Y+1	; 0x01
    15c6:	b3 01       	movw	r22, r6
    15c8:	c4 01       	movw	r24, r8
    15ca:	a7 01       	movw	r20, r14
    15cc:	96 01       	movw	r18, r12
    15ce:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    15d2:	20 5d       	subi	r18, 0xD0	; 208
    15d4:	d8 01       	movw	r26, r16
    15d6:	12 96       	adiw	r26, 0x02	; 2
    15d8:	ed 91       	ld	r30, X+
    15da:	fc 91       	ld	r31, X
    15dc:	13 97       	sbiw	r26, 0x03	; 3
    15de:	ce 01       	movw	r24, r28
    15e0:	62 2f       	mov	r22, r18
    15e2:	09 95       	icall
		microseconds %= divisor;
    15e4:	b3 01       	movw	r22, r6
    15e6:	c4 01       	movw	r24, r8
    15e8:	a7 01       	movw	r20, r14
    15ea:	96 01       	movw	r18, r12
    15ec:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    15f0:	3b 01       	movw	r6, r22
    15f2:	4c 01       	movw	r8, r24
	serial << seconds;
	serial.putchar ('.');

	// For the digits in the fractional part, write 'em in backwards order. We can't
	// use itoa here because we need leading zeros
	for (uint32_t divisor = 100000; divisor > 0; divisor /= 10)
    15f4:	c7 01       	movw	r24, r14
    15f6:	b6 01       	movw	r22, r12
    15f8:	2a e0       	ldi	r18, 0x0A	; 10
    15fa:	30 e0       	ldi	r19, 0x00	; 0
    15fc:	40 e0       	ldi	r20, 0x00	; 0
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    1604:	c9 01       	movw	r24, r18
    1606:	da 01       	movw	r26, r20
    1608:	6c 01       	movw	r12, r24
    160a:	7d 01       	movw	r14, r26
    160c:	08 94       	sec
    160e:	a1 1c       	adc	r10, r1
    1610:	b1 1c       	adc	r11, r1
    1612:	b6 e0       	ldi	r27, 0x06	; 6
    1614:	ab 16       	cp	r10, r27
    1616:	b1 04       	cpc	r11, r1
    1618:	a1 f6       	brne	.-88     	; 0x15c2 <_ZlsR16base_text_serialR10time_stamp+0x5c>
		serial.putchar (microseconds / divisor + '0');
		microseconds %= divisor;
	}

	return (serial);
}
    161a:	ce 01       	movw	r24, r28
    161c:	df 91       	pop	r29
    161e:	cf 91       	pop	r28
    1620:	1f 91       	pop	r17
    1622:	0f 91       	pop	r16
    1624:	ff 90       	pop	r15
    1626:	ef 90       	pop	r14
    1628:	df 90       	pop	r13
    162a:	cf 90       	pop	r12
    162c:	bf 90       	pop	r11
    162e:	af 90       	pop	r10
    1630:	9f 90       	pop	r9
    1632:	8f 90       	pop	r8
    1634:	7f 90       	pop	r7
    1636:	6f 90       	pop	r6
    1638:	08 95       	ret

0000163a <_ZlsR16base_text_serialR10task_timer>:
 *  has the time stamp print itself. 
 *  @param serial A reference to the serial-type object to which to print
 *  @param tmr A reference to the timer whose time is to be displayed
 */

base_text_serial& operator<< (base_text_serial& serial, task_timer& tmr)
    163a:	0f 93       	push	r16
    163c:	1f 93       	push	r17
    163e:	18 2f       	mov	r17, r24
    1640:	09 2f       	mov	r16, r25
    1642:	fb 01       	movw	r30, r22
 *  a measurement of what the time is now. 
 */

time_stamp& task_timer::get_time_now (void)
{
	uint8_t temp_sreg = SREG;				// Store interrupt flag status
    1644:	2f b7       	in	r18, 0x3f	; 63
	now_time.data.half[0] = TMR_TCNT_REG;	// Get hardware count
    1646:	80 91 94 00 	lds	r24, 0x0094
    164a:	90 91 95 00 	lds	r25, 0x0095
    164e:	91 83       	std	Z+1, r25	; 0x01
    1650:	80 83       	st	Z, r24
	cli ();									// Prevent interruption
    1652:	f8 94       	cli
	now_time.data.half[1] = ust_overflows;	// Get overflow counter data
    1654:	80 91 50 02 	lds	r24, 0x0250
    1658:	90 91 51 02 	lds	r25, 0x0251
    165c:	93 83       	std	Z+3, r25	; 0x03
    165e:	82 83       	std	Z+2, r24	; 0x02
	SREG = temp_sreg;						// Re-enable interrupts if they were on
    1660:	2f bf       	out	0x3f, r18	; 63
 *  @param tmr A reference to the timer whose time is to be displayed
 */

base_text_serial& operator<< (base_text_serial& serial, task_timer& tmr)
{
	serial << tmr.get_time_now ();
    1662:	81 2f       	mov	r24, r17
    1664:	90 2f       	mov	r25, r16
    1666:	0e 94 b3 0a 	call	0x1566	; 0x1566 <_ZlsR16base_text_serialR10time_stamp>
	return (serial);
}
    166a:	81 2f       	mov	r24, r17
    166c:	90 2f       	mov	r25, r16
    166e:	1f 91       	pop	r17
    1670:	0f 91       	pop	r16
    1672:	08 95       	ret

00001674 <__cxa_guard_acquire>:
//-------------------------------------------------------------------------------------
// Stuff needed for templates and virtual methods (?). Doxygen comments in mechutil.h

extern "C"
{
int __cxa_guard_acquire (__guard *g)
    1674:	fc 01       	movw	r30, r24
    1676:	20 e0       	ldi	r18, 0x00	; 0
    1678:	30 e0       	ldi	r19, 0x00	; 0
    167a:	80 81       	ld	r24, Z
    167c:	88 23       	and	r24, r24
    167e:	11 f4       	brne	.+4      	; 0x1684 <__cxa_guard_acquire+0x10>
    1680:	21 e0       	ldi	r18, 0x01	; 1
    1682:	30 e0       	ldi	r19, 0x00	; 0
    {
    return !*(char *)(g);
    }
    1684:	c9 01       	movw	r24, r18
    1686:	08 95       	ret

00001688 <__cxa_guard_release>:
}

extern "C"
{
void __cxa_guard_release (__guard *g)
    1688:	fc 01       	movw	r30, r24
    {
    *(char *)g = 1;
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	80 83       	st	Z, r24
    }
    168e:	08 95       	ret

00001690 <__cxa_guard_abort>:

extern "C"
{
void __cxa_guard_abort (__guard *g)
    {
    }
    1690:	08 95       	ret

00001692 <__cxa_pure_virtual>:

extern "C"
{    
void __cxa_pure_virtual (void)
    {
    }
    1692:	08 95       	ret

00001694 <_ZdaPv>:
    return malloc (size);
    }
 
void operator delete[] (void* ptr) 
    { 
    if (ptr) free (ptr); 
    1694:	00 97       	sbiw	r24, 0x00	; 0
    1696:	11 f0       	breq	.+4      	; 0x169c <_ZdaPv+0x8>
    1698:	0e 94 09 12 	call	0x2412	; 0x2412 <free>
    169c:	08 95       	ret

0000169e <_ZdlPv>:
    return malloc (size); 
    } 
 
void operator delete (void* ptr) 
    { 
    if (ptr) free (ptr); 
    169e:	00 97       	sbiw	r24, 0x00	; 0
    16a0:	11 f0       	breq	.+4      	; 0x16a6 <_ZdlPv+0x8>
    16a2:	0e 94 09 12 	call	0x2412	; 0x2412 <free>
    16a6:	08 95       	ret

000016a8 <_Znaj>:
    } 
      
void* operator new[] (size_t size)
    {
    return malloc (size);
    16a8:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <malloc>
    }
    16ac:	08 95       	ret

000016ae <_Znwj>:
//-------------------------------------------------------------------------------------
// Stuff to make the new and delete operators work. Doxygen comments in mechutil.h

void* operator new (size_t size) 
    { 
    return malloc (size); 
    16ae:	0e 94 5c 11 	call	0x22b8	; 0x22b8 <malloc>
    } 
    16b2:	08 95       	ret

000016b4 <_ZN7base232C2Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    16b4:	cf 93       	push	r28
    16b6:	df 93       	push	r29
    16b8:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    16ba:	44 23       	and	r20, r20
    16bc:	09 f4       	brne	.+2      	; 0x16c0 <_ZN7base232C2Ejh+0xc>
    16be:	41 c0       	rjmp	.+130    	; 0x1742 <_ZN7base232C2Ejh+0x8e>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    16c0:	8e ec       	ldi	r24, 0xCE	; 206
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	99 83       	std	Y+1, r25	; 0x01
    16c6:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    16c8:	88 ec       	ldi	r24, 0xC8	; 200
    16ca:	90 e0       	ldi	r25, 0x00	; 0
    16cc:	9b 83       	std	Y+3, r25	; 0x03
    16ce:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    16d0:	89 ec       	ldi	r24, 0xC9	; 201
    16d2:	90 e0       	ldi	r25, 0x00	; 0
    16d4:	9d 83       	std	Y+5, r25	; 0x05
    16d6:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    16d8:	88 e1       	ldi	r24, 0x18	; 24
    16da:	80 93 c9 00 	sts	0x00C9, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    16de:	86 e0       	ldi	r24, 0x06	; 6
    16e0:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    16e4:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    16e8:	9b 01       	movw	r18, r22
    16ea:	40 e0       	ldi	r20, 0x00	; 0
    16ec:	50 e0       	ldi	r21, 0x00	; 0
    16ee:	22 0f       	add	r18, r18
    16f0:	33 1f       	adc	r19, r19
    16f2:	44 1f       	adc	r20, r20
    16f4:	55 1f       	adc	r21, r21
    16f6:	22 0f       	add	r18, r18
    16f8:	33 1f       	adc	r19, r19
    16fa:	44 1f       	adc	r20, r20
    16fc:	55 1f       	adc	r21, r21
    16fe:	22 0f       	add	r18, r18
    1700:	33 1f       	adc	r19, r19
    1702:	44 1f       	adc	r20, r20
    1704:	55 1f       	adc	r21, r21
    1706:	22 0f       	add	r18, r18
    1708:	33 1f       	adc	r19, r19
    170a:	44 1f       	adc	r20, r20
    170c:	55 1f       	adc	r21, r21
    170e:	60 e0       	ldi	r22, 0x00	; 0
    1710:	74 e2       	ldi	r23, 0x24	; 36
    1712:	84 ef       	ldi	r24, 0xF4	; 244
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    171a:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    171e:	80 91 c8 00 	lds	r24, 0x00C8
    1722:	81 60       	ori	r24, 0x01	; 1
    1724:	80 93 c8 00 	sts	0x00C8, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    1728:	80 e2       	ldi	r24, 0x20	; 32
    172a:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    172c:	80 e8       	ldi	r24, 0x80	; 128
    172e:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    1730:	80 e4       	ldi	r24, 0x40	; 64
    1732:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    1734:	e8 81       	ld	r30, Y
    1736:	f9 81       	ldd	r31, Y+1	; 0x01
    1738:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    173a:	80 81       	ld	r24, Z
}
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    1742:	86 ec       	ldi	r24, 0xC6	; 198
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	99 83       	std	Y+1, r25	; 0x01
    1748:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    174a:	80 ec       	ldi	r24, 0xC0	; 192
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	9b 83       	std	Y+3, r25	; 0x03
    1750:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    1752:	81 ec       	ldi	r24, 0xC1	; 193
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	9d 83       	std	Y+5, r25	; 0x05
    1758:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    175a:	88 e1       	ldi	r24, 0x18	; 24
    175c:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    1760:	86 e0       	ldi	r24, 0x06	; 6
    1762:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    1766:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    176a:	9b 01       	movw	r18, r22
    176c:	40 e0       	ldi	r20, 0x00	; 0
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	22 0f       	add	r18, r18
    1772:	33 1f       	adc	r19, r19
    1774:	44 1f       	adc	r20, r20
    1776:	55 1f       	adc	r21, r21
    1778:	22 0f       	add	r18, r18
    177a:	33 1f       	adc	r19, r19
    177c:	44 1f       	adc	r20, r20
    177e:	55 1f       	adc	r21, r21
    1780:	22 0f       	add	r18, r18
    1782:	33 1f       	adc	r19, r19
    1784:	44 1f       	adc	r20, r20
    1786:	55 1f       	adc	r21, r21
    1788:	22 0f       	add	r18, r18
    178a:	33 1f       	adc	r19, r19
    178c:	44 1f       	adc	r20, r20
    178e:	55 1f       	adc	r21, r21
    1790:	60 e0       	ldi	r22, 0x00	; 0
    1792:	74 e2       	ldi	r23, 0x24	; 36
    1794:	84 ef       	ldi	r24, 0xF4	; 244
    1796:	90 e0       	ldi	r25, 0x00	; 0
    1798:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    179c:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    17a0:	80 91 c0 00 	lds	r24, 0x00C0
    17a4:	81 60       	ori	r24, 0x01	; 1
    17a6:	80 93 c0 00 	sts	0x00C0, r24
    17aa:	be cf       	rjmp	.-132    	; 0x1728 <_ZN7base232C2Ejh+0x74>

000017ac <_ZN7base232C1Ejh>:
 *                     1 only exists on some processors). The default is port 0 
 */

// This section compiles for the AVR microcontroller
#ifdef __AVR
base232::base232 (unsigned int baud_rate, unsigned char port_number)
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	ec 01       	movw	r28, r24
{
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
    17b2:	44 23       	and	r20, r20
    17b4:	09 f4       	brne	.+2      	; 0x17b8 <_ZN7base232C1Ejh+0xc>
    17b6:	41 c0       	rjmp	.+130    	; 0x183a <_ZN7base232C1Ejh+0x8e>
			mask_TXC = (1 << TXC0);
		}
		else	// The port number isn't 0, so it presumably must be serial port 1
		{
		#if defined UCSR1A
			p_UDR = &UDR1;
    17b8:	8e ec       	ldi	r24, 0xCE	; 206
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	99 83       	std	Y+1, r25	; 0x01
    17be:	88 83       	st	Y, r24
			p_USR = &UCSR1A;
    17c0:	88 ec       	ldi	r24, 0xC8	; 200
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	9b 83       	std	Y+3, r25	; 0x03
    17c6:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR1B;
    17c8:	89 ec       	ldi	r24, 0xC9	; 201
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	9d 83       	std	Y+5, r25	; 0x05
    17ce:	8c 83       	std	Y+4, r24	; 0x04
			UCSR1B = (1 << RXEN1) | (1 << TXEN1);
    17d0:	88 e1       	ldi	r24, 0x18	; 24
    17d2:	80 93 c9 00 	sts	0x00C9, r24
			UCSR1C = (1 << UCSZ11) | (1 << UCSZ10); // | (1 << USBS1);
    17d6:	86 e0       	ldi	r24, 0x06	; 6
    17d8:	80 93 ca 00 	sts	0x00CA, r24
			UBRR1H = 0x00;
    17dc:	10 92 cd 00 	sts	0x00CD, r1
			UBRR1L = calc_baud_div (baud_rate);
    17e0:	9b 01       	movw	r18, r22
    17e2:	40 e0       	ldi	r20, 0x00	; 0
    17e4:	50 e0       	ldi	r21, 0x00	; 0
    17e6:	22 0f       	add	r18, r18
    17e8:	33 1f       	adc	r19, r19
    17ea:	44 1f       	adc	r20, r20
    17ec:	55 1f       	adc	r21, r21
    17ee:	22 0f       	add	r18, r18
    17f0:	33 1f       	adc	r19, r19
    17f2:	44 1f       	adc	r20, r20
    17f4:	55 1f       	adc	r21, r21
    17f6:	22 0f       	add	r18, r18
    17f8:	33 1f       	adc	r19, r19
    17fa:	44 1f       	adc	r20, r20
    17fc:	55 1f       	adc	r21, r21
    17fe:	22 0f       	add	r18, r18
    1800:	33 1f       	adc	r19, r19
    1802:	44 1f       	adc	r20, r20
    1804:	55 1f       	adc	r21, r21
    1806:	60 e0       	ldi	r22, 0x00	; 0
    1808:	74 e2       	ldi	r23, 0x24	; 36
    180a:	84 ef       	ldi	r24, 0xF4	; 244
    180c:	90 e0       	ldi	r25, 0x00	; 0
    180e:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    1812:	20 93 cc 00 	sts	0x00CC, r18
			#ifdef UART_DOUBLE_SPEED		// If double-speed macro has been defined,
				UCSR1A |= U2X1;				// turn on double-speed operation
    1816:	80 91 c8 00 	lds	r24, 0x00C8
    181a:	81 60       	ori	r24, 0x01	; 1
    181c:	80 93 c8 00 	sts	0x00C8, r24
			#endif
			mask_UDRE = (1 << UDRE1);
    1820:	80 e2       	ldi	r24, 0x20	; 32
    1822:	8e 83       	std	Y+6, r24	; 0x06
			mask_RXC = (1 << RXC1);
    1824:	80 e8       	ldi	r24, 0x80	; 128
    1826:	8f 83       	std	Y+7, r24	; 0x07
			mask_TXC = (1 << TXC1);
    1828:	80 e4       	ldi	r24, 0x40	; 64
    182a:	88 87       	std	Y+8, r24	; 0x08
			mask_TXC = (1 << TXC);
		#endif // UCSRA
	#endif // UCSR0A

	// Read the data register to ensure that it's empty
	port_number = *p_UDR;
    182c:	e8 81       	ld	r30, Y
    182e:	f9 81       	ldd	r31, Y+1	; 0x01
    1830:	80 81       	ld	r24, Z
	port_number = *p_UDR;
    1832:	80 81       	ld	r24, Z
}
    1834:	df 91       	pop	r29
    1836:	cf 91       	pop	r28
    1838:	08 95       	ret
	// If we're compiling for a chip with UCSR0A defined, it has dual serial ports
	// (examples are ATmega324P and ATmega128). Set up Port 0 or Port 1
	#if defined UCSR0A
		if (port_number == 0)
		{
			p_UDR = &UDR0;
    183a:	86 ec       	ldi	r24, 0xC6	; 198
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	99 83       	std	Y+1, r25	; 0x01
    1840:	88 83       	st	Y, r24
			p_USR = &UCSR0A;
    1842:	80 ec       	ldi	r24, 0xC0	; 192
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	9b 83       	std	Y+3, r25	; 0x03
    1848:	8a 83       	std	Y+2, r24	; 0x02
			p_UCR = &UCSR0B;
    184a:	81 ec       	ldi	r24, 0xC1	; 193
    184c:	90 e0       	ldi	r25, 0x00	; 0
    184e:	9d 83       	std	Y+5, r25	; 0x05
    1850:	8c 83       	std	Y+4, r24	; 0x04
			UCSR0B = (1 << RXEN0) | (1 << TXEN0);
    1852:	88 e1       	ldi	r24, 0x18	; 24
    1854:	80 93 c1 00 	sts	0x00C1, r24
			UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // | (1 << USBS0);
    1858:	86 e0       	ldi	r24, 0x06	; 6
    185a:	80 93 c2 00 	sts	0x00C2, r24
			UBRR0H = 0x00;
    185e:	10 92 c5 00 	sts	0x00C5, r1
			UBRR0L = calc_baud_div (baud_rate);
    1862:	9b 01       	movw	r18, r22
    1864:	40 e0       	ldi	r20, 0x00	; 0
    1866:	50 e0       	ldi	r21, 0x00	; 0
    1868:	22 0f       	add	r18, r18
    186a:	33 1f       	adc	r19, r19
    186c:	44 1f       	adc	r20, r20
    186e:	55 1f       	adc	r21, r21
    1870:	22 0f       	add	r18, r18
    1872:	33 1f       	adc	r19, r19
    1874:	44 1f       	adc	r20, r20
    1876:	55 1f       	adc	r21, r21
    1878:	22 0f       	add	r18, r18
    187a:	33 1f       	adc	r19, r19
    187c:	44 1f       	adc	r20, r20
    187e:	55 1f       	adc	r21, r21
    1880:	22 0f       	add	r18, r18
    1882:	33 1f       	adc	r19, r19
    1884:	44 1f       	adc	r20, r20
    1886:	55 1f       	adc	r21, r21
    1888:	60 e0       	ldi	r22, 0x00	; 0
    188a:	74 e2       	ldi	r23, 0x24	; 36
    188c:	84 ef       	ldi	r24, 0xF4	; 244
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    1894:	20 93 c4 00 	sts	0x00C4, r18
			#ifdef UART_DOUBLE_SPEED					// Activate double speed mode
				UCSR0A |= U2X0;							// if required
    1898:	80 91 c0 00 	lds	r24, 0x00C0
    189c:	81 60       	ori	r24, 0x01	; 1
    189e:	80 93 c0 00 	sts	0x00C0, r24
    18a2:	be cf       	rjmp	.-132    	; 0x1820 <_ZN7base232C1Ejh+0x74>

000018a4 <_ZN7base23213ready_to_sendEv>:
/** This method checks if the serial port transmitter is ready to send data.  It 
 *  tests whether transmitter buffer is empty. 
 *  @return True if the serial port is ready to send, and false if not
 */

bool base232::ready_to_send (void)
    18a4:	dc 01       	movw	r26, r24
{
#ifdef __AVR
	// If transmitter buffer is full, we're not ready to send
	if (*p_USR & mask_UDRE)
    18a6:	12 96       	adiw	r26, 0x02	; 2
    18a8:	ed 91       	ld	r30, X+
    18aa:	fc 91       	ld	r31, X
    18ac:	13 97       	sbiw	r26, 0x03	; 3
    18ae:	20 81       	ld	r18, Z
    18b0:	40 e0       	ldi	r20, 0x00	; 0
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	16 96       	adiw	r26, 0x06	; 6
    18b6:	8c 91       	ld	r24, X
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	28 23       	and	r18, r24
    18bc:	39 23       	and	r19, r25
    18be:	23 2b       	or	r18, r19
    18c0:	09 f0       	breq	.+2      	; 0x18c4 <_ZN7base23213ready_to_sendEv+0x20>
    18c2:	41 e0       	ldi	r20, 0x01	; 1
	return (false);
#else
	// The non-AVR (that is, PC) serial port buffer should always be ready
	return (true);
#endif
}
    18c4:	84 2f       	mov	r24, r20
    18c6:	08 95       	ret

000018c8 <_ZN7base23210is_sendingEv>:
 *  last one; it would be a bad idea to put the processor to sleep before the character
 *  has been sent. 
 *  @return True if the port is currently sending a character, false if it's idle
 */

bool base232::is_sending (void)
    18c8:	dc 01       	movw	r26, r24
{
#ifdef __AVR
	if (*p_USR & mask_TXC)
    18ca:	12 96       	adiw	r26, 0x02	; 2
    18cc:	ed 91       	ld	r30, X+
    18ce:	fc 91       	ld	r31, X
    18d0:	13 97       	sbiw	r26, 0x03	; 3
    18d2:	20 81       	ld	r18, Z
    18d4:	40 e0       	ldi	r20, 0x00	; 0
    18d6:	30 e0       	ldi	r19, 0x00	; 0
    18d8:	18 96       	adiw	r26, 0x08	; 8
    18da:	8c 91       	ld	r24, X
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	28 23       	and	r18, r24
    18e0:	39 23       	and	r19, r25
    18e2:	23 2b       	or	r18, r19
    18e4:	09 f4       	brne	.+2      	; 0x18e8 <_ZN7base23210is_sendingEv+0x20>
    18e6:	41 e0       	ldi	r20, 0x01	; 1
		return (true);
#else
	// We don't really care if a PC is sending, as it has a buffer anyway
	return (false);
#endif
}
    18e8:	84 2f       	mov	r24, r20
    18ea:	08 95       	ret

000018ec <_ZN16base_text_serial7putcharEc>:
	// Public methods can be called from anywhere in the program where there is a 
	// pointer or reference to an object of this class
	public:
		base_text_serial (void);			// Simple constructor doesn't do much
		virtual bool ready_to_send (void);  // Virtual and not defined in base class
		virtual bool putchar (char) {}	 	///< Virtual and not defined in base class
    18ec:	08 95       	ret

000018ee <_ZN16base_text_serial4putsEPKc>:
		virtual void puts (char const*) {}	///< Virtual and not defined in base class
    18ee:	08 95       	ret

000018f0 <_ZN16base_text_serialC2Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

base_text_serial::base_text_serial (void)
    18f0:	fc 01       	movw	r30, r24
    18f2:	8f e2       	ldi	r24, 0x2F	; 47
    18f4:	92 e0       	ldi	r25, 0x02	; 2
    18f6:	91 83       	std	Z+1, r25	; 0x01
    18f8:	80 83       	st	Z, r24
{
	base = 10;								// Numbers are shown as decimal by default
    18fa:	8a e0       	ldi	r24, 0x0A	; 10
    18fc:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;					// Print 8-bit chars as numbers by default
    18fe:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;							// Print 3 digits after a decimal point
    1900:	83 e0       	ldi	r24, 0x03	; 3
    1902:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;						// Print strings from SRAM by default
    1904:	14 82       	std	Z+4, r1	; 0x04
}
    1906:	08 95       	ret

00001908 <_ZN16base_text_serialC1Ev>:
//-------------------------------------------------------------------------------------
/** This constructor sets up the base serial port object. It sets the default base for
 *  the conversion of numbers to text and the default format for converting chars. 
 */

base_text_serial::base_text_serial (void)
    1908:	fc 01       	movw	r30, r24
    190a:	8f e2       	ldi	r24, 0x2F	; 47
    190c:	92 e0       	ldi	r25, 0x02	; 2
    190e:	91 83       	std	Z+1, r25	; 0x01
    1910:	80 83       	st	Z, r24
{
	base = 10;								// Numbers are shown as decimal by default
    1912:	8a e0       	ldi	r24, 0x0A	; 10
    1914:	82 83       	std	Z+2, r24	; 0x02
	print_ascii = false;					// Print 8-bit chars as numbers by default
    1916:	13 82       	std	Z+3, r1	; 0x03
	precision = 3;							// Print 3 digits after a decimal point
    1918:	83 e0       	ldi	r24, 0x03	; 3
    191a:	85 83       	std	Z+5, r24	; 0x05
	pgm_string = false;						// Print strings from SRAM by default
    191c:	14 82       	std	Z+4, r1	; 0x04
}
    191e:	08 95       	ret

00001920 <_ZN16base_text_serial13ready_to_sendEv>:
 */

bool base_text_serial::ready_to_send (void)
{
	return (true);							// By default the port's always ready
}
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	08 95       	ret

00001924 <_ZN16base_text_serial7getcharEv>:
 */

char base_text_serial::getchar (void)
{
	return ('\0');							// Nothing to return, really
}
    1924:	80 e0       	ldi	r24, 0x00	; 0
    1926:	08 95       	ret

00001928 <_ZN16base_text_serial14check_for_charEv>:
 */

bool base_text_serial::check_for_char (void)
{
	return (false);
}
    1928:	80 e0       	ldi	r24, 0x00	; 0
    192a:	08 95       	ret

0000192c <_ZN16base_text_serial12transmit_nowEv>:
 *  need to respond to calls for immediate transmission. 
 */

void base_text_serial::transmit_now (void)
{
}
    192c:	08 95       	ret

0000192e <_ZN16base_text_serial12clear_screenEv>:
 *  classes which send things to displays should respond by clearing themselves.
 */

void base_text_serial::clear_screen (void)
{
}
    192e:	08 95       	ret

00001930 <_ZN16base_text_seriallsEPKc>:
 *  character pointer to the serial device. It acts in about the same way as puts(). 
 *  As with puts(), the string must have a null character (ASCII zero) at the end. 
 *  @param string Pointer to the string to be written
 */

base_text_serial& base_text_serial::operator<< (const char* string)
    1930:	0f 93       	push	r16
    1932:	1f 93       	push	r17
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	8c 01       	movw	r16, r24
    193a:	eb 01       	movw	r28, r22
{
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
    193c:	dc 01       	movw	r26, r24
    193e:	14 96       	adiw	r26, 0x04	; 4
    1940:	8c 91       	ld	r24, X
    1942:	88 23       	and	r24, r24
    1944:	19 f1       	breq	.+70     	; 0x198c <_ZN16base_text_seriallsEPKc+0x5c>
	{
		pgm_string = false;
    1946:	f8 01       	movw	r30, r16
    1948:	14 82       	std	Z+4, r1	; 0x04
		while (char ch = pgm_read_byte_near (string++))
    194a:	fb 01       	movw	r30, r22
    194c:	64 91       	lpm	r22, Z+
    194e:	66 23       	and	r22, r22
    1950:	71 f0       	breq	.+28     	; 0x196e <_ZN16base_text_seriallsEPKc+0x3e>
    1952:	21 96       	adiw	r28, 0x01	; 1
			putchar (ch);
    1954:	d8 01       	movw	r26, r16
    1956:	ed 91       	ld	r30, X+
    1958:	fc 91       	ld	r31, X
    195a:	02 80       	ldd	r0, Z+2	; 0x02
    195c:	f3 81       	ldd	r31, Z+3	; 0x03
    195e:	e0 2d       	mov	r30, r0
    1960:	c8 01       	movw	r24, r16
    1962:	09 95       	icall
    1964:	fe 01       	movw	r30, r28
	// If the program-string variable is set, this string is to be found in program
	// memory rather than data memory
	if (pgm_string)
	{
		pgm_string = false;
		while (char ch = pgm_read_byte_near (string++))
    1966:	21 96       	adiw	r28, 0x01	; 1
    1968:	64 91       	lpm	r22, Z+
    196a:	66 23       	and	r22, r22
    196c:	99 f7       	brne	.-26     	; 0x1954 <_ZN16base_text_seriallsEPKc+0x24>
	{
		while (*string) putchar (*string++);
	}

	return (*this);
}
    196e:	c8 01       	movw	r24, r16
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	1f 91       	pop	r17
    1976:	0f 91       	pop	r16
    1978:	08 95       	ret
	}
	// If the program-string variable is not set, the string is in RAM and printed
	// in the normal way
	else
	{
		while (*string) putchar (*string++);
    197a:	21 96       	adiw	r28, 0x01	; 1
    197c:	d8 01       	movw	r26, r16
    197e:	ed 91       	ld	r30, X+
    1980:	fc 91       	ld	r31, X
    1982:	02 80       	ldd	r0, Z+2	; 0x02
    1984:	f3 81       	ldd	r31, Z+3	; 0x03
    1986:	e0 2d       	mov	r30, r0
    1988:	c8 01       	movw	r24, r16
    198a:	09 95       	icall
    198c:	68 81       	ld	r22, Y
    198e:	66 23       	and	r22, r22
    1990:	a1 f7       	brne	.-24     	; 0x197a <_ZN16base_text_seriallsEPKc+0x4a>
	}

	return (*this);
}
    1992:	c8 01       	movw	r24, r16
    1994:	df 91       	pop	r29
    1996:	cf 91       	pop	r28
    1998:	1f 91       	pop	r17
    199a:	0f 91       	pop	r16
    199c:	08 95       	ret

0000199e <_ZN16base_text_seriallsEb>:
/** This method writes a boolean value to the serial port as a character, either "T"
 *  or "F" depending on the value. 
 *  @param value The boolean value to be written
 */

base_text_serial& base_text_serial::operator<< (bool value)
    199e:	cf 93       	push	r28
    19a0:	df 93       	push	r29
    19a2:	ec 01       	movw	r28, r24
{
	if (value)
    19a4:	66 23       	and	r22, r22
    19a6:	59 f4       	brne	.+22     	; 0x19be <_ZN16base_text_seriallsEb+0x20>
		putchar ('T');
	else
		putchar ('F');
    19a8:	e8 81       	ld	r30, Y
    19aa:	f9 81       	ldd	r31, Y+1	; 0x01
    19ac:	02 80       	ldd	r0, Z+2	; 0x02
    19ae:	f3 81       	ldd	r31, Z+3	; 0x03
    19b0:	e0 2d       	mov	r30, r0
    19b2:	66 e4       	ldi	r22, 0x46	; 70
    19b4:	09 95       	icall

	return (*this);;   
}
    19b6:	ce 01       	movw	r24, r28
    19b8:	df 91       	pop	r29
    19ba:	cf 91       	pop	r28
    19bc:	08 95       	ret
 */

base_text_serial& base_text_serial::operator<< (bool value)
{
	if (value)
		putchar ('T');
    19be:	e8 81       	ld	r30, Y
    19c0:	f9 81       	ldd	r31, Y+1	; 0x01
    19c2:	02 80       	ldd	r0, Z+2	; 0x02
    19c4:	f3 81       	ldd	r31, Z+3	; 0x03
    19c6:	e0 2d       	mov	r30, r0
    19c8:	64 e5       	ldi	r22, 0x54	; 84
    19ca:	09 95       	icall
	else
		putchar ('F');

	return (*this);;   
}
    19cc:	ce 01       	movw	r24, r28
    19ce:	df 91       	pop	r29
    19d0:	cf 91       	pop	r28
    19d2:	08 95       	ret

000019d4 <_Z12setprecisionh>:
 */

ser_manipulator setprecision (unsigned char digits)
{
	if (digits > 7) digits = 7;
	bts_glob_prec = digits;
    19d4:	88 30       	cpi	r24, 0x08	; 8
    19d6:	08 f0       	brcs	.+2      	; 0x19da <_Z12setprecisionh+0x6>
    19d8:	87 e0       	ldi	r24, 0x07	; 7
    19da:	80 93 2a 02 	sts	0x022A, r24

	return (manip_set_precision);
}
    19de:	89 e0       	ldi	r24, 0x09	; 9
    19e0:	08 95       	ret

000019e2 <_ZN16base_text_seriallsE15ser_manipulator>:
 *  with the name "endl" and the code "send_now" causes immediate transmission by
 *  devices which save stuff to be transmitted in buffers. 
 *  @param new_manip The serial manipulator which was given
 */

base_text_serial& base_text_serial::operator<< (ser_manipulator new_manip)
    19e2:	cf 93       	push	r28
    19e4:	df 93       	push	r29
    19e6:	ec 01       	movw	r28, r24
{
	switch (new_manip)
    19e8:	64 30       	cpi	r22, 0x04	; 4
    19ea:	09 f4       	brne	.+2      	; 0x19ee <_ZN16base_text_seriallsE15ser_manipulator+0xc>
    19ec:	41 c0       	rjmp	.+130    	; 0x1a70 <_ZN16base_text_seriallsE15ser_manipulator+0x8e>
    19ee:	65 30       	cpi	r22, 0x05	; 5
    19f0:	a0 f0       	brcs	.+40     	; 0x1a1a <_ZN16base_text_seriallsE15ser_manipulator+0x38>
    19f2:	67 30       	cpi	r22, 0x07	; 7
    19f4:	49 f1       	breq	.+82     	; 0x1a48 <_ZN16base_text_seriallsE15ser_manipulator+0x66>
    19f6:	68 30       	cpi	r22, 0x08	; 8
    19f8:	d8 f4       	brcc	.+54     	; 0x1a30 <_ZN16base_text_seriallsE15ser_manipulator+0x4e>
    19fa:	65 30       	cpi	r22, 0x05	; 5
    19fc:	19 f1       	breq	.+70     	; 0x1a44 <_ZN16base_text_seriallsE15ser_manipulator+0x62>
    19fe:	66 30       	cpi	r22, 0x06	; 6
    1a00:	41 f4       	brne	.+16     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (numeric):						// Print chars as numbers
			print_ascii = false;
			break;
		case (endl):						// Send an end-of-line
			puts (ENDL_STYLE);
    1a02:	e8 81       	ld	r30, Y
    1a04:	f9 81       	ldd	r31, Y+1	; 0x01
    1a06:	04 80       	ldd	r0, Z+4	; 0x04
    1a08:	f5 81       	ldd	r31, Z+5	; 0x05
    1a0a:	e0 2d       	mov	r30, r0
    1a0c:	61 e2       	ldi	r22, 0x21	; 33
    1a0e:	72 e0       	ldi	r23, 0x02	; 2
    1a10:	09 95       	icall
		case (_p_str):						// The next string is in program memory
			pgm_string = true;
	};

	return (*this);
}
    1a12:	ce 01       	movw	r24, r28
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	08 95       	ret
 *  @param new_manip The serial manipulator which was given
 */

base_text_serial& base_text_serial::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
    1a1a:	61 30       	cpi	r22, 0x01	; 1
    1a1c:	31 f1       	breq	.+76     	; 0x1a6a <_ZN16base_text_seriallsE15ser_manipulator+0x88>
    1a1e:	61 30       	cpi	r22, 0x01	; 1
    1a20:	70 f0       	brcs	.+28     	; 0x1a3e <_ZN16base_text_seriallsE15ser_manipulator+0x5c>
    1a22:	62 30       	cpi	r22, 0x02	; 2
    1a24:	c1 f0       	breq	.+48     	; 0x1a56 <_ZN16base_text_seriallsE15ser_manipulator+0x74>
    1a26:	63 30       	cpi	r22, 0x03	; 3
    1a28:	a1 f7       	brne	.-24     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (dec):							// Print integers in decimal
			base = 10;
			break;
		case (hex):							// Print integers in hexadecimal
			base = 16;
    1a2a:	80 e1       	ldi	r24, 0x10	; 16
    1a2c:	8a 83       	std	Y+2, r24	; 0x02
    1a2e:	f1 cf       	rjmp	.-30     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
 *  @param new_manip The serial manipulator which was given
 */

base_text_serial& base_text_serial::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
    1a30:	68 30       	cpi	r22, 0x08	; 8
    1a32:	a1 f0       	breq	.+40     	; 0x1a5c <_ZN16base_text_seriallsE15ser_manipulator+0x7a>
    1a34:	6a 30       	cpi	r22, 0x0A	; 10
    1a36:	69 f7       	brne	.-38     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (send_now):					// Send whatever's in the send buffer
			transmit_now ();
			break;
		case (_p_str):						// The next string is in program memory
			pgm_string = true;
    1a38:	81 e0       	ldi	r24, 0x01	; 1
    1a3a:	8c 83       	std	Y+4, r24	; 0x04
    1a3c:	ea cf       	rjmp	.-44     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
base_text_serial& base_text_serial::operator<< (ser_manipulator new_manip)
{
	switch (new_manip)
	{
		case (bin):							// Print integers in binary
			base = 2;
    1a3e:	82 e0       	ldi	r24, 0x02	; 2
    1a40:	8a 83       	std	Y+2, r24	; 0x02
    1a42:	e7 cf       	rjmp	.-50     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (ascii):						// Print chars as ASCII letters, etc.
			print_ascii = true;
			break;
		case (numeric):						// Print chars as numbers
			print_ascii = false;
    1a44:	1b 82       	std	Y+3, r1	; 0x03
    1a46:	e5 cf       	rjmp	.-54     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (endl):						// Send an end-of-line
			puts (ENDL_STYLE);
			break;
		case (clrscr):						// Send a clear-screen code
			clear_screen ();
    1a48:	e8 81       	ld	r30, Y
    1a4a:	f9 81       	ldd	r31, Y+1	; 0x01
    1a4c:	04 84       	ldd	r0, Z+12	; 0x0c
    1a4e:	f5 85       	ldd	r31, Z+13	; 0x0d
    1a50:	e0 2d       	mov	r30, r0
    1a52:	09 95       	icall
    1a54:	de cf       	rjmp	.-68     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (oct):							// Print integers in octal
			base = 8;
			break;
		case (dec):							// Print integers in decimal
			base = 10;
    1a56:	8a e0       	ldi	r24, 0x0A	; 10
    1a58:	8a 83       	std	Y+2, r24	; 0x02
    1a5a:	db cf       	rjmp	.-74     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (clrscr):						// Send a clear-screen code
			clear_screen ();
			break;
		case (send_now):					// Send whatever's in the send buffer
			transmit_now ();
    1a5c:	e8 81       	ld	r30, Y
    1a5e:	f9 81       	ldd	r31, Y+1	; 0x01
    1a60:	02 84       	ldd	r0, Z+10	; 0x0a
    1a62:	f3 85       	ldd	r31, Z+11	; 0x0b
    1a64:	e0 2d       	mov	r30, r0
    1a66:	09 95       	icall
    1a68:	d4 cf       	rjmp	.-88     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
	{
		case (bin):							// Print integers in binary
			base = 2;
			break;
		case (oct):							// Print integers in octal
			base = 8;
    1a6a:	88 e0       	ldi	r24, 0x08	; 8
    1a6c:	8a 83       	std	Y+2, r24	; 0x02
    1a6e:	d1 cf       	rjmp	.-94     	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>
			break;
		case (hex):							// Print integers in hexadecimal
			base = 16;
			break;
		case (ascii):						// Print chars as ASCII letters, etc.
			print_ascii = true;
    1a70:	81 e0       	ldi	r24, 0x01	; 1
    1a72:	8b 83       	std	Y+3, r24	; 0x03
    1a74:	ce cf       	rjmp	.-100    	; 0x1a12 <_ZN16base_text_seriallsE15ser_manipulator+0x30>

00001a76 <_ZN16base_text_seriallsEh>:
 *  8-bit unsigned number in that character. If the format control term 'ascii' was
 *  called prior to this printing, the character will be printed as an ASCII character.
 *  @param num The 8-bit number or character to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned char num)
    1a76:	af 92       	push	r10
    1a78:	bf 92       	push	r11
    1a7a:	cf 92       	push	r12
    1a7c:	df 92       	push	r13
    1a7e:	ef 92       	push	r14
    1a80:	ff 92       	push	r15
    1a82:	0f 93       	push	r16
    1a84:	1f 93       	push	r17
    1a86:	df 93       	push	r29
    1a88:	cf 93       	push	r28
    1a8a:	cd b7       	in	r28, 0x3d	; 61
    1a8c:	de b7       	in	r29, 0x3e	; 62
    1a8e:	29 97       	sbiw	r28, 0x09	; 9
    1a90:	0f b6       	in	r0, 0x3f	; 63
    1a92:	f8 94       	cli
    1a94:	de bf       	out	0x3e, r29	; 62
    1a96:	0f be       	out	0x3f, r0	; 63
    1a98:	cd bf       	out	0x3d, r28	; 61
    1a9a:	6c 01       	movw	r12, r24
    1a9c:	16 2f       	mov	r17, r22
{
	unsigned char temp_char;				// Temporary storage for a nibble

	if (print_ascii)
    1a9e:	dc 01       	movw	r26, r24
    1aa0:	13 96       	adiw	r26, 0x03	; 3
    1aa2:	8c 91       	ld	r24, X
    1aa4:	13 97       	sbiw	r26, 0x03	; 3
    1aa6:	88 23       	and	r24, r24
    1aa8:	09 f0       	breq	.+2      	; 0x1aac <_ZN16base_text_seriallsEh+0x36>
    1aaa:	5f c0       	rjmp	.+190    	; 0x1b6a <_ZN16base_text_seriallsEh+0xf4>
	{
		putchar (num);
	}
	else if (base == 2)
    1aac:	f6 01       	movw	r30, r12
    1aae:	42 81       	ldd	r20, Z+2	; 0x02
    1ab0:	42 30       	cpi	r20, 0x02	; 2
    1ab2:	89 f1       	breq	.+98     	; 0x1b16 <_ZN16base_text_seriallsEh+0xa0>
		{
			if (num & bmask) putchar ('1');
			else			 putchar ('0');
		}
	}
	else if (base == 16)
    1ab4:	40 31       	cpi	r20, 0x10	; 16
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <_ZN16base_text_seriallsEh+0x44>
    1ab8:	60 c0       	rjmp	.+192    	; 0x1b7a <_ZN16base_text_seriallsEh+0x104>
	{
		temp_char = (num >> 4) & 0x0F;
    1aba:	62 95       	swap	r22
    1abc:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1abe:	d6 01       	movw	r26, r12
    1ac0:	ed 91       	ld	r30, X+
    1ac2:	fc 91       	ld	r31, X
    1ac4:	02 80       	ldd	r0, Z+2	; 0x02
    1ac6:	f3 81       	ldd	r31, Z+3	; 0x03
    1ac8:	e0 2d       	mov	r30, r0
    1aca:	6a 30       	cpi	r22, 0x0A	; 10
    1acc:	08 f0       	brcs	.+2      	; 0x1ad0 <_ZN16base_text_seriallsEh+0x5a>
    1ace:	68 c0       	rjmp	.+208    	; 0x1ba0 <_ZN16base_text_seriallsEh+0x12a>
    1ad0:	60 5d       	subi	r22, 0xD0	; 208
    1ad2:	c6 01       	movw	r24, r12
    1ad4:	09 95       	icall
		temp_char = num & 0x0F;
    1ad6:	61 2f       	mov	r22, r17
    1ad8:	6f 70       	andi	r22, 0x0F	; 15
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1ada:	d6 01       	movw	r26, r12
    1adc:	ed 91       	ld	r30, X+
    1ade:	fc 91       	ld	r31, X
    1ae0:	02 80       	ldd	r0, Z+2	; 0x02
    1ae2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ae4:	e0 2d       	mov	r30, r0
    1ae6:	6a 30       	cpi	r22, 0x0A	; 10
    1ae8:	08 f4       	brcc	.+2      	; 0x1aec <_ZN16base_text_seriallsEh+0x76>
    1aea:	5c c0       	rjmp	.+184    	; 0x1ba4 <_ZN16base_text_seriallsEh+0x12e>
    1aec:	69 5c       	subi	r22, 0xC9	; 201
    1aee:	c6 01       	movw	r24, r12
    1af0:	09 95       	icall
		utoa ((unsigned int)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1af2:	c6 01       	movw	r24, r12
    1af4:	29 96       	adiw	r28, 0x09	; 9
    1af6:	0f b6       	in	r0, 0x3f	; 63
    1af8:	f8 94       	cli
    1afa:	de bf       	out	0x3e, r29	; 62
    1afc:	0f be       	out	0x3f, r0	; 63
    1afe:	cd bf       	out	0x3d, r28	; 61
    1b00:	cf 91       	pop	r28
    1b02:	df 91       	pop	r29
    1b04:	1f 91       	pop	r17
    1b06:	0f 91       	pop	r16
    1b08:	ff 90       	pop	r15
    1b0a:	ef 90       	pop	r14
    1b0c:	df 90       	pop	r13
    1b0e:	cf 90       	pop	r12
    1b10:	bf 90       	pop	r11
    1b12:	af 90       	pop	r10
    1b14:	08 95       	ret

	if (print_ascii)
	{
		putchar (num);
	}
	else if (base == 2)
    1b16:	a6 2e       	mov	r10, r22
    1b18:	bb 24       	eor	r11, r11
    1b1a:	80 e8       	ldi	r24, 0x80	; 128
    1b1c:	ee 24       	eor	r14, r14
    1b1e:	ff 24       	eor	r15, r15
    1b20:	13 c0       	rjmp	.+38     	; 0x1b48 <_ZN16base_text_seriallsEh+0xd2>
	{
		for (unsigned char bmask = 0x80; bmask != 0; bmask >>= 1)
		{
			if (num & bmask) putchar ('1');
    1b22:	d6 01       	movw	r26, r12
    1b24:	ed 91       	ld	r30, X+
    1b26:	fc 91       	ld	r31, X
    1b28:	02 80       	ldd	r0, Z+2	; 0x02
    1b2a:	f3 81       	ldd	r31, Z+3	; 0x03
    1b2c:	e0 2d       	mov	r30, r0
    1b2e:	c6 01       	movw	r24, r12
    1b30:	61 e3       	ldi	r22, 0x31	; 49
    1b32:	09 95       	icall
	{
		putchar (num);
	}
	else if (base == 2)
	{
		for (unsigned char bmask = 0x80; bmask != 0; bmask >>= 1)
    1b34:	15 95       	asr	r17
    1b36:	07 95       	ror	r16
    1b38:	80 2f       	mov	r24, r16
    1b3a:	08 94       	sec
    1b3c:	e1 1c       	adc	r14, r1
    1b3e:	f1 1c       	adc	r15, r1
    1b40:	b8 e0       	ldi	r27, 0x08	; 8
    1b42:	eb 16       	cp	r14, r27
    1b44:	f1 04       	cpc	r15, r1
    1b46:	a9 f2       	breq	.-86     	; 0x1af2 <_ZN16base_text_seriallsEh+0x7c>
		{
			if (num & bmask) putchar ('1');
    1b48:	08 2f       	mov	r16, r24
    1b4a:	10 e0       	ldi	r17, 0x00	; 0
    1b4c:	c8 01       	movw	r24, r16
    1b4e:	8a 21       	and	r24, r10
    1b50:	9b 21       	and	r25, r11
    1b52:	89 2b       	or	r24, r25
    1b54:	31 f7       	brne	.-52     	; 0x1b22 <_ZN16base_text_seriallsEh+0xac>
			else			 putchar ('0');
    1b56:	d6 01       	movw	r26, r12
    1b58:	ed 91       	ld	r30, X+
    1b5a:	fc 91       	ld	r31, X
    1b5c:	02 80       	ldd	r0, Z+2	; 0x02
    1b5e:	f3 81       	ldd	r31, Z+3	; 0x03
    1b60:	e0 2d       	mov	r30, r0
    1b62:	c6 01       	movw	r24, r12
    1b64:	60 e3       	ldi	r22, 0x30	; 48
    1b66:	09 95       	icall
    1b68:	e5 cf       	rjmp	.-54     	; 0x1b34 <_ZN16base_text_seriallsEh+0xbe>
{
	unsigned char temp_char;				// Temporary storage for a nibble

	if (print_ascii)
	{
		putchar (num);
    1b6a:	ed 91       	ld	r30, X+
    1b6c:	fc 91       	ld	r31, X
    1b6e:	02 80       	ldd	r0, Z+2	; 0x02
    1b70:	f3 81       	ldd	r31, Z+3	; 0x03
    1b72:	e0 2d       	mov	r30, r0
    1b74:	c6 01       	movw	r24, r12
    1b76:	09 95       	icall
    1b78:	bc cf       	rjmp	.-136    	; 0x1af2 <_ZN16base_text_seriallsEh+0x7c>
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
	}
	else
	{
		char out_str[9];
		utoa ((unsigned int)num, out_str, base);
    1b7a:	86 2f       	mov	r24, r22
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	8e 01       	movw	r16, r28
    1b80:	0f 5f       	subi	r16, 0xFF	; 255
    1b82:	1f 4f       	sbci	r17, 0xFF	; 255
    1b84:	b8 01       	movw	r22, r16
    1b86:	50 e0       	ldi	r21, 0x00	; 0
    1b88:	0e 94 ba 13 	call	0x2774	; 0x2774 <utoa>
		puts (out_str);
    1b8c:	d6 01       	movw	r26, r12
    1b8e:	ed 91       	ld	r30, X+
    1b90:	fc 91       	ld	r31, X
    1b92:	04 80       	ldd	r0, Z+4	; 0x04
    1b94:	f5 81       	ldd	r31, Z+5	; 0x05
    1b96:	e0 2d       	mov	r30, r0
    1b98:	c6 01       	movw	r24, r12
    1b9a:	b8 01       	movw	r22, r16
    1b9c:	09 95       	icall
    1b9e:	a9 cf       	rjmp	.-174    	; 0x1af2 <_ZN16base_text_seriallsEh+0x7c>
		}
	}
	else if (base == 16)
	{
		temp_char = (num >> 4) & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1ba0:	69 5c       	subi	r22, 0xC9	; 201
    1ba2:	97 cf       	rjmp	.-210    	; 0x1ad2 <_ZN16base_text_seriallsEh+0x5c>
		temp_char = num & 0x0F;
		putchar ((temp_char > 9) ? temp_char + ('A' - 10) : temp_char + '0');
    1ba4:	60 5d       	subi	r22, 0xD0	; 208
    1ba6:	a3 cf       	rjmp	.-186    	; 0x1aee <_ZN16base_text_seriallsEh+0x78>

00001ba8 <_ZN16base_text_seriallsEy>:
 *  text string.  It only writes such numbers in unsigned hexadecimal format. The
 *  number is written by breaking it into two unsigned longs, writing them in order.
 *  @param num The 64-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned long long num)
    1ba8:	ef 92       	push	r14
    1baa:	ff 92       	push	r15
    1bac:	0f 93       	push	r16
    1bae:	1f 93       	push	r17
    1bb0:	df 93       	push	r29
    1bb2:	cf 93       	push	r28
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
    1bb8:	28 97       	sbiw	r28, 0x08	; 8
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	cd bf       	out	0x3d, r28	; 61
    1bc4:	f8 2e       	mov	r15, r24
    1bc6:	e9 2e       	mov	r14, r25
{
	union {
		unsigned long long whole;
		unsigned char bits[8];
	} parts;
	parts.whole = num;
    1bc8:	09 83       	std	Y+1, r16	; 0x01
    1bca:	1a 83       	std	Y+2, r17	; 0x02
    1bcc:	2b 83       	std	Y+3, r18	; 0x03
    1bce:	3c 83       	std	Y+4, r19	; 0x04
    1bd0:	4d 83       	std	Y+5, r20	; 0x05
    1bd2:	5e 83       	std	Y+6, r21	; 0x06
    1bd4:	6f 83       	std	Y+7, r22	; 0x07
    1bd6:	78 87       	std	Y+8, r23	; 0x08
	*this << parts.bits[7] << parts.bits[6] << parts.bits[5] << parts.bits[4]
		  << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    1bd8:	67 2f       	mov	r22, r23
    1bda:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1bde:	6f 81       	ldd	r22, Y+7	; 0x07
    1be0:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1be4:	6e 81       	ldd	r22, Y+6	; 0x06
    1be6:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1bea:	6d 81       	ldd	r22, Y+5	; 0x05
    1bec:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1bf0:	6c 81       	ldd	r22, Y+4	; 0x04
    1bf2:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1bf6:	6b 81       	ldd	r22, Y+3	; 0x03
    1bf8:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1bfc:	6a 81       	ldd	r22, Y+2	; 0x02
    1bfe:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1c02:	69 81       	ldd	r22, Y+1	; 0x01
    1c04:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>

	return (*this);
}
    1c08:	8f 2d       	mov	r24, r15
    1c0a:	9e 2d       	mov	r25, r14
    1c0c:	28 96       	adiw	r28, 0x08	; 8
    1c0e:	0f b6       	in	r0, 0x3f	; 63
    1c10:	f8 94       	cli
    1c12:	de bf       	out	0x3e, r29	; 62
    1c14:	0f be       	out	0x3f, r0	; 63
    1c16:	cd bf       	out	0x3d, r28	; 61
    1c18:	cf 91       	pop	r28
    1c1a:	df 91       	pop	r29
    1c1c:	1f 91       	pop	r17
    1c1e:	0f 91       	pop	r16
    1c20:	ff 90       	pop	r15
    1c22:	ef 90       	pop	r14
    1c24:	08 95       	ret

00001c26 <_ZN16base_text_seriallsEm>:
/** This method writes an unsigned long integer to the serial port as a text string 
 *  showing the 32-bit unsigned number in that long integer. 
 *  @param num The 32-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned long num)
    1c26:	df 92       	push	r13
    1c28:	ef 92       	push	r14
    1c2a:	ff 92       	push	r15
    1c2c:	0f 93       	push	r16
    1c2e:	1f 93       	push	r17
    1c30:	df 93       	push	r29
    1c32:	cf 93       	push	r28
    1c34:	cd b7       	in	r28, 0x3d	; 61
    1c36:	de b7       	in	r29, 0x3e	; 62
    1c38:	a1 97       	sbiw	r28, 0x21	; 33
    1c3a:	0f b6       	in	r0, 0x3f	; 63
    1c3c:	f8 94       	cli
    1c3e:	de bf       	out	0x3e, r29	; 62
    1c40:	0f be       	out	0x3f, r0	; 63
    1c42:	cd bf       	out	0x3d, r28	; 61
    1c44:	7c 01       	movw	r14, r24
    1c46:	d4 2e       	mov	r13, r20
    1c48:	15 2f       	mov	r17, r21
    1c4a:	06 2f       	mov	r16, r22
    1c4c:	37 2f       	mov	r19, r23
{
	if (base == 16 || base == 8 || base == 2)
    1c4e:	dc 01       	movw	r26, r24
    1c50:	12 96       	adiw	r26, 0x02	; 2
    1c52:	2c 91       	ld	r18, X
    1c54:	20 31       	cpi	r18, 0x10	; 16
    1c56:	c9 f0       	breq	.+50     	; 0x1c8a <_ZN16base_text_seriallsEm+0x64>
    1c58:	28 30       	cpi	r18, 0x08	; 8
    1c5a:	b9 f0       	breq	.+46     	; 0x1c8a <_ZN16base_text_seriallsEm+0x64>
    1c5c:	22 30       	cpi	r18, 0x02	; 2
    1c5e:	a9 f0       	breq	.+42     	; 0x1c8a <_ZN16base_text_seriallsEm+0x64>
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[33];
		ultoa ((long)num, out_str, base);
    1c60:	64 2f       	mov	r22, r20
    1c62:	75 2f       	mov	r23, r21
    1c64:	80 2f       	mov	r24, r16
    1c66:	93 2f       	mov	r25, r19
    1c68:	8e 01       	movw	r16, r28
    1c6a:	0f 5f       	subi	r16, 0xFF	; 255
    1c6c:	1f 4f       	sbci	r17, 0xFF	; 255
    1c6e:	a8 01       	movw	r20, r16
    1c70:	30 e0       	ldi	r19, 0x00	; 0
    1c72:	0e 94 95 13 	call	0x272a	; 0x272a <ultoa>
		puts (out_str);
    1c76:	d7 01       	movw	r26, r14
    1c78:	ed 91       	ld	r30, X+
    1c7a:	fc 91       	ld	r31, X
    1c7c:	04 80       	ldd	r0, Z+4	; 0x04
    1c7e:	f5 81       	ldd	r31, Z+5	; 0x05
    1c80:	e0 2d       	mov	r30, r0
    1c82:	c7 01       	movw	r24, r14
    1c84:	b8 01       	movw	r22, r16
    1c86:	09 95       	icall
    1c88:	0d c0       	rjmp	.+26     	; 0x1ca4 <_ZN16base_text_seriallsEm+0x7e>
		union {
			unsigned long whole;
			unsigned char bits[4];
		} parts;
		parts.whole = num;
		*this << parts.bits[3] << parts.bits[2] << parts.bits[1] << parts.bits[0];
    1c8a:	c7 01       	movw	r24, r14
    1c8c:	63 2f       	mov	r22, r19
    1c8e:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1c92:	60 2f       	mov	r22, r16
    1c94:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1c98:	61 2f       	mov	r22, r17
    1c9a:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1c9e:	6d 2d       	mov	r22, r13
    1ca0:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
		ultoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1ca4:	c7 01       	movw	r24, r14
    1ca6:	a1 96       	adiw	r28, 0x21	; 33
    1ca8:	0f b6       	in	r0, 0x3f	; 63
    1caa:	f8 94       	cli
    1cac:	de bf       	out	0x3e, r29	; 62
    1cae:	0f be       	out	0x3f, r0	; 63
    1cb0:	cd bf       	out	0x3d, r28	; 61
    1cb2:	cf 91       	pop	r28
    1cb4:	df 91       	pop	r29
    1cb6:	1f 91       	pop	r17
    1cb8:	0f 91       	pop	r16
    1cba:	ff 90       	pop	r15
    1cbc:	ef 90       	pop	r14
    1cbe:	df 90       	pop	r13
    1cc0:	08 95       	ret

00001cc2 <_ZN16base_text_seriallsEl>:
/** This method writes a long integer to the serial port as a text string showing the 
 *  32-bit signed number in that long integer. 
 *  @param num The 32-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (long num)
    1cc2:	ef 92       	push	r14
    1cc4:	ff 92       	push	r15
    1cc6:	0f 93       	push	r16
    1cc8:	1f 93       	push	r17
    1cca:	df 93       	push	r29
    1ccc:	cf 93       	push	r28
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	a2 97       	sbiw	r28, 0x22	; 34
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	de bf       	out	0x3e, r29	; 62
    1cda:	0f be       	out	0x3f, r0	; 63
    1cdc:	cd bf       	out	0x3d, r28	; 61
    1cde:	7c 01       	movw	r14, r24
{
	if (base != 10)
    1ce0:	dc 01       	movw	r26, r24
    1ce2:	12 96       	adiw	r26, 0x02	; 2
    1ce4:	8c 91       	ld	r24, X
    1ce6:	8a 30       	cpi	r24, 0x0A	; 10
    1ce8:	89 f0       	breq	.+34     	; 0x1d0c <_ZN16base_text_seriallsEl+0x4a>
	{
		*this << (unsigned long)num;
    1cea:	c7 01       	movw	r24, r14
    1cec:	0e 94 13 0e 	call	0x1c26	; 0x1c26 <_ZN16base_text_seriallsEm>
		ltoa ((long)num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1cf0:	c7 01       	movw	r24, r14
    1cf2:	a2 96       	adiw	r28, 0x22	; 34
    1cf4:	0f b6       	in	r0, 0x3f	; 63
    1cf6:	f8 94       	cli
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	cd bf       	out	0x3d, r28	; 61
    1cfe:	cf 91       	pop	r28
    1d00:	df 91       	pop	r29
    1d02:	1f 91       	pop	r17
    1d04:	0f 91       	pop	r16
    1d06:	ff 90       	pop	r15
    1d08:	ef 90       	pop	r14
    1d0a:	08 95       	ret
		*this << (unsigned long)num;
	}
	else
	{
		char out_str[34];
		ltoa ((long)num, out_str, base);
    1d0c:	cb 01       	movw	r24, r22
    1d0e:	ba 01       	movw	r22, r20
    1d10:	8e 01       	movw	r16, r28
    1d12:	0f 5f       	subi	r16, 0xFF	; 255
    1d14:	1f 4f       	sbci	r17, 0xFF	; 255
    1d16:	a8 01       	movw	r20, r16
    1d18:	2a e0       	ldi	r18, 0x0A	; 10
    1d1a:	30 e0       	ldi	r19, 0x00	; 0
    1d1c:	0e 94 61 13 	call	0x26c2	; 0x26c2 <ltoa>
		puts (out_str);
    1d20:	d7 01       	movw	r26, r14
    1d22:	ed 91       	ld	r30, X+
    1d24:	fc 91       	ld	r31, X
    1d26:	04 80       	ldd	r0, Z+4	; 0x04
    1d28:	f5 81       	ldd	r31, Z+5	; 0x05
    1d2a:	e0 2d       	mov	r30, r0
    1d2c:	c7 01       	movw	r24, r14
    1d2e:	b8 01       	movw	r22, r16
    1d30:	09 95       	icall
    1d32:	de cf       	rjmp	.-68     	; 0x1cf0 <_ZN16base_text_seriallsEl+0x2e>

00001d34 <_ZN16base_text_seriallsEc>:
 *  used to put the port in ascii text mode, in which case the character is printed
 *  directly. 
 *  @param num The 8-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (char num)
    1d34:	ef 92       	push	r14
    1d36:	ff 92       	push	r15
    1d38:	0f 93       	push	r16
    1d3a:	1f 93       	push	r17
    1d3c:	df 93       	push	r29
    1d3e:	cf 93       	push	r28
    1d40:	00 d0       	rcall	.+0      	; 0x1d42 <_ZN16base_text_seriallsEc+0xe>
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <_ZN16base_text_seriallsEc+0x10>
    1d44:	0f 92       	push	r0
    1d46:	cd b7       	in	r28, 0x3d	; 61
    1d48:	de b7       	in	r29, 0x3e	; 62
    1d4a:	7c 01       	movw	r14, r24
{
	char out_str[5];

	if (print_ascii) 
    1d4c:	dc 01       	movw	r26, r24
    1d4e:	13 96       	adiw	r26, 0x03	; 3
    1d50:	8c 91       	ld	r24, X
    1d52:	13 97       	sbiw	r26, 0x03	; 3
    1d54:	88 23       	and	r24, r24
    1d56:	a1 f4       	brne	.+40     	; 0x1d80 <_ZN16base_text_seriallsEc+0x4c>
		putchar (num);
	else
	{
		if (base == 10)
    1d58:	f7 01       	movw	r30, r14
    1d5a:	82 81       	ldd	r24, Z+2	; 0x02
    1d5c:	8a 30       	cpi	r24, 0x0A	; 10
    1d5e:	c1 f0       	breq	.+48     	; 0x1d90 <_ZN16base_text_seriallsEc+0x5c>
		{
			itoa ((int)num, out_str, 10);
			puts (out_str);
		}
		else
			*this << (unsigned char)num;
    1d60:	c7 01       	movw	r24, r14
    1d62:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
	}

	return (*this);
}
    1d66:	c7 01       	movw	r24, r14
    1d68:	0f 90       	pop	r0
    1d6a:	0f 90       	pop	r0
    1d6c:	0f 90       	pop	r0
    1d6e:	0f 90       	pop	r0
    1d70:	0f 90       	pop	r0
    1d72:	cf 91       	pop	r28
    1d74:	df 91       	pop	r29
    1d76:	1f 91       	pop	r17
    1d78:	0f 91       	pop	r16
    1d7a:	ff 90       	pop	r15
    1d7c:	ef 90       	pop	r14
    1d7e:	08 95       	ret
base_text_serial& base_text_serial::operator<< (char num)
{
	char out_str[5];

	if (print_ascii) 
		putchar (num);
    1d80:	ed 91       	ld	r30, X+
    1d82:	fc 91       	ld	r31, X
    1d84:	02 80       	ldd	r0, Z+2	; 0x02
    1d86:	f3 81       	ldd	r31, Z+3	; 0x03
    1d88:	e0 2d       	mov	r30, r0
    1d8a:	c7 01       	movw	r24, r14
    1d8c:	09 95       	icall
    1d8e:	eb cf       	rjmp	.-42     	; 0x1d66 <_ZN16base_text_seriallsEc+0x32>
	else
	{
		if (base == 10)
		{
			itoa ((int)num, out_str, 10);
    1d90:	86 2f       	mov	r24, r22
    1d92:	99 27       	eor	r25, r25
    1d94:	87 fd       	sbrc	r24, 7
    1d96:	90 95       	com	r25
    1d98:	8e 01       	movw	r16, r28
    1d9a:	0f 5f       	subi	r16, 0xFF	; 255
    1d9c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d9e:	b8 01       	movw	r22, r16
    1da0:	4a e0       	ldi	r20, 0x0A	; 10
    1da2:	50 e0       	ldi	r21, 0x00	; 0
    1da4:	0e 94 40 13 	call	0x2680	; 0x2680 <itoa>
			puts (out_str);
    1da8:	d7 01       	movw	r26, r14
    1daa:	ed 91       	ld	r30, X+
    1dac:	fc 91       	ld	r31, X
    1dae:	04 80       	ldd	r0, Z+4	; 0x04
    1db0:	f5 81       	ldd	r31, Z+5	; 0x05
    1db2:	e0 2d       	mov	r30, r0
    1db4:	c7 01       	movw	r24, r14
    1db6:	b8 01       	movw	r22, r16
    1db8:	09 95       	icall
    1dba:	d5 cf       	rjmp	.-86     	; 0x1d66 <_ZN16base_text_seriallsEc+0x32>

00001dbc <_ZN16base_text_seriallsEj>:
/** This method writes an integer to the serial port as a text string showing the 
 *  16-bit unsigned number in that integer. 
 *  @param num The 16-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (unsigned int num)
    1dbc:	cf 92       	push	r12
    1dbe:	df 92       	push	r13
    1dc0:	ef 92       	push	r14
    1dc2:	ff 92       	push	r15
    1dc4:	0f 93       	push	r16
    1dc6:	1f 93       	push	r17
    1dc8:	df 93       	push	r29
    1dca:	cf 93       	push	r28
    1dcc:	cd b7       	in	r28, 0x3d	; 61
    1dce:	de b7       	in	r29, 0x3e	; 62
    1dd0:	61 97       	sbiw	r28, 0x11	; 17
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	de bf       	out	0x3e, r29	; 62
    1dd8:	0f be       	out	0x3f, r0	; 63
    1dda:	cd bf       	out	0x3d, r28	; 61
    1ddc:	6c 01       	movw	r12, r24
{
	if (base == 16 || base == 8 || base == 2)
    1dde:	dc 01       	movw	r26, r24
    1de0:	12 96       	adiw	r26, 0x02	; 2
    1de2:	4c 91       	ld	r20, X
    1de4:	40 31       	cpi	r20, 0x10	; 16
    1de6:	b1 f0       	breq	.+44     	; 0x1e14 <_ZN16base_text_seriallsEj+0x58>
    1de8:	48 30       	cpi	r20, 0x08	; 8
    1dea:	a1 f0       	breq	.+40     	; 0x1e14 <_ZN16base_text_seriallsEj+0x58>
    1dec:	42 30       	cpi	r20, 0x02	; 2
    1dee:	91 f0       	breq	.+36     	; 0x1e14 <_ZN16base_text_seriallsEj+0x58>
		*this << parts.bits[1] << parts.bits[0];
	}
	else
	{
		char out_str[17];
		utoa (num, out_str, base);
    1df0:	cb 01       	movw	r24, r22
    1df2:	8e 01       	movw	r16, r28
    1df4:	0f 5f       	subi	r16, 0xFF	; 255
    1df6:	1f 4f       	sbci	r17, 0xFF	; 255
    1df8:	b8 01       	movw	r22, r16
    1dfa:	50 e0       	ldi	r21, 0x00	; 0
    1dfc:	0e 94 ba 13 	call	0x2774	; 0x2774 <utoa>
		puts (out_str);
    1e00:	d6 01       	movw	r26, r12
    1e02:	ed 91       	ld	r30, X+
    1e04:	fc 91       	ld	r31, X
    1e06:	04 80       	ldd	r0, Z+4	; 0x04
    1e08:	f5 81       	ldd	r31, Z+5	; 0x05
    1e0a:	e0 2d       	mov	r30, r0
    1e0c:	c6 01       	movw	r24, r12
    1e0e:	b8 01       	movw	r22, r16
    1e10:	09 95       	icall
    1e12:	08 c0       	rjmp	.+16     	; 0x1e24 <_ZN16base_text_seriallsEj+0x68>
	{
		union {
			unsigned long whole;
			unsigned char bits[2];
		} parts;
		parts.whole = num;
    1e14:	7b 01       	movw	r14, r22
		*this << parts.bits[1] << parts.bits[0];
    1e16:	c6 01       	movw	r24, r12
    1e18:	6f 2d       	mov	r22, r15
    1e1a:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
    1e1e:	6e 2d       	mov	r22, r14
    1e20:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <_ZN16base_text_seriallsEh>
		utoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1e24:	c6 01       	movw	r24, r12
    1e26:	61 96       	adiw	r28, 0x11	; 17
    1e28:	0f b6       	in	r0, 0x3f	; 63
    1e2a:	f8 94       	cli
    1e2c:	de bf       	out	0x3e, r29	; 62
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	cd bf       	out	0x3d, r28	; 61
    1e32:	cf 91       	pop	r28
    1e34:	df 91       	pop	r29
    1e36:	1f 91       	pop	r17
    1e38:	0f 91       	pop	r16
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	df 90       	pop	r13
    1e40:	cf 90       	pop	r12
    1e42:	08 95       	ret

00001e44 <_ZN16base_text_seriallsEi>:
/** This method writes an integer to the serial port as a text string showing the 
 *  16-bit signed number in that integer. 
 *  @param num The 16-bit number to be sent out
 */

base_text_serial& base_text_serial::operator<< (int num)
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	df 93       	push	r29
    1e4e:	cf 93       	push	r28
    1e50:	cd b7       	in	r28, 0x3d	; 61
    1e52:	de b7       	in	r29, 0x3e	; 62
    1e54:	61 97       	sbiw	r28, 0x11	; 17
    1e56:	0f b6       	in	r0, 0x3f	; 63
    1e58:	f8 94       	cli
    1e5a:	de bf       	out	0x3e, r29	; 62
    1e5c:	0f be       	out	0x3f, r0	; 63
    1e5e:	cd bf       	out	0x3d, r28	; 61
    1e60:	7c 01       	movw	r14, r24
{
	if (base != 10)
    1e62:	dc 01       	movw	r26, r24
    1e64:	12 96       	adiw	r26, 0x02	; 2
    1e66:	8c 91       	ld	r24, X
    1e68:	8a 30       	cpi	r24, 0x0A	; 10
    1e6a:	89 f0       	breq	.+34     	; 0x1e8e <_ZN16base_text_seriallsEi+0x4a>
	{
		*this << (unsigned int)num;
    1e6c:	c7 01       	movw	r24, r14
    1e6e:	0e 94 de 0e 	call	0x1dbc	; 0x1dbc <_ZN16base_text_seriallsEj>
		itoa (num, out_str, base);
		puts (out_str);
	}

	return (*this);
}
    1e72:	c7 01       	movw	r24, r14
    1e74:	61 96       	adiw	r28, 0x11	; 17
    1e76:	0f b6       	in	r0, 0x3f	; 63
    1e78:	f8 94       	cli
    1e7a:	de bf       	out	0x3e, r29	; 62
    1e7c:	0f be       	out	0x3f, r0	; 63
    1e7e:	cd bf       	out	0x3d, r28	; 61
    1e80:	cf 91       	pop	r28
    1e82:	df 91       	pop	r29
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	ff 90       	pop	r15
    1e8a:	ef 90       	pop	r14
    1e8c:	08 95       	ret
	}
	else
	{
		char out_str[17];

		itoa (num, out_str, base);
    1e8e:	cb 01       	movw	r24, r22
    1e90:	8e 01       	movw	r16, r28
    1e92:	0f 5f       	subi	r16, 0xFF	; 255
    1e94:	1f 4f       	sbci	r17, 0xFF	; 255
    1e96:	b8 01       	movw	r22, r16
    1e98:	4a e0       	ldi	r20, 0x0A	; 10
    1e9a:	50 e0       	ldi	r21, 0x00	; 0
    1e9c:	0e 94 40 13 	call	0x2680	; 0x2680 <itoa>
		puts (out_str);
    1ea0:	d7 01       	movw	r26, r14
    1ea2:	ed 91       	ld	r30, X+
    1ea4:	fc 91       	ld	r31, X
    1ea6:	04 80       	ldd	r0, Z+4	; 0x04
    1ea8:	f5 81       	ldd	r31, Z+5	; 0x05
    1eaa:	e0 2d       	mov	r30, r0
    1eac:	c7 01       	movw	r24, r14
    1eae:	b8 01       	movw	r22, r16
    1eb0:	09 95       	icall
    1eb2:	df cf       	rjmp	.-66     	; 0x1e72 <_ZN16base_text_seriallsEi+0x2e>

00001eb4 <_ZN16base_text_seriallsEd>:
 *  __ftoa_engine, which is hiding in the AVR libraries, used by the Xprintf() 
 *  functions when they need to convert a double into text. 
 *  @param num The double-precision floating point number to be sent out
 */

base_text_serial& base_text_serial::operator<< (double num)
    1eb4:	af 92       	push	r10
    1eb6:	bf 92       	push	r11
    1eb8:	df 92       	push	r13
    1eba:	ef 92       	push	r14
    1ebc:	ff 92       	push	r15
    1ebe:	0f 93       	push	r16
    1ec0:	1f 93       	push	r17
    1ec2:	df 93       	push	r29
    1ec4:	cf 93       	push	r28
    1ec6:	cd b7       	in	r28, 0x3d	; 61
    1ec8:	de b7       	in	r29, 0x3e	; 62
    1eca:	64 97       	sbiw	r28, 0x14	; 20
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	de bf       	out	0x3e, r29	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	cd bf       	out	0x3d, r28	; 61
    1ed6:	7c 01       	movw	r14, r24
{
	char digits = precision;
    1ed8:	dc 01       	movw	r26, r24
    1eda:	15 96       	adiw	r26, 0x05	; 5
    1edc:	dc 90       	ld	r13, X
	char buf[20];
	char* p_buf = buf;

	int exponent = __ftoa_engine (num, buf, digits, 16);
    1ede:	cb 01       	movw	r24, r22
    1ee0:	ba 01       	movw	r22, r20
    1ee2:	ae 01       	movw	r20, r28
    1ee4:	4f 5f       	subi	r20, 0xFF	; 255
    1ee6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ee8:	2d 2d       	mov	r18, r13
    1eea:	00 e1       	ldi	r16, 0x10	; 16
    1eec:	0e 94 61 12 	call	0x24c2	; 0x24c2 <__ftoa_engine>
    1ef0:	5c 01       	movw	r10, r24
	uint8_t vtype = *p_buf++;
	if (vtype & FTOA_NAN)
    1ef2:	89 81       	ldd	r24, Y+1	; 0x01
    1ef4:	83 fd       	sbrc	r24, 3
    1ef6:	5e c0       	rjmp	.+188    	; 0x1fb4 <_ZN16base_text_seriallsEd+0x100>
		*this << "  NaN";
		return (*this);
	}

	// Display the sign if it's negative
	if (vtype & FTOA_MINUS)
    1ef8:	80 fd       	sbrc	r24, 0
    1efa:	52 c0       	rjmp	.+164    	; 0x1fa0 <_ZN16base_text_seriallsEd+0xec>
		putchar ('-');

	// Show the mantissa
	putchar (*p_buf++);
    1efc:	d7 01       	movw	r26, r14
    1efe:	ed 91       	ld	r30, X+
    1f00:	fc 91       	ld	r31, X
    1f02:	02 80       	ldd	r0, Z+2	; 0x02
    1f04:	f3 81       	ldd	r31, Z+3	; 0x03
    1f06:	e0 2d       	mov	r30, r0
    1f08:	c7 01       	movw	r24, r14
    1f0a:	6a 81       	ldd	r22, Y+2	; 0x02
    1f0c:	09 95       	icall
	if (digits)
    1f0e:	dd 20       	and	r13, r13
    1f10:	e9 f5       	brne	.+122    	; 0x1f8c <_ZN16base_text_seriallsEd+0xd8>
		putchar ('.');
    1f12:	6b 81       	ldd	r22, Y+3	; 0x03
    1f14:	8e 01       	movw	r16, r28
    1f16:	0d 5f       	subi	r16, 0xFD	; 253
    1f18:	1f 4f       	sbci	r17, 0xFF	; 255
	do
		putchar (*p_buf++);
    1f1a:	d7 01       	movw	r26, r14
    1f1c:	ed 91       	ld	r30, X+
    1f1e:	fc 91       	ld	r31, X
    1f20:	02 80       	ldd	r0, Z+2	; 0x02
    1f22:	f3 81       	ldd	r31, Z+3	; 0x03
    1f24:	e0 2d       	mov	r30, r0
    1f26:	c7 01       	movw	r24, r14
    1f28:	09 95       	icall

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
	do
    1f2a:	da 94       	dec	r13
    1f2c:	31 f0       	breq	.+12     	; 0x1f3a <_ZN16base_text_seriallsEd+0x86>
		putchar (*p_buf++);
    1f2e:	0f 5f       	subi	r16, 0xFF	; 255
    1f30:	1f 4f       	sbci	r17, 0xFF	; 255

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
	do
    1f32:	f8 01       	movw	r30, r16
    1f34:	60 81       	ld	r22, Z
    1f36:	66 23       	and	r22, r22
    1f38:	81 f7       	brne	.-32     	; 0x1f1a <_ZN16base_text_seriallsEd+0x66>
		putchar (*p_buf++);
	while (--digits && *p_buf);

	// Now display the exponent
	putchar ('e');
    1f3a:	d7 01       	movw	r26, r14
    1f3c:	ed 91       	ld	r30, X+
    1f3e:	fc 91       	ld	r31, X
    1f40:	02 80       	ldd	r0, Z+2	; 0x02
    1f42:	f3 81       	ldd	r31, Z+3	; 0x03
    1f44:	e0 2d       	mov	r30, r0
    1f46:	c7 01       	movw	r24, r14
    1f48:	65 e6       	ldi	r22, 0x65	; 101
    1f4a:	09 95       	icall
	if (exponent > 0)
    1f4c:	1a 14       	cp	r1, r10
    1f4e:	1b 04       	cpc	r1, r11
    1f50:	4c f4       	brge	.+18     	; 0x1f64 <_ZN16base_text_seriallsEd+0xb0>
		putchar ('+');
    1f52:	d7 01       	movw	r26, r14
    1f54:	ed 91       	ld	r30, X+
    1f56:	fc 91       	ld	r31, X
    1f58:	02 80       	ldd	r0, Z+2	; 0x02
    1f5a:	f3 81       	ldd	r31, Z+3	; 0x03
    1f5c:	e0 2d       	mov	r30, r0
    1f5e:	c7 01       	movw	r24, r14
    1f60:	6b e2       	ldi	r22, 0x2B	; 43
    1f62:	09 95       	icall
	*this << exponent;
    1f64:	c7 01       	movw	r24, r14
    1f66:	b5 01       	movw	r22, r10
    1f68:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <_ZN16base_text_seriallsEi>
}
    1f6c:	64 96       	adiw	r28, 0x14	; 20
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	de bf       	out	0x3e, r29	; 62
    1f74:	0f be       	out	0x3f, r0	; 63
    1f76:	cd bf       	out	0x3d, r28	; 61
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	1f 91       	pop	r17
    1f7e:	0f 91       	pop	r16
    1f80:	ff 90       	pop	r15
    1f82:	ef 90       	pop	r14
    1f84:	df 90       	pop	r13
    1f86:	bf 90       	pop	r11
    1f88:	af 90       	pop	r10
    1f8a:	08 95       	ret
		putchar ('-');

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
    1f8c:	d7 01       	movw	r26, r14
    1f8e:	ed 91       	ld	r30, X+
    1f90:	fc 91       	ld	r31, X
    1f92:	02 80       	ldd	r0, Z+2	; 0x02
    1f94:	f3 81       	ldd	r31, Z+3	; 0x03
    1f96:	e0 2d       	mov	r30, r0
    1f98:	c7 01       	movw	r24, r14
    1f9a:	6e e2       	ldi	r22, 0x2E	; 46
    1f9c:	09 95       	icall
    1f9e:	b9 cf       	rjmp	.-142    	; 0x1f12 <_ZN16base_text_seriallsEd+0x5e>
		return (*this);
	}

	// Display the sign if it's negative
	if (vtype & FTOA_MINUS)
		putchar ('-');
    1fa0:	d7 01       	movw	r26, r14
    1fa2:	ed 91       	ld	r30, X+
    1fa4:	fc 91       	ld	r31, X
    1fa6:	02 80       	ldd	r0, Z+2	; 0x02
    1fa8:	f3 81       	ldd	r31, Z+3	; 0x03
    1faa:	e0 2d       	mov	r30, r0
    1fac:	c7 01       	movw	r24, r14
    1fae:	6d e2       	ldi	r22, 0x2D	; 45
    1fb0:	09 95       	icall
    1fb2:	a4 cf       	rjmp	.-184    	; 0x1efc <_ZN16base_text_seriallsEd+0x48>

	int exponent = __ftoa_engine (num, buf, digits, 16);
	uint8_t vtype = *p_buf++;
	if (vtype & FTOA_NAN)
	{
		*this << "  NaN";
    1fb4:	c7 01       	movw	r24, r14
    1fb6:	64 e2       	ldi	r22, 0x24	; 36
    1fb8:	72 e0       	ldi	r23, 0x02	; 2
    1fba:	0e 94 98 0c 	call	0x1930	; 0x1930 <_ZN16base_text_seriallsEPKc>
    1fbe:	c7 01       	movw	r24, r14
    1fc0:	d5 cf       	rjmp	.-86     	; 0x1f6c <_ZN16base_text_seriallsEd+0xb8>

00001fc2 <_ZN16base_text_seriallsEf>:
 *  __ftoa_engine, which is hiding in the AVR libraries, used by the Xprintf() 
 *  functions when they need to convert a float into text. 
 *  @param num The floating point number to be sent out
 */

base_text_serial& base_text_serial::operator<< (float num)
    1fc2:	af 92       	push	r10
    1fc4:	bf 92       	push	r11
    1fc6:	df 92       	push	r13
    1fc8:	ef 92       	push	r14
    1fca:	ff 92       	push	r15
    1fcc:	0f 93       	push	r16
    1fce:	1f 93       	push	r17
    1fd0:	df 93       	push	r29
    1fd2:	cf 93       	push	r28
    1fd4:	cd b7       	in	r28, 0x3d	; 61
    1fd6:	de b7       	in	r29, 0x3e	; 62
    1fd8:	64 97       	sbiw	r28, 0x14	; 20
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	de bf       	out	0x3e, r29	; 62
    1fe0:	0f be       	out	0x3f, r0	; 63
    1fe2:	cd bf       	out	0x3d, r28	; 61
    1fe4:	7c 01       	movw	r14, r24
{
	char digits = precision;
    1fe6:	dc 01       	movw	r26, r24
    1fe8:	15 96       	adiw	r26, 0x05	; 5
    1fea:	1c 91       	ld	r17, X
	char buf[20];
	char* p_buf = buf;

	int exponent = __ftoa_engine ((double)num, buf, digits, 16);
    1fec:	cb 01       	movw	r24, r22
    1fee:	ba 01       	movw	r22, r20
    1ff0:	ae 01       	movw	r20, r28
    1ff2:	4f 5f       	subi	r20, 0xFF	; 255
    1ff4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ff6:	21 2f       	mov	r18, r17
    1ff8:	00 e1       	ldi	r16, 0x10	; 16
    1ffa:	0e 94 61 12 	call	0x24c2	; 0x24c2 <__ftoa_engine>
    1ffe:	5c 01       	movw	r10, r24
	uint8_t vtype = *p_buf++;
	if (vtype & FTOA_NAN)
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	83 fd       	sbrc	r24, 3
    2004:	67 c0       	rjmp	.+206    	; 0x20d4 <_ZN16base_text_seriallsEf+0x112>
		*this << "  NaN";
		return (*this);
	}

	// Display the sign if it's negative
	if (vtype & FTOA_MINUS)
    2006:	80 fd       	sbrc	r24, 0
    2008:	5b c0       	rjmp	.+182    	; 0x20c0 <_ZN16base_text_seriallsEf+0xfe>
		putchar ('-');

	// Show the mantissa
	putchar (*p_buf++);
    200a:	d7 01       	movw	r26, r14
    200c:	ed 91       	ld	r30, X+
    200e:	fc 91       	ld	r31, X
    2010:	02 80       	ldd	r0, Z+2	; 0x02
    2012:	f3 81       	ldd	r31, Z+3	; 0x03
    2014:	e0 2d       	mov	r30, r0
    2016:	c7 01       	movw	r24, r14
    2018:	6a 81       	ldd	r22, Y+2	; 0x02
    201a:	09 95       	icall
	if (digits)
    201c:	11 23       	and	r17, r17
    201e:	49 f5       	brne	.+82     	; 0x2072 <_ZN16base_text_seriallsEf+0xb0>
		putchar ('.');
	while ((digits-- > 0) && *p_buf)
		putchar (*p_buf++);

	// Now display the exponent
	putchar ('e');
    2020:	d7 01       	movw	r26, r14
    2022:	ed 91       	ld	r30, X+
    2024:	fc 91       	ld	r31, X
    2026:	02 80       	ldd	r0, Z+2	; 0x02
    2028:	f3 81       	ldd	r31, Z+3	; 0x03
    202a:	e0 2d       	mov	r30, r0
    202c:	c7 01       	movw	r24, r14
    202e:	65 e6       	ldi	r22, 0x65	; 101
    2030:	09 95       	icall
	if (exponent > 0)
    2032:	1a 14       	cp	r1, r10
    2034:	1b 04       	cpc	r1, r11
    2036:	4c f4       	brge	.+18     	; 0x204a <_ZN16base_text_seriallsEf+0x88>
		putchar ('+');
    2038:	d7 01       	movw	r26, r14
    203a:	ed 91       	ld	r30, X+
    203c:	fc 91       	ld	r31, X
    203e:	02 80       	ldd	r0, Z+2	; 0x02
    2040:	f3 81       	ldd	r31, Z+3	; 0x03
    2042:	e0 2d       	mov	r30, r0
    2044:	c7 01       	movw	r24, r14
    2046:	6b e2       	ldi	r22, 0x2B	; 43
    2048:	09 95       	icall
	*this << exponent;
    204a:	c7 01       	movw	r24, r14
    204c:	b5 01       	movw	r22, r10
    204e:	0e 94 22 0f 	call	0x1e44	; 0x1e44 <_ZN16base_text_seriallsEi>
}
    2052:	64 96       	adiw	r28, 0x14	; 20
    2054:	0f b6       	in	r0, 0x3f	; 63
    2056:	f8 94       	cli
    2058:	de bf       	out	0x3e, r29	; 62
    205a:	0f be       	out	0x3f, r0	; 63
    205c:	cd bf       	out	0x3d, r28	; 61
    205e:	cf 91       	pop	r28
    2060:	df 91       	pop	r29
    2062:	1f 91       	pop	r17
    2064:	0f 91       	pop	r16
    2066:	ff 90       	pop	r15
    2068:	ef 90       	pop	r14
    206a:	df 90       	pop	r13
    206c:	bf 90       	pop	r11
    206e:	af 90       	pop	r10
    2070:	08 95       	ret
		putchar ('-');

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
    2072:	d7 01       	movw	r26, r14
    2074:	ed 91       	ld	r30, X+
    2076:	fc 91       	ld	r31, X
    2078:	02 80       	ldd	r0, Z+2	; 0x02
    207a:	f3 81       	ldd	r31, Z+3	; 0x03
    207c:	e0 2d       	mov	r30, r0
    207e:	c7 01       	movw	r24, r14
    2080:	6e e2       	ldi	r22, 0x2E	; 46
    2082:	09 95       	icall
	while ((digits-- > 0) && *p_buf)
    2084:	11 16       	cp	r1, r17
    2086:	64 f6       	brge	.-104    	; 0x2020 <_ZN16base_text_seriallsEf+0x5e>
    2088:	6b 81       	ldd	r22, Y+3	; 0x03
    208a:	66 23       	and	r22, r22
    208c:	49 f2       	breq	.-110    	; 0x2020 <_ZN16base_text_seriallsEf+0x5e>
    208e:	d1 2e       	mov	r13, r17
    2090:	da 94       	dec	r13
    2092:	8e 01       	movw	r16, r28
    2094:	0d 5f       	subi	r16, 0xFD	; 253
    2096:	1f 4f       	sbci	r17, 0xFF	; 255
		putchar (*p_buf++);
    2098:	d7 01       	movw	r26, r14
    209a:	ed 91       	ld	r30, X+
    209c:	fc 91       	ld	r31, X
    209e:	02 80       	ldd	r0, Z+2	; 0x02
    20a0:	f3 81       	ldd	r31, Z+3	; 0x03
    20a2:	e0 2d       	mov	r30, r0
    20a4:	c7 01       	movw	r24, r14
    20a6:	09 95       	icall

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
	while ((digits-- > 0) && *p_buf)
    20a8:	1d 14       	cp	r1, r13
    20aa:	0c f0       	brlt	.+2      	; 0x20ae <_ZN16base_text_seriallsEf+0xec>
    20ac:	b9 cf       	rjmp	.-142    	; 0x2020 <_ZN16base_text_seriallsEf+0x5e>
		putchar (*p_buf++);
    20ae:	0f 5f       	subi	r16, 0xFF	; 255
    20b0:	1f 4f       	sbci	r17, 0xFF	; 255

	// Show the mantissa
	putchar (*p_buf++);
	if (digits)
		putchar ('.');
	while ((digits-- > 0) && *p_buf)
    20b2:	f8 01       	movw	r30, r16
    20b4:	60 81       	ld	r22, Z
    20b6:	da 94       	dec	r13
    20b8:	66 23       	and	r22, r22
    20ba:	09 f4       	brne	.+2      	; 0x20be <_ZN16base_text_seriallsEf+0xfc>
    20bc:	b1 cf       	rjmp	.-158    	; 0x2020 <_ZN16base_text_seriallsEf+0x5e>
    20be:	ec cf       	rjmp	.-40     	; 0x2098 <_ZN16base_text_seriallsEf+0xd6>
		return (*this);
	}

	// Display the sign if it's negative
	if (vtype & FTOA_MINUS)
		putchar ('-');
    20c0:	d7 01       	movw	r26, r14
    20c2:	ed 91       	ld	r30, X+
    20c4:	fc 91       	ld	r31, X
    20c6:	02 80       	ldd	r0, Z+2	; 0x02
    20c8:	f3 81       	ldd	r31, Z+3	; 0x03
    20ca:	e0 2d       	mov	r30, r0
    20cc:	c7 01       	movw	r24, r14
    20ce:	6d e2       	ldi	r22, 0x2D	; 45
    20d0:	09 95       	icall
    20d2:	9b cf       	rjmp	.-202    	; 0x200a <_ZN16base_text_seriallsEf+0x48>

	int exponent = __ftoa_engine ((double)num, buf, digits, 16);
	uint8_t vtype = *p_buf++;
	if (vtype & FTOA_NAN)
	{
		*this << "  NaN";
    20d4:	c7 01       	movw	r24, r14
    20d6:	64 e2       	ldi	r22, 0x24	; 36
    20d8:	72 e0       	ldi	r23, 0x02	; 2
    20da:	0e 94 98 0c 	call	0x1930	; 0x1930 <_ZN16base_text_seriallsEPKc>
    20de:	c7 01       	movw	r24, r14
    20e0:	b8 cf       	rjmp	.-144    	; 0x2052 <_ZN16base_text_seriallsEf+0x90>

000020e2 <__mulsi3>:
    20e2:	62 9f       	mul	r22, r18
    20e4:	d0 01       	movw	r26, r0
    20e6:	73 9f       	mul	r23, r19
    20e8:	f0 01       	movw	r30, r0
    20ea:	82 9f       	mul	r24, r18
    20ec:	e0 0d       	add	r30, r0
    20ee:	f1 1d       	adc	r31, r1
    20f0:	64 9f       	mul	r22, r20
    20f2:	e0 0d       	add	r30, r0
    20f4:	f1 1d       	adc	r31, r1
    20f6:	92 9f       	mul	r25, r18
    20f8:	f0 0d       	add	r31, r0
    20fa:	83 9f       	mul	r24, r19
    20fc:	f0 0d       	add	r31, r0
    20fe:	74 9f       	mul	r23, r20
    2100:	f0 0d       	add	r31, r0
    2102:	65 9f       	mul	r22, r21
    2104:	f0 0d       	add	r31, r0
    2106:	99 27       	eor	r25, r25
    2108:	72 9f       	mul	r23, r18
    210a:	b0 0d       	add	r27, r0
    210c:	e1 1d       	adc	r30, r1
    210e:	f9 1f       	adc	r31, r25
    2110:	63 9f       	mul	r22, r19
    2112:	b0 0d       	add	r27, r0
    2114:	e1 1d       	adc	r30, r1
    2116:	f9 1f       	adc	r31, r25
    2118:	bd 01       	movw	r22, r26
    211a:	cf 01       	movw	r24, r30
    211c:	11 24       	eor	r1, r1
    211e:	08 95       	ret

00002120 <__udivmodqi4>:
    2120:	99 1b       	sub	r25, r25
    2122:	79 e0       	ldi	r23, 0x09	; 9
    2124:	04 c0       	rjmp	.+8      	; 0x212e <__udivmodqi4_ep>

00002126 <__udivmodqi4_loop>:
    2126:	99 1f       	adc	r25, r25
    2128:	96 17       	cp	r25, r22
    212a:	08 f0       	brcs	.+2      	; 0x212e <__udivmodqi4_ep>
    212c:	96 1b       	sub	r25, r22

0000212e <__udivmodqi4_ep>:
    212e:	88 1f       	adc	r24, r24
    2130:	7a 95       	dec	r23
    2132:	c9 f7       	brne	.-14     	; 0x2126 <__udivmodqi4_loop>
    2134:	80 95       	com	r24
    2136:	08 95       	ret

00002138 <__udivmodhi4>:
    2138:	aa 1b       	sub	r26, r26
    213a:	bb 1b       	sub	r27, r27
    213c:	51 e1       	ldi	r21, 0x11	; 17
    213e:	07 c0       	rjmp	.+14     	; 0x214e <__udivmodhi4_ep>

00002140 <__udivmodhi4_loop>:
    2140:	aa 1f       	adc	r26, r26
    2142:	bb 1f       	adc	r27, r27
    2144:	a6 17       	cp	r26, r22
    2146:	b7 07       	cpc	r27, r23
    2148:	10 f0       	brcs	.+4      	; 0x214e <__udivmodhi4_ep>
    214a:	a6 1b       	sub	r26, r22
    214c:	b7 0b       	sbc	r27, r23

0000214e <__udivmodhi4_ep>:
    214e:	88 1f       	adc	r24, r24
    2150:	99 1f       	adc	r25, r25
    2152:	5a 95       	dec	r21
    2154:	a9 f7       	brne	.-22     	; 0x2140 <__udivmodhi4_loop>
    2156:	80 95       	com	r24
    2158:	90 95       	com	r25
    215a:	bc 01       	movw	r22, r24
    215c:	cd 01       	movw	r24, r26
    215e:	08 95       	ret

00002160 <__udivmodsi4>:
    2160:	a1 e2       	ldi	r26, 0x21	; 33
    2162:	1a 2e       	mov	r1, r26
    2164:	aa 1b       	sub	r26, r26
    2166:	bb 1b       	sub	r27, r27
    2168:	fd 01       	movw	r30, r26
    216a:	0d c0       	rjmp	.+26     	; 0x2186 <__udivmodsi4_ep>

0000216c <__udivmodsi4_loop>:
    216c:	aa 1f       	adc	r26, r26
    216e:	bb 1f       	adc	r27, r27
    2170:	ee 1f       	adc	r30, r30
    2172:	ff 1f       	adc	r31, r31
    2174:	a2 17       	cp	r26, r18
    2176:	b3 07       	cpc	r27, r19
    2178:	e4 07       	cpc	r30, r20
    217a:	f5 07       	cpc	r31, r21
    217c:	20 f0       	brcs	.+8      	; 0x2186 <__udivmodsi4_ep>
    217e:	a2 1b       	sub	r26, r18
    2180:	b3 0b       	sbc	r27, r19
    2182:	e4 0b       	sbc	r30, r20
    2184:	f5 0b       	sbc	r31, r21

00002186 <__udivmodsi4_ep>:
    2186:	66 1f       	adc	r22, r22
    2188:	77 1f       	adc	r23, r23
    218a:	88 1f       	adc	r24, r24
    218c:	99 1f       	adc	r25, r25
    218e:	1a 94       	dec	r1
    2190:	69 f7       	brne	.-38     	; 0x216c <__udivmodsi4_loop>
    2192:	60 95       	com	r22
    2194:	70 95       	com	r23
    2196:	80 95       	com	r24
    2198:	90 95       	com	r25
    219a:	9b 01       	movw	r18, r22
    219c:	ac 01       	movw	r20, r24
    219e:	bd 01       	movw	r22, r26
    21a0:	cf 01       	movw	r24, r30
    21a2:	08 95       	ret

000021a4 <dtostre>:
    21a4:	df 92       	push	r13
    21a6:	ef 92       	push	r14
    21a8:	ff 92       	push	r15
    21aa:	0f 93       	push	r16
    21ac:	1f 93       	push	r17
    21ae:	cf 93       	push	r28
    21b0:	df 93       	push	r29
    21b2:	7a 01       	movw	r14, r20
    21b4:	d0 2e       	mov	r13, r16
    21b6:	12 2f       	mov	r17, r18
    21b8:	28 30       	cpi	r18, 0x08	; 8
    21ba:	08 f0       	brcs	.+2      	; 0x21be <dtostre+0x1a>
    21bc:	17 e0       	ldi	r17, 0x07	; 7
    21be:	a7 01       	movw	r20, r14
    21c0:	21 2f       	mov	r18, r17
    21c2:	00 e0       	ldi	r16, 0x00	; 0
    21c4:	0e 94 61 12 	call	0x24c2	; 0x24c2 <__ftoa_engine>
    21c8:	68 2f       	mov	r22, r24
    21ca:	f7 01       	movw	r30, r14
    21cc:	51 91       	ld	r21, Z+
    21ce:	25 2f       	mov	r18, r21
    21d0:	50 ff       	sbrs	r21, 0
    21d2:	04 c0       	rjmp	.+8      	; 0x21dc <dtostre+0x38>
    21d4:	53 fd       	sbrc	r21, 3
    21d6:	02 c0       	rjmp	.+4      	; 0x21dc <dtostre+0x38>
    21d8:	8d e2       	ldi	r24, 0x2D	; 45
    21da:	09 c0       	rjmp	.+18     	; 0x21ee <dtostre+0x4a>
    21dc:	d1 fe       	sbrs	r13, 1
    21de:	02 c0       	rjmp	.+4      	; 0x21e4 <dtostre+0x40>
    21e0:	8b e2       	ldi	r24, 0x2B	; 43
    21e2:	05 c0       	rjmp	.+10     	; 0x21ee <dtostre+0x4a>
    21e4:	d0 fc       	sbrc	r13, 0
    21e6:	02 c0       	rjmp	.+4      	; 0x21ec <dtostre+0x48>
    21e8:	c7 01       	movw	r24, r14
    21ea:	04 c0       	rjmp	.+8      	; 0x21f4 <dtostre+0x50>
    21ec:	80 e2       	ldi	r24, 0x20	; 32
    21ee:	d7 01       	movw	r26, r14
    21f0:	8c 93       	st	X, r24
    21f2:	cf 01       	movw	r24, r30
    21f4:	48 2f       	mov	r20, r24
    21f6:	39 2f       	mov	r19, r25
    21f8:	23 ff       	sbrs	r18, 3
    21fa:	03 c0       	rjmp	.+6      	; 0x2202 <__stack+0x3>
    21fc:	64 ed       	ldi	r22, 0xD4	; 212
    21fe:	70 e0       	ldi	r23, 0x00	; 0
    2200:	04 c0       	rjmp	.+8      	; 0x220a <__stack+0xb>
    2202:	22 ff       	sbrs	r18, 2
    2204:	0b c0       	rjmp	.+22     	; 0x221c <__stack+0x1d>
    2206:	6c ec       	ldi	r22, 0xCC	; 204
    2208:	70 e0       	ldi	r23, 0x00	; 0
    220a:	d2 fe       	sbrs	r13, 2
    220c:	02 c0       	rjmp	.+4      	; 0x2212 <__stack+0x13>
    220e:	6c 5f       	subi	r22, 0xFC	; 252
    2210:	7f 4f       	sbci	r23, 0xFF	; 255
    2212:	84 2f       	mov	r24, r20
    2214:	93 2f       	mov	r25, r19
    2216:	0e 94 39 13 	call	0x2672	; 0x2672 <strcpy_P>
    221a:	45 c0       	rjmp	.+138    	; 0x22a6 <__stack+0xa7>
    221c:	f7 01       	movw	r30, r14
    221e:	21 81       	ldd	r18, Z+1	; 0x01
    2220:	dc 01       	movw	r26, r24
    2222:	2d 93       	st	X+, r18
    2224:	21 33       	cpi	r18, 0x31	; 49
    2226:	09 f0       	breq	.+2      	; 0x222a <__stack+0x2b>
    2228:	5f 7e       	andi	r21, 0xEF	; 239
    222a:	11 23       	and	r17, r17
    222c:	a9 f0       	breq	.+42     	; 0x2258 <__stack+0x59>
    222e:	e7 01       	movw	r28, r14
    2230:	84 2f       	mov	r24, r20
    2232:	93 2f       	mov	r25, r19
    2234:	fc 01       	movw	r30, r24
    2236:	91 2f       	mov	r25, r17
    2238:	2e e2       	ldi	r18, 0x2E	; 46
    223a:	8a 81       	ldd	r24, Y+2	; 0x02
    223c:	21 83       	std	Z+1, r18	; 0x01
    223e:	91 50       	subi	r25, 0x01	; 1
    2240:	21 96       	adiw	r28, 0x01	; 1
    2242:	31 96       	adiw	r30, 0x01	; 1
    2244:	28 2f       	mov	r18, r24
    2246:	99 23       	and	r25, r25
    2248:	c1 f7       	brne	.-16     	; 0x223a <__stack+0x3b>
    224a:	11 50       	subi	r17, 0x01	; 1
    224c:	81 2f       	mov	r24, r17
    224e:	90 e0       	ldi	r25, 0x00	; 0
    2250:	01 96       	adiw	r24, 0x01	; 1
    2252:	a8 0f       	add	r26, r24
    2254:	b9 1f       	adc	r27, r25
    2256:	2d 93       	st	X+, r18
    2258:	d2 fc       	sbrc	r13, 2
    225a:	02 c0       	rjmp	.+4      	; 0x2260 <__stack+0x61>
    225c:	85 e6       	ldi	r24, 0x65	; 101
    225e:	01 c0       	rjmp	.+2      	; 0x2262 <__stack+0x63>
    2260:	85 e4       	ldi	r24, 0x45	; 69
    2262:	96 2f       	mov	r25, r22
    2264:	fd 01       	movw	r30, r26
    2266:	81 93       	st	Z+, r24
    2268:	67 ff       	sbrs	r22, 7
    226a:	07 c0       	rjmp	.+14     	; 0x227a <__stack+0x7b>
    226c:	8d e2       	ldi	r24, 0x2D	; 45
    226e:	11 96       	adiw	r26, 0x01	; 1
    2270:	8c 93       	st	X, r24
    2272:	df 01       	movw	r26, r30
    2274:	11 96       	adiw	r26, 0x01	; 1
    2276:	91 95       	neg	r25
    2278:	0a c0       	rjmp	.+20     	; 0x228e <__stack+0x8f>
    227a:	66 23       	and	r22, r22
    227c:	29 f4       	brne	.+10     	; 0x2288 <__stack+0x89>
    227e:	54 ff       	sbrs	r21, 4
    2280:	03 c0       	rjmp	.+6      	; 0x2288 <__stack+0x89>
    2282:	df 01       	movw	r26, r30
    2284:	8d e2       	ldi	r24, 0x2D	; 45
    2286:	02 c0       	rjmp	.+4      	; 0x228c <__stack+0x8d>
    2288:	df 01       	movw	r26, r30
    228a:	8b e2       	ldi	r24, 0x2B	; 43
    228c:	8d 93       	st	X+, r24
    228e:	80 e3       	ldi	r24, 0x30	; 48
    2290:	02 c0       	rjmp	.+4      	; 0x2296 <__stack+0x97>
    2292:	8f 5f       	subi	r24, 0xFF	; 255
    2294:	9a 50       	subi	r25, 0x0A	; 10
    2296:	9a 30       	cpi	r25, 0x0A	; 10
    2298:	e4 f7       	brge	.-8      	; 0x2292 <__stack+0x93>
    229a:	fd 01       	movw	r30, r26
    229c:	81 93       	st	Z+, r24
    229e:	90 5d       	subi	r25, 0xD0	; 208
    22a0:	11 96       	adiw	r26, 0x01	; 1
    22a2:	9c 93       	st	X, r25
    22a4:	11 82       	std	Z+1, r1	; 0x01
    22a6:	c7 01       	movw	r24, r14
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	0f 91       	pop	r16
    22b0:	ff 90       	pop	r15
    22b2:	ef 90       	pop	r14
    22b4:	df 90       	pop	r13
    22b6:	08 95       	ret

000022b8 <malloc>:
    22b8:	cf 93       	push	r28
    22ba:	df 93       	push	r29
    22bc:	bc 01       	movw	r22, r24
    22be:	82 30       	cpi	r24, 0x02	; 2
    22c0:	91 05       	cpc	r25, r1
    22c2:	10 f4       	brcc	.+4      	; 0x22c8 <malloc+0x10>
    22c4:	62 e0       	ldi	r22, 0x02	; 2
    22c6:	70 e0       	ldi	r23, 0x00	; 0
    22c8:	a0 91 54 02 	lds	r26, 0x0254
    22cc:	b0 91 55 02 	lds	r27, 0x0255
    22d0:	ed 01       	movw	r28, r26
    22d2:	e0 e0       	ldi	r30, 0x00	; 0
    22d4:	f0 e0       	ldi	r31, 0x00	; 0
    22d6:	40 e0       	ldi	r20, 0x00	; 0
    22d8:	50 e0       	ldi	r21, 0x00	; 0
    22da:	21 c0       	rjmp	.+66     	; 0x231e <malloc+0x66>
    22dc:	88 81       	ld	r24, Y
    22de:	99 81       	ldd	r25, Y+1	; 0x01
    22e0:	86 17       	cp	r24, r22
    22e2:	97 07       	cpc	r25, r23
    22e4:	69 f4       	brne	.+26     	; 0x2300 <malloc+0x48>
    22e6:	8a 81       	ldd	r24, Y+2	; 0x02
    22e8:	9b 81       	ldd	r25, Y+3	; 0x03
    22ea:	30 97       	sbiw	r30, 0x00	; 0
    22ec:	19 f0       	breq	.+6      	; 0x22f4 <malloc+0x3c>
    22ee:	93 83       	std	Z+3, r25	; 0x03
    22f0:	82 83       	std	Z+2, r24	; 0x02
    22f2:	04 c0       	rjmp	.+8      	; 0x22fc <malloc+0x44>
    22f4:	90 93 55 02 	sts	0x0255, r25
    22f8:	80 93 54 02 	sts	0x0254, r24
    22fc:	fe 01       	movw	r30, r28
    22fe:	34 c0       	rjmp	.+104    	; 0x2368 <malloc+0xb0>
    2300:	68 17       	cp	r22, r24
    2302:	79 07       	cpc	r23, r25
    2304:	38 f4       	brcc	.+14     	; 0x2314 <malloc+0x5c>
    2306:	41 15       	cp	r20, r1
    2308:	51 05       	cpc	r21, r1
    230a:	19 f0       	breq	.+6      	; 0x2312 <malloc+0x5a>
    230c:	84 17       	cp	r24, r20
    230e:	95 07       	cpc	r25, r21
    2310:	08 f4       	brcc	.+2      	; 0x2314 <malloc+0x5c>
    2312:	ac 01       	movw	r20, r24
    2314:	fe 01       	movw	r30, r28
    2316:	8a 81       	ldd	r24, Y+2	; 0x02
    2318:	9b 81       	ldd	r25, Y+3	; 0x03
    231a:	9c 01       	movw	r18, r24
    231c:	e9 01       	movw	r28, r18
    231e:	20 97       	sbiw	r28, 0x00	; 0
    2320:	e9 f6       	brne	.-70     	; 0x22dc <malloc+0x24>
    2322:	41 15       	cp	r20, r1
    2324:	51 05       	cpc	r21, r1
    2326:	a9 f1       	breq	.+106    	; 0x2392 <malloc+0xda>
    2328:	ca 01       	movw	r24, r20
    232a:	86 1b       	sub	r24, r22
    232c:	97 0b       	sbc	r25, r23
    232e:	04 97       	sbiw	r24, 0x04	; 4
    2330:	08 f4       	brcc	.+2      	; 0x2334 <malloc+0x7c>
    2332:	ba 01       	movw	r22, r20
    2334:	e0 e0       	ldi	r30, 0x00	; 0
    2336:	f0 e0       	ldi	r31, 0x00	; 0
    2338:	2a c0       	rjmp	.+84     	; 0x238e <malloc+0xd6>
    233a:	8d 91       	ld	r24, X+
    233c:	9c 91       	ld	r25, X
    233e:	11 97       	sbiw	r26, 0x01	; 1
    2340:	84 17       	cp	r24, r20
    2342:	95 07       	cpc	r25, r21
    2344:	f9 f4       	brne	.+62     	; 0x2384 <malloc+0xcc>
    2346:	64 17       	cp	r22, r20
    2348:	75 07       	cpc	r23, r21
    234a:	81 f4       	brne	.+32     	; 0x236c <malloc+0xb4>
    234c:	12 96       	adiw	r26, 0x02	; 2
    234e:	8d 91       	ld	r24, X+
    2350:	9c 91       	ld	r25, X
    2352:	13 97       	sbiw	r26, 0x03	; 3
    2354:	30 97       	sbiw	r30, 0x00	; 0
    2356:	19 f0       	breq	.+6      	; 0x235e <malloc+0xa6>
    2358:	93 83       	std	Z+3, r25	; 0x03
    235a:	82 83       	std	Z+2, r24	; 0x02
    235c:	04 c0       	rjmp	.+8      	; 0x2366 <malloc+0xae>
    235e:	90 93 55 02 	sts	0x0255, r25
    2362:	80 93 54 02 	sts	0x0254, r24
    2366:	fd 01       	movw	r30, r26
    2368:	32 96       	adiw	r30, 0x02	; 2
    236a:	4f c0       	rjmp	.+158    	; 0x240a <malloc+0x152>
    236c:	ca 01       	movw	r24, r20
    236e:	86 1b       	sub	r24, r22
    2370:	97 0b       	sbc	r25, r23
    2372:	fd 01       	movw	r30, r26
    2374:	e8 0f       	add	r30, r24
    2376:	f9 1f       	adc	r31, r25
    2378:	61 93       	st	Z+, r22
    237a:	71 93       	st	Z+, r23
    237c:	02 97       	sbiw	r24, 0x02	; 2
    237e:	8d 93       	st	X+, r24
    2380:	9c 93       	st	X, r25
    2382:	43 c0       	rjmp	.+134    	; 0x240a <malloc+0x152>
    2384:	fd 01       	movw	r30, r26
    2386:	82 81       	ldd	r24, Z+2	; 0x02
    2388:	93 81       	ldd	r25, Z+3	; 0x03
    238a:	9c 01       	movw	r18, r24
    238c:	d9 01       	movw	r26, r18
    238e:	10 97       	sbiw	r26, 0x00	; 0
    2390:	a1 f6       	brne	.-88     	; 0x233a <malloc+0x82>
    2392:	80 91 52 02 	lds	r24, 0x0252
    2396:	90 91 53 02 	lds	r25, 0x0253
    239a:	89 2b       	or	r24, r25
    239c:	41 f4       	brne	.+16     	; 0x23ae <malloc+0xf6>
    239e:	80 91 3f 02 	lds	r24, 0x023F
    23a2:	90 91 40 02 	lds	r25, 0x0240
    23a6:	90 93 53 02 	sts	0x0253, r25
    23aa:	80 93 52 02 	sts	0x0252, r24
    23ae:	40 91 41 02 	lds	r20, 0x0241
    23b2:	50 91 42 02 	lds	r21, 0x0242
    23b6:	41 15       	cp	r20, r1
    23b8:	51 05       	cpc	r21, r1
    23ba:	41 f4       	brne	.+16     	; 0x23cc <malloc+0x114>
    23bc:	4d b7       	in	r20, 0x3d	; 61
    23be:	5e b7       	in	r21, 0x3e	; 62
    23c0:	80 91 3d 02 	lds	r24, 0x023D
    23c4:	90 91 3e 02 	lds	r25, 0x023E
    23c8:	48 1b       	sub	r20, r24
    23ca:	59 0b       	sbc	r21, r25
    23cc:	20 91 52 02 	lds	r18, 0x0252
    23d0:	30 91 53 02 	lds	r19, 0x0253
    23d4:	24 17       	cp	r18, r20
    23d6:	35 07       	cpc	r19, r21
    23d8:	b0 f4       	brcc	.+44     	; 0x2406 <malloc+0x14e>
    23da:	ca 01       	movw	r24, r20
    23dc:	82 1b       	sub	r24, r18
    23de:	93 0b       	sbc	r25, r19
    23e0:	86 17       	cp	r24, r22
    23e2:	97 07       	cpc	r25, r23
    23e4:	80 f0       	brcs	.+32     	; 0x2406 <malloc+0x14e>
    23e6:	ab 01       	movw	r20, r22
    23e8:	4e 5f       	subi	r20, 0xFE	; 254
    23ea:	5f 4f       	sbci	r21, 0xFF	; 255
    23ec:	84 17       	cp	r24, r20
    23ee:	95 07       	cpc	r25, r21
    23f0:	50 f0       	brcs	.+20     	; 0x2406 <malloc+0x14e>
    23f2:	42 0f       	add	r20, r18
    23f4:	53 1f       	adc	r21, r19
    23f6:	50 93 53 02 	sts	0x0253, r21
    23fa:	40 93 52 02 	sts	0x0252, r20
    23fe:	f9 01       	movw	r30, r18
    2400:	61 93       	st	Z+, r22
    2402:	71 93       	st	Z+, r23
    2404:	02 c0       	rjmp	.+4      	; 0x240a <malloc+0x152>
    2406:	e0 e0       	ldi	r30, 0x00	; 0
    2408:	f0 e0       	ldi	r31, 0x00	; 0
    240a:	cf 01       	movw	r24, r30
    240c:	df 91       	pop	r29
    240e:	cf 91       	pop	r28
    2410:	08 95       	ret

00002412 <free>:
    2412:	cf 93       	push	r28
    2414:	df 93       	push	r29
    2416:	00 97       	sbiw	r24, 0x00	; 0
    2418:	09 f4       	brne	.+2      	; 0x241c <free+0xa>
    241a:	50 c0       	rjmp	.+160    	; 0x24bc <free+0xaa>
    241c:	ec 01       	movw	r28, r24
    241e:	22 97       	sbiw	r28, 0x02	; 2
    2420:	1b 82       	std	Y+3, r1	; 0x03
    2422:	1a 82       	std	Y+2, r1	; 0x02
    2424:	a0 91 54 02 	lds	r26, 0x0254
    2428:	b0 91 55 02 	lds	r27, 0x0255
    242c:	10 97       	sbiw	r26, 0x00	; 0
    242e:	09 f1       	breq	.+66     	; 0x2472 <free+0x60>
    2430:	40 e0       	ldi	r20, 0x00	; 0
    2432:	50 e0       	ldi	r21, 0x00	; 0
    2434:	ac 17       	cp	r26, r28
    2436:	bd 07       	cpc	r27, r29
    2438:	08 f1       	brcs	.+66     	; 0x247c <free+0x6a>
    243a:	bb 83       	std	Y+3, r27	; 0x03
    243c:	aa 83       	std	Y+2, r26	; 0x02
    243e:	fe 01       	movw	r30, r28
    2440:	21 91       	ld	r18, Z+
    2442:	31 91       	ld	r19, Z+
    2444:	e2 0f       	add	r30, r18
    2446:	f3 1f       	adc	r31, r19
    2448:	ae 17       	cp	r26, r30
    244a:	bf 07       	cpc	r27, r31
    244c:	79 f4       	brne	.+30     	; 0x246c <free+0x5a>
    244e:	8d 91       	ld	r24, X+
    2450:	9c 91       	ld	r25, X
    2452:	11 97       	sbiw	r26, 0x01	; 1
    2454:	28 0f       	add	r18, r24
    2456:	39 1f       	adc	r19, r25
    2458:	2e 5f       	subi	r18, 0xFE	; 254
    245a:	3f 4f       	sbci	r19, 0xFF	; 255
    245c:	39 83       	std	Y+1, r19	; 0x01
    245e:	28 83       	st	Y, r18
    2460:	12 96       	adiw	r26, 0x02	; 2
    2462:	8d 91       	ld	r24, X+
    2464:	9c 91       	ld	r25, X
    2466:	13 97       	sbiw	r26, 0x03	; 3
    2468:	9b 83       	std	Y+3, r25	; 0x03
    246a:	8a 83       	std	Y+2, r24	; 0x02
    246c:	41 15       	cp	r20, r1
    246e:	51 05       	cpc	r21, r1
    2470:	71 f4       	brne	.+28     	; 0x248e <free+0x7c>
    2472:	d0 93 55 02 	sts	0x0255, r29
    2476:	c0 93 54 02 	sts	0x0254, r28
    247a:	20 c0       	rjmp	.+64     	; 0x24bc <free+0xaa>
    247c:	12 96       	adiw	r26, 0x02	; 2
    247e:	8d 91       	ld	r24, X+
    2480:	9c 91       	ld	r25, X
    2482:	13 97       	sbiw	r26, 0x03	; 3
    2484:	ad 01       	movw	r20, r26
    2486:	00 97       	sbiw	r24, 0x00	; 0
    2488:	11 f0       	breq	.+4      	; 0x248e <free+0x7c>
    248a:	dc 01       	movw	r26, r24
    248c:	d3 cf       	rjmp	.-90     	; 0x2434 <free+0x22>
    248e:	fa 01       	movw	r30, r20
    2490:	d3 83       	std	Z+3, r29	; 0x03
    2492:	c2 83       	std	Z+2, r28	; 0x02
    2494:	21 91       	ld	r18, Z+
    2496:	31 91       	ld	r19, Z+
    2498:	e2 0f       	add	r30, r18
    249a:	f3 1f       	adc	r31, r19
    249c:	ce 17       	cp	r28, r30
    249e:	df 07       	cpc	r29, r31
    24a0:	69 f4       	brne	.+26     	; 0x24bc <free+0xaa>
    24a2:	88 81       	ld	r24, Y
    24a4:	99 81       	ldd	r25, Y+1	; 0x01
    24a6:	28 0f       	add	r18, r24
    24a8:	39 1f       	adc	r19, r25
    24aa:	2e 5f       	subi	r18, 0xFE	; 254
    24ac:	3f 4f       	sbci	r19, 0xFF	; 255
    24ae:	fa 01       	movw	r30, r20
    24b0:	31 83       	std	Z+1, r19	; 0x01
    24b2:	20 83       	st	Z, r18
    24b4:	8a 81       	ldd	r24, Y+2	; 0x02
    24b6:	9b 81       	ldd	r25, Y+3	; 0x03
    24b8:	93 83       	std	Z+3, r25	; 0x03
    24ba:	82 83       	std	Z+2, r24	; 0x02
    24bc:	df 91       	pop	r29
    24be:	cf 91       	pop	r28
    24c0:	08 95       	ret

000024c2 <__ftoa_engine>:
    24c2:	28 30       	cpi	r18, 0x08	; 8
    24c4:	08 f0       	brcs	.+2      	; 0x24c8 <__ftoa_engine+0x6>
    24c6:	27 e0       	ldi	r18, 0x07	; 7
    24c8:	33 27       	eor	r19, r19
    24ca:	da 01       	movw	r26, r20
    24cc:	99 0f       	add	r25, r25
    24ce:	31 1d       	adc	r19, r1
    24d0:	87 fd       	sbrc	r24, 7
    24d2:	91 60       	ori	r25, 0x01	; 1
    24d4:	00 96       	adiw	r24, 0x00	; 0
    24d6:	61 05       	cpc	r22, r1
    24d8:	71 05       	cpc	r23, r1
    24da:	39 f4       	brne	.+14     	; 0x24ea <__ftoa_engine+0x28>
    24dc:	32 60       	ori	r19, 0x02	; 2
    24de:	2e 5f       	subi	r18, 0xFE	; 254
    24e0:	3d 93       	st	X+, r19
    24e2:	30 e3       	ldi	r19, 0x30	; 48
    24e4:	2a 95       	dec	r18
    24e6:	e1 f7       	brne	.-8      	; 0x24e0 <__ftoa_engine+0x1e>
    24e8:	08 95       	ret
    24ea:	9f 3f       	cpi	r25, 0xFF	; 255
    24ec:	30 f0       	brcs	.+12     	; 0x24fa <__ftoa_engine+0x38>
    24ee:	80 38       	cpi	r24, 0x80	; 128
    24f0:	71 05       	cpc	r23, r1
    24f2:	61 05       	cpc	r22, r1
    24f4:	09 f0       	breq	.+2      	; 0x24f8 <__ftoa_engine+0x36>
    24f6:	3c 5f       	subi	r19, 0xFC	; 252
    24f8:	3c 5f       	subi	r19, 0xFC	; 252
    24fa:	3d 93       	st	X+, r19
    24fc:	91 30       	cpi	r25, 0x01	; 1
    24fe:	08 f0       	brcs	.+2      	; 0x2502 <__ftoa_engine+0x40>
    2500:	80 68       	ori	r24, 0x80	; 128
    2502:	91 1d       	adc	r25, r1
    2504:	df 93       	push	r29
    2506:	cf 93       	push	r28
    2508:	1f 93       	push	r17
    250a:	0f 93       	push	r16
    250c:	ff 92       	push	r15
    250e:	ef 92       	push	r14
    2510:	19 2f       	mov	r17, r25
    2512:	98 7f       	andi	r25, 0xF8	; 248
    2514:	96 95       	lsr	r25
    2516:	e9 2f       	mov	r30, r25
    2518:	96 95       	lsr	r25
    251a:	96 95       	lsr	r25
    251c:	e9 0f       	add	r30, r25
    251e:	ff 27       	eor	r31, r31
    2520:	ea 5c       	subi	r30, 0xCA	; 202
    2522:	fe 4f       	sbci	r31, 0xFE	; 254
    2524:	99 27       	eor	r25, r25
    2526:	33 27       	eor	r19, r19
    2528:	ee 24       	eor	r14, r14
    252a:	ff 24       	eor	r15, r15
    252c:	a7 01       	movw	r20, r14
    252e:	e7 01       	movw	r28, r14
    2530:	05 90       	lpm	r0, Z+
    2532:	08 94       	sec
    2534:	07 94       	ror	r0
    2536:	28 f4       	brcc	.+10     	; 0x2542 <__ftoa_engine+0x80>
    2538:	36 0f       	add	r19, r22
    253a:	e7 1e       	adc	r14, r23
    253c:	f8 1e       	adc	r15, r24
    253e:	49 1f       	adc	r20, r25
    2540:	51 1d       	adc	r21, r1
    2542:	66 0f       	add	r22, r22
    2544:	77 1f       	adc	r23, r23
    2546:	88 1f       	adc	r24, r24
    2548:	99 1f       	adc	r25, r25
    254a:	06 94       	lsr	r0
    254c:	a1 f7       	brne	.-24     	; 0x2536 <__ftoa_engine+0x74>
    254e:	05 90       	lpm	r0, Z+
    2550:	07 94       	ror	r0
    2552:	28 f4       	brcc	.+10     	; 0x255e <__ftoa_engine+0x9c>
    2554:	e7 0e       	add	r14, r23
    2556:	f8 1e       	adc	r15, r24
    2558:	49 1f       	adc	r20, r25
    255a:	56 1f       	adc	r21, r22
    255c:	c1 1d       	adc	r28, r1
    255e:	77 0f       	add	r23, r23
    2560:	88 1f       	adc	r24, r24
    2562:	99 1f       	adc	r25, r25
    2564:	66 1f       	adc	r22, r22
    2566:	06 94       	lsr	r0
    2568:	a1 f7       	brne	.-24     	; 0x2552 <__ftoa_engine+0x90>
    256a:	05 90       	lpm	r0, Z+
    256c:	07 94       	ror	r0
    256e:	28 f4       	brcc	.+10     	; 0x257a <__ftoa_engine+0xb8>
    2570:	f8 0e       	add	r15, r24
    2572:	49 1f       	adc	r20, r25
    2574:	56 1f       	adc	r21, r22
    2576:	c7 1f       	adc	r28, r23
    2578:	d1 1d       	adc	r29, r1
    257a:	88 0f       	add	r24, r24
    257c:	99 1f       	adc	r25, r25
    257e:	66 1f       	adc	r22, r22
    2580:	77 1f       	adc	r23, r23
    2582:	06 94       	lsr	r0
    2584:	a1 f7       	brne	.-24     	; 0x256e <__ftoa_engine+0xac>
    2586:	05 90       	lpm	r0, Z+
    2588:	07 94       	ror	r0
    258a:	20 f4       	brcc	.+8      	; 0x2594 <__ftoa_engine+0xd2>
    258c:	49 0f       	add	r20, r25
    258e:	56 1f       	adc	r21, r22
    2590:	c7 1f       	adc	r28, r23
    2592:	d8 1f       	adc	r29, r24
    2594:	99 0f       	add	r25, r25
    2596:	66 1f       	adc	r22, r22
    2598:	77 1f       	adc	r23, r23
    259a:	88 1f       	adc	r24, r24
    259c:	06 94       	lsr	r0
    259e:	a9 f7       	brne	.-22     	; 0x258a <__ftoa_engine+0xc8>
    25a0:	84 91       	lpm	r24, Z+
    25a2:	10 95       	com	r17
    25a4:	17 70       	andi	r17, 0x07	; 7
    25a6:	41 f0       	breq	.+16     	; 0x25b8 <__ftoa_engine+0xf6>
    25a8:	d6 95       	lsr	r29
    25aa:	c7 95       	ror	r28
    25ac:	57 95       	ror	r21
    25ae:	47 95       	ror	r20
    25b0:	f7 94       	ror	r15
    25b2:	e7 94       	ror	r14
    25b4:	1a 95       	dec	r17
    25b6:	c1 f7       	brne	.-16     	; 0x25a8 <__ftoa_engine+0xe6>
    25b8:	ec ed       	ldi	r30, 0xDC	; 220
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	68 94       	set
    25be:	15 90       	lpm	r1, Z+
    25c0:	15 91       	lpm	r17, Z+
    25c2:	35 91       	lpm	r19, Z+
    25c4:	65 91       	lpm	r22, Z+
    25c6:	95 91       	lpm	r25, Z+
    25c8:	05 90       	lpm	r0, Z+
    25ca:	7f e2       	ldi	r23, 0x2F	; 47
    25cc:	73 95       	inc	r23
    25ce:	e1 18       	sub	r14, r1
    25d0:	f1 0a       	sbc	r15, r17
    25d2:	43 0b       	sbc	r20, r19
    25d4:	56 0b       	sbc	r21, r22
    25d6:	c9 0b       	sbc	r28, r25
    25d8:	d0 09       	sbc	r29, r0
    25da:	c0 f7       	brcc	.-16     	; 0x25cc <__ftoa_engine+0x10a>
    25dc:	e1 0c       	add	r14, r1
    25de:	f1 1e       	adc	r15, r17
    25e0:	43 1f       	adc	r20, r19
    25e2:	56 1f       	adc	r21, r22
    25e4:	c9 1f       	adc	r28, r25
    25e6:	d0 1d       	adc	r29, r0
    25e8:	7e f4       	brtc	.+30     	; 0x2608 <__ftoa_engine+0x146>
    25ea:	70 33       	cpi	r23, 0x30	; 48
    25ec:	11 f4       	brne	.+4      	; 0x25f2 <__ftoa_engine+0x130>
    25ee:	8a 95       	dec	r24
    25f0:	e6 cf       	rjmp	.-52     	; 0x25be <__ftoa_engine+0xfc>
    25f2:	e8 94       	clt
    25f4:	01 50       	subi	r16, 0x01	; 1
    25f6:	30 f0       	brcs	.+12     	; 0x2604 <__ftoa_engine+0x142>
    25f8:	08 0f       	add	r16, r24
    25fa:	0a f4       	brpl	.+2      	; 0x25fe <__ftoa_engine+0x13c>
    25fc:	00 27       	eor	r16, r16
    25fe:	02 17       	cp	r16, r18
    2600:	08 f4       	brcc	.+2      	; 0x2604 <__ftoa_engine+0x142>
    2602:	20 2f       	mov	r18, r16
    2604:	23 95       	inc	r18
    2606:	02 2f       	mov	r16, r18
    2608:	7a 33       	cpi	r23, 0x3A	; 58
    260a:	28 f0       	brcs	.+10     	; 0x2616 <__ftoa_engine+0x154>
    260c:	79 e3       	ldi	r23, 0x39	; 57
    260e:	7d 93       	st	X+, r23
    2610:	2a 95       	dec	r18
    2612:	e9 f7       	brne	.-6      	; 0x260e <__ftoa_engine+0x14c>
    2614:	10 c0       	rjmp	.+32     	; 0x2636 <__ftoa_engine+0x174>
    2616:	7d 93       	st	X+, r23
    2618:	2a 95       	dec	r18
    261a:	89 f6       	brne	.-94     	; 0x25be <__ftoa_engine+0xfc>
    261c:	06 94       	lsr	r0
    261e:	97 95       	ror	r25
    2620:	67 95       	ror	r22
    2622:	37 95       	ror	r19
    2624:	17 95       	ror	r17
    2626:	17 94       	ror	r1
    2628:	e1 18       	sub	r14, r1
    262a:	f1 0a       	sbc	r15, r17
    262c:	43 0b       	sbc	r20, r19
    262e:	56 0b       	sbc	r21, r22
    2630:	c9 0b       	sbc	r28, r25
    2632:	d0 09       	sbc	r29, r0
    2634:	98 f0       	brcs	.+38     	; 0x265c <__ftoa_engine+0x19a>
    2636:	23 95       	inc	r18
    2638:	7e 91       	ld	r23, -X
    263a:	73 95       	inc	r23
    263c:	7a 33       	cpi	r23, 0x3A	; 58
    263e:	08 f0       	brcs	.+2      	; 0x2642 <__ftoa_engine+0x180>
    2640:	70 e3       	ldi	r23, 0x30	; 48
    2642:	7c 93       	st	X, r23
    2644:	20 13       	cpse	r18, r16
    2646:	b8 f7       	brcc	.-18     	; 0x2636 <__ftoa_engine+0x174>
    2648:	7e 91       	ld	r23, -X
    264a:	70 61       	ori	r23, 0x10	; 16
    264c:	7d 93       	st	X+, r23
    264e:	30 f0       	brcs	.+12     	; 0x265c <__ftoa_engine+0x19a>
    2650:	83 95       	inc	r24
    2652:	71 e3       	ldi	r23, 0x31	; 49
    2654:	7d 93       	st	X+, r23
    2656:	70 e3       	ldi	r23, 0x30	; 48
    2658:	2a 95       	dec	r18
    265a:	e1 f7       	brne	.-8      	; 0x2654 <__ftoa_engine+0x192>
    265c:	11 24       	eor	r1, r1
    265e:	ef 90       	pop	r14
    2660:	ff 90       	pop	r15
    2662:	0f 91       	pop	r16
    2664:	1f 91       	pop	r17
    2666:	cf 91       	pop	r28
    2668:	df 91       	pop	r29
    266a:	99 27       	eor	r25, r25
    266c:	87 fd       	sbrc	r24, 7
    266e:	90 95       	com	r25
    2670:	08 95       	ret

00002672 <strcpy_P>:
    2672:	fb 01       	movw	r30, r22
    2674:	dc 01       	movw	r26, r24
    2676:	05 90       	lpm	r0, Z+
    2678:	0d 92       	st	X+, r0
    267a:	00 20       	and	r0, r0
    267c:	e1 f7       	brne	.-8      	; 0x2676 <strcpy_P+0x4>
    267e:	08 95       	ret

00002680 <itoa>:
    2680:	fb 01       	movw	r30, r22
    2682:	9f 01       	movw	r18, r30
    2684:	e8 94       	clt
    2686:	42 30       	cpi	r20, 0x02	; 2
    2688:	c4 f0       	brlt	.+48     	; 0x26ba <itoa+0x3a>
    268a:	45 32       	cpi	r20, 0x25	; 37
    268c:	b4 f4       	brge	.+44     	; 0x26ba <itoa+0x3a>
    268e:	4a 30       	cpi	r20, 0x0A	; 10
    2690:	29 f4       	brne	.+10     	; 0x269c <itoa+0x1c>
    2692:	97 fb       	bst	r25, 7
    2694:	1e f4       	brtc	.+6      	; 0x269c <itoa+0x1c>
    2696:	90 95       	com	r25
    2698:	81 95       	neg	r24
    269a:	9f 4f       	sbci	r25, 0xFF	; 255
    269c:	64 2f       	mov	r22, r20
    269e:	77 27       	eor	r23, r23
    26a0:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
    26a4:	80 5d       	subi	r24, 0xD0	; 208
    26a6:	8a 33       	cpi	r24, 0x3A	; 58
    26a8:	0c f0       	brlt	.+2      	; 0x26ac <itoa+0x2c>
    26aa:	89 5d       	subi	r24, 0xD9	; 217
    26ac:	81 93       	st	Z+, r24
    26ae:	cb 01       	movw	r24, r22
    26b0:	00 97       	sbiw	r24, 0x00	; 0
    26b2:	a1 f7       	brne	.-24     	; 0x269c <itoa+0x1c>
    26b4:	16 f4       	brtc	.+4      	; 0x26ba <itoa+0x3a>
    26b6:	5d e2       	ldi	r21, 0x2D	; 45
    26b8:	51 93       	st	Z+, r21
    26ba:	10 82       	st	Z, r1
    26bc:	c9 01       	movw	r24, r18
    26be:	0c 94 d0 13 	jmp	0x27a0	; 0x27a0 <strrev>

000026c2 <ltoa>:
    26c2:	fa 01       	movw	r30, r20
    26c4:	cf 93       	push	r28
    26c6:	ff 93       	push	r31
    26c8:	ef 93       	push	r30
    26ca:	22 30       	cpi	r18, 0x02	; 2
    26cc:	44 f1       	brlt	.+80     	; 0x271e <ltoa+0x5c>
    26ce:	25 32       	cpi	r18, 0x25	; 37
    26d0:	34 f5       	brge	.+76     	; 0x271e <ltoa+0x5c>
    26d2:	c2 2f       	mov	r28, r18
    26d4:	e8 94       	clt
    26d6:	ca 30       	cpi	r28, 0x0A	; 10
    26d8:	49 f4       	brne	.+18     	; 0x26ec <ltoa+0x2a>
    26da:	97 fb       	bst	r25, 7
    26dc:	3e f4       	brtc	.+14     	; 0x26ec <ltoa+0x2a>
    26de:	90 95       	com	r25
    26e0:	80 95       	com	r24
    26e2:	70 95       	com	r23
    26e4:	61 95       	neg	r22
    26e6:	7f 4f       	sbci	r23, 0xFF	; 255
    26e8:	8f 4f       	sbci	r24, 0xFF	; 255
    26ea:	9f 4f       	sbci	r25, 0xFF	; 255
    26ec:	2c 2f       	mov	r18, r28
    26ee:	33 27       	eor	r19, r19
    26f0:	44 27       	eor	r20, r20
    26f2:	55 27       	eor	r21, r21
    26f4:	ff 93       	push	r31
    26f6:	ef 93       	push	r30
    26f8:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    26fc:	ef 91       	pop	r30
    26fe:	ff 91       	pop	r31
    2700:	60 5d       	subi	r22, 0xD0	; 208
    2702:	6a 33       	cpi	r22, 0x3A	; 58
    2704:	0c f0       	brlt	.+2      	; 0x2708 <ltoa+0x46>
    2706:	69 5d       	subi	r22, 0xD9	; 217
    2708:	61 93       	st	Z+, r22
    270a:	b9 01       	movw	r22, r18
    270c:	ca 01       	movw	r24, r20
    270e:	60 50       	subi	r22, 0x00	; 0
    2710:	70 40       	sbci	r23, 0x00	; 0
    2712:	80 40       	sbci	r24, 0x00	; 0
    2714:	90 40       	sbci	r25, 0x00	; 0
    2716:	51 f7       	brne	.-44     	; 0x26ec <ltoa+0x2a>
    2718:	16 f4       	brtc	.+4      	; 0x271e <ltoa+0x5c>
    271a:	cd e2       	ldi	r28, 0x2D	; 45
    271c:	c1 93       	st	Z+, r28
    271e:	10 82       	st	Z, r1
    2720:	8f 91       	pop	r24
    2722:	9f 91       	pop	r25
    2724:	cf 91       	pop	r28
    2726:	0c 94 d0 13 	jmp	0x27a0	; 0x27a0 <strrev>

0000272a <ultoa>:
    272a:	fa 01       	movw	r30, r20
    272c:	cf 93       	push	r28
    272e:	ff 93       	push	r31
    2730:	ef 93       	push	r30
    2732:	22 30       	cpi	r18, 0x02	; 2
    2734:	cc f0       	brlt	.+50     	; 0x2768 <ultoa+0x3e>
    2736:	25 32       	cpi	r18, 0x25	; 37
    2738:	bc f4       	brge	.+46     	; 0x2768 <ultoa+0x3e>
    273a:	c2 2f       	mov	r28, r18
    273c:	2c 2f       	mov	r18, r28
    273e:	33 27       	eor	r19, r19
    2740:	44 27       	eor	r20, r20
    2742:	55 27       	eor	r21, r21
    2744:	ff 93       	push	r31
    2746:	ef 93       	push	r30
    2748:	0e 94 b0 10 	call	0x2160	; 0x2160 <__udivmodsi4>
    274c:	ef 91       	pop	r30
    274e:	ff 91       	pop	r31
    2750:	60 5d       	subi	r22, 0xD0	; 208
    2752:	6a 33       	cpi	r22, 0x3A	; 58
    2754:	0c f0       	brlt	.+2      	; 0x2758 <ultoa+0x2e>
    2756:	69 5d       	subi	r22, 0xD9	; 217
    2758:	61 93       	st	Z+, r22
    275a:	b9 01       	movw	r22, r18
    275c:	ca 01       	movw	r24, r20
    275e:	60 50       	subi	r22, 0x00	; 0
    2760:	70 40       	sbci	r23, 0x00	; 0
    2762:	80 40       	sbci	r24, 0x00	; 0
    2764:	90 40       	sbci	r25, 0x00	; 0
    2766:	51 f7       	brne	.-44     	; 0x273c <ultoa+0x12>
    2768:	10 82       	st	Z, r1
    276a:	8f 91       	pop	r24
    276c:	9f 91       	pop	r25
    276e:	cf 91       	pop	r28
    2770:	0c 94 d0 13 	jmp	0x27a0	; 0x27a0 <strrev>

00002774 <utoa>:
    2774:	fb 01       	movw	r30, r22
    2776:	9f 01       	movw	r18, r30
    2778:	42 30       	cpi	r20, 0x02	; 2
    277a:	74 f0       	brlt	.+28     	; 0x2798 <utoa+0x24>
    277c:	45 32       	cpi	r20, 0x25	; 37
    277e:	64 f4       	brge	.+24     	; 0x2798 <utoa+0x24>
    2780:	64 2f       	mov	r22, r20
    2782:	77 27       	eor	r23, r23
    2784:	0e 94 9c 10 	call	0x2138	; 0x2138 <__udivmodhi4>
    2788:	80 5d       	subi	r24, 0xD0	; 208
    278a:	8a 33       	cpi	r24, 0x3A	; 58
    278c:	0c f0       	brlt	.+2      	; 0x2790 <utoa+0x1c>
    278e:	89 5d       	subi	r24, 0xD9	; 217
    2790:	81 93       	st	Z+, r24
    2792:	cb 01       	movw	r24, r22
    2794:	00 97       	sbiw	r24, 0x00	; 0
    2796:	a1 f7       	brne	.-24     	; 0x2780 <utoa+0xc>
    2798:	10 82       	st	Z, r1
    279a:	c9 01       	movw	r24, r18
    279c:	0c 94 d0 13 	jmp	0x27a0	; 0x27a0 <strrev>

000027a0 <strrev>:
    27a0:	dc 01       	movw	r26, r24
    27a2:	fc 01       	movw	r30, r24
    27a4:	67 2f       	mov	r22, r23
    27a6:	71 91       	ld	r23, Z+
    27a8:	77 23       	and	r23, r23
    27aa:	e1 f7       	brne	.-8      	; 0x27a4 <strrev+0x4>
    27ac:	32 97       	sbiw	r30, 0x02	; 2
    27ae:	04 c0       	rjmp	.+8      	; 0x27b8 <strrev+0x18>
    27b0:	7c 91       	ld	r23, X
    27b2:	6d 93       	st	X+, r22
    27b4:	70 83       	st	Z, r23
    27b6:	62 91       	ld	r22, -Z
    27b8:	ae 17       	cp	r26, r30
    27ba:	bf 07       	cpc	r27, r31
    27bc:	c8 f3       	brcs	.-14     	; 0x27b0 <strrev+0x10>
    27be:	08 95       	ret

000027c0 <_exit>:
    27c0:	f8 94       	cli

000027c2 <__stop_program>:
    27c2:	ff cf       	rjmp	.-2      	; 0x27c2 <__stop_program>
