<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Polar Plotter Project: stl_task Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Polar Plotter Project
   &#160;<span id="projectnumber">5.0</span>
   </div>
   <div id="projectbrief">A 2D Polar Plotter for Drawing Straight Lines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classstl__task.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classstl__task-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">stl_task Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="stl__task_8h_source.html">stl_task.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for stl_task:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classstl__task.png" usemap="#stl_task_map" alt=""/>
  <map id="stl_task_map" name="stl_task_map">
<area href="classGo__Home.html" alt="Go_Home" shape="rect" coords="0,56,67,80"/>
<area href="classtask__lines.html" alt="task_lines" shape="rect" coords="77,56,144,80"/>
<area href="classtask__PID.html" title="This define prevents this .h file from being included more than once in a .cpp file. " alt="task_PID" shape="rect" coords="154,56,221,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af8f81fb3e56c9d72b3b273ea1fe28d39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#af8f81fb3e56c9d72b3b273ea1fe28d39">stl_task</a> (<a class="el" href="classtask__timer.html">task_timer</a> &amp;, const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;)</td></tr>
<tr class="separator:af8f81fb3e56c9d72b3b273ea1fe28d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809314255837a6ba122bef5a03775b9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a809314255837a6ba122bef5a03775b9a">set_interval</a> (const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;)</td></tr>
<tr class="separator:a809314255837a6ba122bef5a03775b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d06fa647b9492360a9c38fe429f7ccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a5d06fa647b9492360a9c38fe429f7ccc">set_next_run_time</a> (const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;)</td></tr>
<tr class="separator:a5d06fa647b9492360a9c38fe429f7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a54618c911663e235f07fba78c728a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="stl__task_8h.html#ab7f098b819a25c755325d69a07030021">task_op_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule</a> (<a class="el" href="classtime__stamp.html">time_stamp</a> *=NULL)</td></tr>
<tr class="separator:a86a54618c911663e235f07fba78c728a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f8eccc4a9c6737d217402b3cb0ffee"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run</a> (char)</td></tr>
<tr class="separator:a35f8eccc4a9c6737d217402b3cb0ffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e49886b5ecd7479a3d09d378b09d97f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a8e49886b5ecd7479a3d09d378b09d97f">suspend</a> (void)</td></tr>
<tr class="separator:a8e49886b5ecd7479a3d09d378b09d97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdec061dcd4755e8a870383433b1fc5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#acdec061dcd4755e8a870383433b1fc5b">resume</a> (void)</td></tr>
<tr class="separator:acdec061dcd4755e8a870383433b1fc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73904c3a785fbb3eb0f0041bca5926fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a73904c3a785fbb3eb0f0041bca5926fe">set_initial_state</a> (char)</td></tr>
<tr class="separator:a73904c3a785fbb3eb0f0041bca5926fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d50aa3d9137e11bad5aef502aac2d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#add7d50aa3d9137e11bad5aef502aac2d">get_serial_number</a> (void)</td></tr>
<tr class="separator:add7d50aa3d9137e11bad5aef502aac2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacad5f6dd55902d3292c75f6baed8648"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#aacad5f6dd55902d3292c75f6baed8648">get_current_state</a> (void)</td></tr>
<tr class="separator:aacad5f6dd55902d3292c75f6baed8648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc3f4e187b2b87aa3ce8c9fb851a27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stl__task_8h.html#ab7f098b819a25c755325d69a07030021">task_op_state</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#abdc3f4e187b2b87aa3ce8c9fb851a27a">get_op_state</a> (void)</td></tr>
<tr class="separator:abdc3f4e187b2b87aa3ce8c9fb851a27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa976345c69db9b31f42442a04adda32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#aa976345c69db9b31f42442a04adda32e">run_again_ASAP</a> (void)</td></tr>
<tr class="separator:aa976345c69db9b31f42442a04adda32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8518939173f61a31158c29404b649a54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a8518939173f61a31158c29404b649a54">ready</a> (void)</td></tr>
<tr class="separator:a8518939173f61a31158c29404b649a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab114eb46ce3bf58263d42a3528288d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#ab114eb46ce3bf58263d42a3528288d5d">error_stop</a> (char const *)</td></tr>
<tr class="separator:ab114eb46ce3bf58263d42a3528288d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8db004322eb55d27196c332bbd1d9c4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8db004322eb55d27196c332bbd1d9c4c"></a>
<a class="el" href="classtask__timer.html">task_timer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#a8db004322eb55d27196c332bbd1d9c4c">the_timer</a></td></tr>
<tr class="memdesc:a8db004322eb55d27196c332bbd1d9c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a reference to the device driver which keeps track of real time. <br/></td></tr>
<tr class="separator:a8db004322eb55d27196c332bbd1d9c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add87ffb2cc0649d4b3d291323c2fe47b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add87ffb2cc0649d4b3d291323c2fe47b"></a>
<a class="el" href="classtime__stamp.html">time_stamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#add87ffb2cc0649d4b3d291323c2fe47b">next_run_time</a></td></tr>
<tr class="memdesc:add87ffb2cc0649d4b3d291323c2fe47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the time at which the task should next be run. <br/></td></tr>
<tr class="separator:add87ffb2cc0649d4b3d291323c2fe47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecb442fa869e15d3c82efc19a041abe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afecb442fa869e15d3c82efc19a041abe"></a>
<a class="el" href="classtime__stamp.html">time_stamp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstl__task.html#afecb442fa869e15d3c82efc19a041abe">interval</a></td></tr>
<tr class="memdesc:afecb442fa869e15d3c82efc19a041abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the time interval between runs of the task. <br/></td></tr>
<tr class="separator:afecb442fa869e15d3c82efc19a041abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements the behavior of a task in the context of a multitasking system. Each task runs "simultaneously" with other tasks. This means, of course, that execution switches quickly from one task to another quite quickly under the control of the main execution scheduler. Since a task can be in any of several states at a given time, a task object will have a list of state methods which can be run and be able to switch between those states.</p>
<h1><a class="anchor" id="task_usage"></a>
Usage</h1>
<p>The programmer uses this class by deriving a descendent class from it. Then s/he creates a <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method in the new class which implements the states. In the <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method, there's a big switch statement which chooses which state code is to run when the <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method is called. Checking the time and deciding when to run is taken care of by the <a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule()</a> method, which only runs the task's state code when the task's time interval has been reached; if the time interval is set to 0, the state code is run every time <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> is called. State transitions are detected and tracked by this class for testing and debugging purposes.</p>
<h1><a class="anchor" id="task_options"></a>
Options</h1>
<ul>
<li>Serial port debugging can be enabled by defining SERIAL_DEBUG and calling the constructor which is given a pointer to a uart object. The task will then write information about state transitions to the serial port during operation. This option is intended to be used during debugging, then turned off for production code, as serial device writing takes up time and memory, and of course it requires a serial device to be present and connected. </li>
<li>Execution time profiling can be enabled by defining STL_PROFILE. This option causes the execution times of the state functions to be measured and a simple set of performance data to be kept. Performance data can be written to a serial port at a convenient time, generally after the system has been run in test for a while.</li>
</ul>
<h1><a class="anchor" id="task_intrn"></a>
Internal Organization</h1>
<p>At any time, a task is in both a <em>user state</em> and an <em>operational state</em>. The user state is the state which the user manipulates; it chooses the action that the <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method will take each time it is called by the scheduler. The user state is the state which appears in the user's state transition diagrams. The operational state shows how the scheduler is treating a task - whether the task is running, waiting for its time to run, ready to run, suspended, etc. Operational states for all tasks follow the "state diagram" below.</p>
<div align="center">
</div>
<p> Blocked tasks (due to resource contention) are not currently implemented.</p>
<p>When a task is run cooperatively (rather than by interrupts), it is run when the method <a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule()</a> is called from within the main while loop in the main() routine. The <a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule()</a> method belongs to class <a class="el" href="classstl__task.html">stl_task</a> and generally does not need to be modified by the user. </p>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00121">121</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af8f81fb3e56c9d72b3b273ea1fe28d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">stl_task::stl_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtask__timer.html">task_timer</a> &amp;&#160;</td>
          <td class="paramname"><em>a_timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;&#160;</td>
          <td class="paramname"><em>time_interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor creates a task object. It must be called by the constructor of each task which is written by the user. This constructor sets the time between runs of the <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method (a timestamp with zero time can be used if a task needs to run via interrupt, or every single time its <a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule()</a> method is called). This constructor also saves a pointer to the serial port or radio object which will be used to dump debugging information, if serial debugging is being used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_timer</td><td>A reference to the timer which measures real-time intervals </td></tr>
    <tr><td class="paramname">time_interval</td><td>The time between runs of the task's <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00054">54</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="stl__task_8h_source.html#l00047">TASK_WAITING</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab114eb46ce3bf58263d42a3528288d5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::error_stop </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method displays a message (if the program was compiled with serial debugging enabled) and then causes the processor to freeze in an infinite loop. It should be used if something awful happened and the safest thing to do is to just stop. Only use this function if there isn't a reasonable way to write an error state which handles exceptions in a more useful manner, such as by turning motors and other possibly dangerous devices off and then halting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The text to be displayed before the processor stops working </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00258">258</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, and <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>.</p>

<p>Referenced by <a class="el" href="stl__task_8cpp_source.html#l00115">schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="aacad5f6dd55902d3292c75f6baed8648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char stl_task::get_current_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the state in which the task is currently. The state cannot directly be changed by the user; it can only be changed through the returned value from the <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>The state in which the task is when this method is called </dd></dl>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00177">177</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>

</div>
</div>
<a class="anchor" id="abdc3f4e187b2b87aa3ce8c9fb851a27a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stl__task_8h.html#ab7f098b819a25c755325d69a07030021">task_op_state</a> stl_task::get_op_state </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the task's current operational state. The operational state isn't the same as the state transition logic state; it's a separate variable which controls if the task is running at a given time. </p>
<dl class="section return"><dt>Returns</dt><dd>The task's current operational state </dd></dl>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00184">184</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>

</div>
</div>
<a class="anchor" id="add7d50aa3d9137e11bad5aef502aac2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char stl_task::get_serial_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the task's automatically assigned serial number. </p>
<dl class="section return"><dt>Returns</dt><dd>The task's serial number </dd></dl>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00170">170</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>

<p>Referenced by <a class="el" href="stl__task_8cpp_source.html#l00382">operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="a8518939173f61a31158c29404b649a54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stl_task::ready </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method tells whether the task needs to run again as soon as possible or not. It is convenient to use when determining if the processor should be put to sleep for a while. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the task needs to run soon, false if it does not </dd></dl>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00196">196</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>

<p>References <a class="el" href="stl__task_8h_source.html#l00046">TASK_PENDING</a>, and <a class="el" href="stl__task_8h_source.html#l00045">TASK_RUNNING</a>.</p>

</div>
</div>
<a class="anchor" id="acdec061dcd4755e8a870383433b1fc5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::resume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method resumes the task from suspension, so that the task can run again. The operational state which was saved at the time of suspension is restored. </p>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00229">229</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35f8eccc4a9c6737d217402b3cb0ffee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char stl_task::run </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>a_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a base method which the user should overload in each descendent of this task class. The run method is where all the user-defined action in the task takes place. It is either called by the task's <a class="el" href="classstl__task.html#a86a54618c911663e235f07fba78c728a">schedule()</a> method, in the case of cooperative multitasking, or by an interrupt handler, in the case of pre-emptive multitasking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a_state</td><td>The state of the task when this run method begins running </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The state to which the task will transition, or STL_NO_TRANSITION if no transition is called for at this time </dd></dl>

<p>Reimplemented in <a class="el" href="classtask__PID.html#a6f05dcd8d4efe5ab56610e02ea814b7b">task_PID</a>, <a class="el" href="classtask__lines.html#adc52a1f1de31103830a06737db769a34">task_lines</a>, and <a class="el" href="classGo__Home.html#ae1421efd3ca49627022675f74534ced6">Go_Home</a>.</p>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00203">203</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="stl__task_8h_source.html#l00033">STL_NO_TRANSITION</a>.</p>

<p>Referenced by <a class="el" href="stl__task_8cpp_source.html#l00115">schedule()</a>.</p>

</div>
</div>
<a class="anchor" id="aa976345c69db9b31f42442a04adda32e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::run_again_ASAP </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method will cause the task to run again as soon as it can instead of waiting for the given time interval. </p>

<p>Definition at line <a class="el" href="stl__task_8h_source.html#l00189">189</a> of file <a class="el" href="stl__task_8h_source.html">stl_task.h</a>.</p>

<p>References <a class="el" href="stl__task_8h_source.html#l00046">TASK_PENDING</a>.</p>

</div>
</div>
<a class="anchor" id="a86a54618c911663e235f07fba78c728a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stl__task_8h.html#ab7f098b819a25c755325d69a07030021">task_op_state</a> stl_task::schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtime__stamp.html">time_stamp</a> *&#160;</td>
          <td class="paramname"><em>til_next_time</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called by the main task loop to try to run the task. If the task is in the waiting state, it checks to see if it's time to run yet; if it's in the suspended state, it doesn't. The task shouldn't be in the running state, because this method is used by the cooperative scheduler, not the pre-emptive one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">til_next_time</td><td>A pointer to a time stamp which will hold next time this task next needs to run, or NULL (default) if this data isn't needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operational state of the task after it has been given this chance to run </dd></dl>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00115">115</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="stl__task_8cpp_source.html#l00258">error_stop()</a>, <a class="el" href="stl__timer_8cpp_source.html#l00375">task_timer::get_time_now()</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="stl__task_8h_source.html#l00147">interval</a>, <a class="el" href="stl__task_8h_source.html#l00144">next_run_time</a>, <a class="el" href="stl__task_8cpp_source.html#l00203">run()</a>, <a class="el" href="stl__task_8h_source.html#l00033">STL_NO_TRANSITION</a>, <a class="el" href="stl__task_8h_source.html#l00046">TASK_PENDING</a>, <a class="el" href="stl__task_8h_source.html#l00049">TASK_SUSPENDED</a>, <a class="el" href="stl__task_8h_source.html#l00047">TASK_WAITING</a>, and <a class="el" href="stl__task_8h_source.html#l00141">the_timer</a>.</p>

</div>
</div>
<a class="anchor" id="a73904c3a785fbb3eb0f0041bca5926fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::set_initial_state </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>init_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method changes the initial state in which the task begins to operate. The default initial state is state 0. It should only be used before the task begins to run, as it sets the current and next state variables and will completely mess up normal state transition operation if called at any other time. </p>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00242">242</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a809314255837a6ba122bef5a03775b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::set_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;&#160;</td>
          <td class="paramname"><em>time_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method sets or changes the time interval between runs of this task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_interval</td><td>The time between runs of the task's <a class="el" href="classstl__task.html#a35f8eccc4a9c6737d217402b3cb0ffee">run()</a> method </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00083">83</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="stl__task_8h_source.html#l00147">interval</a>.</p>

</div>
</div>
<a class="anchor" id="a5d06fa647b9492360a9c38fe429f7ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::set_next_run_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtime__stamp.html">time_stamp</a> &amp;&#160;</td>
          <td class="paramname"><em>next_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method sets the next run time for the task. It should be used if the task timer's value is adjusted significantly, or if the task timer is started at a time long after time zero. If this isn't done, the task will run many times in quick succession, trying to catch up to the correct run time. Note that if this method is called and sets the next time far in the past, the same problem will occur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_time</td><td>A time stamp containing the next time for the task to run </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00098">98</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="stl__task_8h_source.html#l00144">next_run_time</a>.</p>

</div>
</div>
<a class="anchor" id="a8e49886b5ecd7479a3d09d378b09d97f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void stl_task::suspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method suspends the task so that it won't run again until after somebody calls the <a class="el" href="classstl__task.html#acdec061dcd4755e8a870383433b1fc5b">resume()</a> method. The state of the task before suspension is saved so that it can be restored after suspension. </p>

<p>Definition at line <a class="el" href="stl__task_8cpp_source.html#l00217">217</a> of file <a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a>.</p>

<p>References <a class="el" href="stl__task_8h_source.html#l00049">TASK_SUSPENDED</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="stl__task_8h_source.html">stl_task.h</a></li>
<li><a class="el" href="stl__task_8cpp_source.html">stl_task.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classstl__task.html">stl_task</a></li>
    <li class="footer">Generated on Fri Sep 20 2013 14:28:00 for Polar Plotter Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
