<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Polar Plotter Project: sd_card Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Polar Plotter Project
   &#160;<span id="projectnumber">5.0</span>
   </div>
   <div id="projectbrief">A 2D Polar Plotter for Drawing Straight Lines</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classsd__card.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsd__card-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sd_card Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sd__card_8h_source.html">sd_card.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sd_card:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsd__card.png" usemap="#sd_card_map" alt=""/>
  <map id="sd_card_map" name="sd_card_map">
<area href="classbase__text__serial.html" alt="base_text_serial" shape="rect" coords="0,0,103,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53258f2e1f42807f2c9238d66b8ca5fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a53258f2e1f42807f2c9238d66b8ca5fc">sd_card</a> (void)</td></tr>
<tr class="separator:a53258f2e1f42807f2c9238d66b8ca5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9426af93920e3819887fec13d89adb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ace9426af93920e3819887fec13d89adb">ready_to_send</a> (void)</td></tr>
<tr class="separator:ace9426af93920e3819887fec13d89adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24780513a0db84cd83cbd5d77437981b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a24780513a0db84cd83cbd5d77437981b">putchar</a> (char)</td></tr>
<tr class="separator:a24780513a0db84cd83cbd5d77437981b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadf1e3a3b449e9ab992ac147a837562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#afadf1e3a3b449e9ab992ac147a837562">puts</a> (char const *)</td></tr>
<tr class="separator:afadf1e3a3b449e9ab992ac147a837562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac718cadb3664d40cd96bd107470b271f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ac718cadb3664d40cd96bd107470b271f">transmit_now</a> (void)</td></tr>
<tr class="separator:ac718cadb3664d40cd96bd107470b271f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e39a6a46a6697f511d3cbef9627ae"><td class="memItemLeft" align="right" valign="top">FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ad62e39a6a46a6697f511d3cbef9627ae">mount</a> (unsigned char)</td></tr>
<tr class="separator:ad62e39a6a46a6697f511d3cbef9627ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac919f2d31c96d9e67520c28917b09e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#aeac919f2d31c96d9e67520c28917b09e">open_directory</a> (const char *)</td></tr>
<tr class="separator:aeac919f2d31c96d9e67520c28917b09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e81d537338e6bcb69a7623087272ca7"><td class="memItemLeft" align="right" valign="top">FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a0e81d537338e6bcb69a7623087272ca7">open_file_readonly</a> (const char *)</td></tr>
<tr class="separator:a0e81d537338e6bcb69a7623087272ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cb0c0eb0dd6e91704f11329721742b"><td class="memItemLeft" align="right" valign="top">FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a90cb0c0eb0dd6e91704f11329721742b">open_file_overwrite</a> (const char *)</td></tr>
<tr class="separator:a90cb0c0eb0dd6e91704f11329721742b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab322608cfd9fc6ac8544d681fe09b34f"><td class="memItemLeft" align="right" valign="top">FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ab322608cfd9fc6ac8544d681fe09b34f">open_file_append</a> (const char *)</td></tr>
<tr class="separator:ab322608cfd9fc6ac8544d681fe09b34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8edd6731e877aed7b4cd953a5f4b78d"><td class="memItemLeft" align="right" valign="top">FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ad8edd6731e877aed7b4cd953a5f4b78d">close_file</a> (void)</td></tr>
<tr class="separator:ad8edd6731e877aed7b4cd953a5f4b78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bf6f40225a91995831f6341eacccbe"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a01bf6f40225a91995831f6341eacccbe">open_new_data_file</a> (char const *, char const *)</td></tr>
<tr class="separator:a01bf6f40225a91995831f6341eacccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbase__text__serial"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbase__text__serial')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classbase__text__serial.html">base_text_serial</a></td></tr>
<tr class="memitem:a621b070a779b138b2dab34b3e33616fe inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a621b070a779b138b2dab34b3e33616fe">base_text_serial</a> (void)</td></tr>
<tr class="separator:a621b070a779b138b2dab34b3e33616fe inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaee97155296a26975e060ea230084ea inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#aaaee97155296a26975e060ea230084ea">check_for_char</a> (void)</td></tr>
<tr class="separator:aaaee97155296a26975e060ea230084ea inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1fd4a7965a273cd7b24ca543f8dbae inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a7c1fd4a7965a273cd7b24ca543f8dbae">getchar</a> (void)</td></tr>
<tr class="separator:a7c1fd4a7965a273cd7b24ca543f8dbae inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb835087fb3dec71c044a2da373bba9 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a1cb835087fb3dec71c044a2da373bba9">clear_screen</a> (void)</td></tr>
<tr class="separator:a1cb835087fb3dec71c044a2da373bba9 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84dcb7707510b48f35fb279bad4e4d5 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#ad84dcb7707510b48f35fb279bad4e4d5">operator&lt;&lt;</a> (bool)</td></tr>
<tr class="separator:ad84dcb7707510b48f35fb279bad4e4d5 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47d2d832ae5218199b86d6dde1cecc9 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#ab47d2d832ae5218199b86d6dde1cecc9">operator&lt;&lt;</a> (const char *)</td></tr>
<tr class="separator:ab47d2d832ae5218199b86d6dde1cecc9 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed7145ba442a8aaddc127ec6a6c3e42 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a2ed7145ba442a8aaddc127ec6a6c3e42">operator&lt;&lt;</a> (unsigned char)</td></tr>
<tr class="separator:a2ed7145ba442a8aaddc127ec6a6c3e42 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f0b7ddcc7ba49d948c112701990499 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#aa1f0b7ddcc7ba49d948c112701990499">operator&lt;&lt;</a> (char num)</td></tr>
<tr class="separator:aa1f0b7ddcc7ba49d948c112701990499 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e7c3adbfd07474322036cb9c321039 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#ac6e7c3adbfd07474322036cb9c321039">operator&lt;&lt;</a> (unsigned int)</td></tr>
<tr class="separator:ac6e7c3adbfd07474322036cb9c321039 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50c16ab5d5e5a308dd3a261700cb222 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#ad50c16ab5d5e5a308dd3a261700cb222">operator&lt;&lt;</a> (int)</td></tr>
<tr class="separator:ad50c16ab5d5e5a308dd3a261700cb222 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37eb2df4a84ff7af1c80e74a6f188f83 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a37eb2df4a84ff7af1c80e74a6f188f83">operator&lt;&lt;</a> (unsigned long)</td></tr>
<tr class="separator:a37eb2df4a84ff7af1c80e74a6f188f83 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca5651e37bcd704e69d9f9569dfbd14 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#aaca5651e37bcd704e69d9f9569dfbd14">operator&lt;&lt;</a> (long)</td></tr>
<tr class="separator:aaca5651e37bcd704e69d9f9569dfbd14 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde40cbd2f57b19fc3e0ef5f7a178a2d inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#abde40cbd2f57b19fc3e0ef5f7a178a2d">operator&lt;&lt;</a> (unsigned long long)</td></tr>
<tr class="separator:abde40cbd2f57b19fc3e0ef5f7a178a2d inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a9ffbd4ba8b557c7b61babf04e2e32 inherit pub_methods_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbase__text__serial.html">base_text_serial</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a51a9ffbd4ba8b557c7b61babf04e2e32">operator&lt;&lt;</a> (<a class="el" href="base__text__serial_8h.html#a5582483c459c0f48e51d96478d5b3407">ser_manipulator</a>)</td></tr>
<tr class="separator:a51a9ffbd4ba8b557c7b61babf04e2e32 inherit pub_methods_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac4cc3b5cee55e61d8bd3cf5aca7fd45e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4cc3b5cee55e61d8bd3cf5aca7fd45e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ac4cc3b5cee55e61d8bd3cf5aca7fd45e">sector_buffer</a> [<a class="el" href="sd__card_8h.html#a451aeffb68f3ecfb82eae03c88e9e48c">SD_BLOCK_SIZE</a>]</td></tr>
<tr class="memdesc:ac4cc3b5cee55e61d8bd3cf5aca7fd45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This buffer holds data which is to be saved into a block on the SD card. <br/></td></tr>
<tr class="separator:ac4cc3b5cee55e61d8bd3cf5aca7fd45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af621dab780f50c28cd7408fcf0ada3ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af621dab780f50c28cd7408fcf0ada3ec"></a>
<a class="el" href="classqueue.html">queue</a>&lt; char, <a class="el" href="sd__card_8h.html#aa25b1f28e3aef588379729587d2155c2">SD_L_BUF_IDX_T</a>, <br class="typebreak"/>
<a class="el" href="sd__card_8h.html#a6fd92a542394e4077621133ba8a8254d">SD_LINE_BUF_SIZE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#af621dab780f50c28cd7408fcf0ada3ec">line_buffer</a></td></tr>
<tr class="memdesc:af621dab780f50c28cd7408fcf0ada3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This buffer holds one line of text to be written to the card. <br/></td></tr>
<tr class="separator:af621dab780f50c28cd7408fcf0ada3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88ab93e401eb88fadf1f37622d87197"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88ab93e401eb88fadf1f37622d87197"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ac88ab93e401eb88fadf1f37622d87197">p_line_buffer</a></td></tr>
<tr class="memdesc:ac88ab93e401eb88fadf1f37622d87197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Points to buffer for lines of text. <br/></td></tr>
<tr class="separator:ac88ab93e401eb88fadf1f37622d87197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe8c92ca05cfcbb273962f4479ea802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe8c92ca05cfcbb273962f4479ea802"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a7fe8c92ca05cfcbb273962f4479ea802">index</a></td></tr>
<tr class="memdesc:a7fe8c92ca05cfcbb273962f4479ea802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index into buffer at which to put data. <br/></td></tr>
<tr class="separator:a7fe8c92ca05cfcbb273962f4479ea802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4ff5187d9c35208e83f886fb3456d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9d4ff5187d9c35208e83f886fb3456d"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#ac9d4ff5187d9c35208e83f886fb3456d">write_addr</a></td></tr>
<tr class="memdesc:ac9d4ff5187d9c35208e83f886fb3456d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address to which data is being written. <br/></td></tr>
<tr class="separator:ac9d4ff5187d9c35208e83f886fb3456d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908c8eb86a3ed04bd4653632e508588c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a908c8eb86a3ed04bd4653632e508588c"></a>
<a class="el" href="struct__FATFS__.html">FATFS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a908c8eb86a3ed04bd4653632e508588c">the_fat_fs</a></td></tr>
<tr class="memdesc:a908c8eb86a3ed04bd4653632e508588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a filesystem data structure (see <a class="el" href="ff_8h_source.html">ff.h</a>). <br/></td></tr>
<tr class="separator:a908c8eb86a3ed04bd4653632e508588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8958a4296da8a494dee943b09397e9bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8958a4296da8a494dee943b09397e9bc"></a>
FRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a8958a4296da8a494dee943b09397e9bc">dir_file_result</a></td></tr>
<tr class="memdesc:a8958a4296da8a494dee943b09397e9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This item holds a result code from opening a directory and/or a file. <br/></td></tr>
<tr class="separator:a8958a4296da8a494dee943b09397e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bc90f0045658fd4605a0cec4457b8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06bc90f0045658fd4605a0cec4457b8c"></a>
<a class="el" href="struct__DIR__.html">DIR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a06bc90f0045658fd4605a0cec4457b8c">the_dir</a></td></tr>
<tr class="memdesc:a06bc90f0045658fd4605a0cec4457b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a directory data structure (see <a class="el" href="ff_8h_source.html">ff.h</a>). <br/></td></tr>
<tr class="separator:a06bc90f0045658fd4605a0cec4457b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9db40386a4f7cf82131a1eb47f9960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e9db40386a4f7cf82131a1eb47f9960"></a>
<a class="el" href="struct__FIL__.html">FIL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsd__card.html#a4e9db40386a4f7cf82131a1eb47f9960">the_file</a></td></tr>
<tr class="memdesc:a4e9db40386a4f7cf82131a1eb47f9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This data structure stores information about a file on the disk. <br/></td></tr>
<tr class="separator:a4e9db40386a4f7cf82131a1eb47f9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classbase__text__serial"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classbase__text__serial')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classbase__text__serial.html">base_text_serial</a></td></tr>
<tr class="memitem:a8f253aae58f8897edee505b4118afed0 inherit pro_attribs_classbase__text__serial"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f253aae58f8897edee505b4118afed0"></a>
unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a8f253aae58f8897edee505b4118afed0">base</a></td></tr>
<tr class="memdesc:a8f253aae58f8897edee505b4118afed0 inherit pro_attribs_classbase__text__serial"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the currently used base for converting numbers to text. <br/></td></tr>
<tr class="separator:a8f253aae58f8897edee505b4118afed0 inherit pro_attribs_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf570e2dd8b2f818f2728c22945f1955 inherit pro_attribs_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#acf570e2dd8b2f818f2728c22945f1955">print_ascii</a></td></tr>
<tr class="separator:acf570e2dd8b2f818f2728c22945f1955 inherit pro_attribs_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613572e10c2d70d44bdb44c451f6fc6b inherit pro_attribs_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a613572e10c2d70d44bdb44c451f6fc6b">pgm_string</a></td></tr>
<tr class="separator:a613572e10c2d70d44bdb44c451f6fc6b inherit pro_attribs_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0927f9b976981a7f38a4445083ec6f34 inherit pro_attribs_classbase__text__serial"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbase__text__serial.html#a0927f9b976981a7f38a4445083ec6f34">precision</a></td></tr>
<tr class="separator:a0927f9b976981a7f38a4445083ec6f34 inherit pro_attribs_classbase__text__serial"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements an interface to an SD card. Data is stored up in a buffer, then written to the card when the buffer becomes full or when the send_now modifier is inserted into the SD card object's output stream. (Alternatively, one can specify that carriage returns cause writing to the card using the macro SD_SEND_NOW_CHAR in <a class="el" href="sd__card_8h.html">sd_card.h</a>.) The SPI interface to the SD card is used, as it is much simpler and requires less wires than the full high-speed interface. The SPI interface is a bit slow, though.</p>
<p>The ELM-FAT-FS library is used for its low-level and FAT file system drivers. This library can be found at <a href="http://elm-chan.org/fsw/ff/00index_e.html">http://elm-chan.org/fsw/ff/00index_e.html</a>. The filesystem library interfaces with the <a class="el" href="classsd__card.html">sd_card</a> class through two sets of C functions. The first set of functions is in files <a class="el" href="ff_8h_source.html">ff.h</a> and <a class="el" href="ff_8c_source.html">ff.c</a>; these functions provide the functionality of a file system: initializing and mounting volumes, opening files and directories, reading and writing data, and so on. The second set of functions is a set of callback functions which are provided in sd_card.cc. Written in C, these callbacks are called by the ELM-FAT-FS library to provide platform and media specific access; they allow the AVR processor to work with the SD card. Most of the C functions in sd_card.cc are slightly modified versions of functions from the AVR-specific example files distributed with the ELM-FAT-FS library.</p>
<h1><a class="anchor" id="sd_prep_card"></a>
Preparing an SD Card for Use</h1>
<p>The SD cards used by this program should be formatted as MS-DOS style volumes in the "floppy disk" style, not the "hard disk" style. This means that there should not be a partition table, with one or more partitions each having a filesystem. Instead, the disk's main volume should be formatted. Many SD cards come formatted in the wrong style when purchased; the following steps will help determine if a card is formatted in the right or wrong way: </p>
<ul>
<li>Plug the card into a Linux computer. </li>
<li>Open the card in a file browser; ignore the contents and close the browser. Opening the card caused it to be automatically mounted, which is why it was worth doing. </li>
<li>Open a terminal window (konsole or gnome-terminal) and type 'mount'. Look near the end of the bunch of text which comes up for a line that looks like this: <br/>
 <code>/dev/sde1 on /media/disk type vfat (rw,nosuid,nodev,uhelper=hal,uid=1000,utf8,shortname=mixed,flush)</code> </li>
<li>If the code <code>/dev/xxxx</code> on the left of the line ends with a number, such as <code>/dev/sde1</code>, you have the wrong kind of formatting; it will need to be reformatted. If the code has no number, such as <code>/dev/sdf</code>, then you should be able to use the card as is. </li>
<li>The device name is usually <code>/dev/sdxx</code>, but on some computers the name may be different, such as <code>/dev/mmcblk0</code>. In this case, partitions may be named like <code>/dev/mmcblk0p1</code>, and the device name is actually <code>/dev/mmcblk0</code> including the "0" at the end. </li>
<li>Unmount the card. In KDE, use the device mounter's "eject" button; in Gnome right-click on the device icon and choose unmount.</li>
</ul>
<p>The following process will format an SD card in "floppy disk style" on Linux: </p>
<ul>
<li>Get to a Linux computer on which you have root (sudo) access. You need root access in order to write directly to the SD card. </li>
<li>Plug the card into an SD/MMC slot in the computer. Do not open it up in a file manager or mount it. </li>
<li>Repeat the steps for checking the card's formatting if necessary to find the device name <code>/dev/xxxn</code> for the card. Note that in <code>/dev/xxxn</code>, the "\c xxx" is letters (for example sdf) and the "\t n" is a number, almost always <code>1</code>. </li>
<li><b>WARNING:</b> You need to be very careful in the following command: <b>Do not enter the designation of one of your computer's hard drives</b>, as this command would then reformat your system drive and effectively wipe out all the data on that drive. </li>
<li>Run the following command: <br/>
 <code>sudo mkfs -t msdos -I /dev/xxx</code> <br/>
 Note that the number is left off the device name. What you are doing is formatting the disk without any partitions; the numbers referred to partitions on the disk. </li>
<li>Remove the card and re-insert it in the computer. Make sure you can open it in a file manager as usual. </li>
<li>Unmount the card, remove it from the PC, and you're ready to use it to save some data.</li>
</ul>
<h1><a class="anchor" id="sd_card_drv"></a>
Using the SD Card Driver Software</h1>
<p>In order to use the SD card driver, one must have an AVR board with an SD card slot, and the board must be configured to operate with Vcc at 3.3 volts. It is possible that multiple SD cards could be used on the same board, but this has not been tested, and it would be rather weird to want to do so. Hot swapping the SD card is possible, but it's usually not a very good idea because of hardware considerations: SD cards have big internal power supply capacitance and tend to inflict brownouts on the AVR when plugged in. Also, making sure that all your reads and writes are finished before swapping the card can be a problem.</p>
<p>Configuration is done by modifying values in <a class="el" href="sd__card_8h.html">sd_card.h</a> and <a class="el" href="ffconf_8h_source.html">ffconf.h</a>. Recommended settings for <a class="el" href="ffconf_8h_source.html">ffconf.h</a> (which configures the filesystem drivers) include the following: </p>
<table  border="0" cellspacing="1">
<tr>
<td>_FS_TINY </td><td>0 </td><td>unless you have &gt;= 4K SRAM  </td></tr>
<tr>
<td>_FS_READONLY </td><td>0 </td><td>to enable writing  </td></tr>
<tr>
<td>_FS_MINIMIZE </td><td>1 </td><td>to save space  </td></tr>
<tr>
<td>_USE_STRFUNC </td><td>0 </td><td>unless you need strings  </td></tr>
<tr>
<td>_USE_MKFS </td><td>0 </td><td>unless you need to format  </td></tr>
<tr>
<td>_USE_FORWARD </td><td>0 </td><td>unless you need...this  </td></tr>
<tr>
<td>_CODE_PAGE </td><td>1 </td><td>for ASCII coding  </td></tr>
<tr>
<td>_USE_LFN </td><td>0 </td><td>to use short (8.3) filenames  </td></tr>
</table>
<p>Recommended settings for <a class="el" href="sd__card_8h.html">sd_card.h</a> include the following: </p>
<table  border="0" cellspacing="1">
<tr>
<td>SD_BLOCK_SIZE </td><td>512  </td><td>This must be 512 for all SD cards  </td></tr>
<tr>
<td>SD_LINE_BUF_SIZE </td><td>256  </td><td>256 Anything from about 16 to 512 should work; this value can be adjusted to balance speed with memory usage.  </td></tr>
</table>
<p>The processs of reading or writing a file consists of the following steps: </p>
<ul>
<li>Mount the card. This is Unix-talk for getting data from the boot record about where the partitions and base directories on the card can be found. </li>
<li>Open a file using a method such as <a class="el" href="classsd__card.html#a0e81d537338e6bcb69a7623087272ca7">open_file_readonly()</a>, <a class="el" href="classsd__card.html#a90cb0c0eb0dd6e91704f11329721742b">open_file_overwrite()</a>, etc. </li>
<li>If lots of data is being logged, one can use the <a class="el" href="classsd__card.html#a01bf6f40225a91995831f6341eacccbe">open_new_data_file()</a> method which automatically creates file names in a sequence. </li>
<li>Use the overloaded shift operator "&lt;&lt;" to write data to the file, or use the more primitive methods <a class="el" href="classbase__text__serial.html#a7c1fd4a7965a273cd7b24ca543f8dbae">getchar()</a>, <a class="el" href="classsd__card.html#a24780513a0db84cd83cbd5d77437981b">putchar()</a>, and <a class="el" href="classsd__card.html#afadf1e3a3b449e9ab992ac147a837562">puts()</a> to read and write characters from and to the file. </li>
<li>If at all possible, use the <a class="el" href="classsd__card.html#ad8edd6731e877aed7b4cd953a5f4b78d">close_file()</a> method to make sure all the data is saved to the file. If a file is not closed properly, some data may be left in the memory buffer and not written to the disk.</li>
</ul>
<h1><a class="anchor" id="sd_tested"></a>
Functions tested and working</h1>
<ul>
<li>Opening an SD card formatted without a partition </li>
<li>Automatically creating data files in the root directory and writing to them</li>
</ul>
<h1><a class="anchor" id="sd_bugs"></a>
Bugs</h1>
<ul>
<li>When using SD cards formatted with one or more partitions, sometimes the files written by this driver aren't visible to a computer reading the card. Workaround: Make sure to use cards which don't have partitions on them. </li>
<li>Writing to the SD card can be very slow, and this code does not attempt to prevent blocking of the rest of the system during card writes. </li>
<li>Long file names have not been tested. They're probably not a good idea for a small embedded system anyway.</li>
</ul>
<h1><a class="anchor" id="sd_int_comp"></a>
Internal stuff</h1>
<p>The DSTATUS flag byte, given in sd_card.c, holds some status bits for the disk: </p>
<ul>
<li>0x01: STA_NOINIT </li>
<li>0x02: STA_NODISK </li>
<li>0x04: STA_PROTECT</li>
</ul>
<p>The FRESULT enumeration, given in <a class="el" href="ff_8c_source.html">ff.c</a>, holds the result of a file operation. Its values are: </p>
<ul>
<li>0: FR_OK </li>
<li>1: FR_DISK_ERR </li>
<li>2: FR_INT_ERR </li>
<li>3: FR_NOT_READY </li>
<li>4: FR_NO_FILE </li>
<li>5: FR_NO_PATH </li>
<li>6: FR_INVALID_NAME </li>
<li>7: FR_DENIED </li>
<li>8: FR_EXIST </li>
<li>9: FR_INVALID_OBJECT </li>
<li>10: FR_WRITE_PROTECTED </li>
<li>11: FR_INVALID_DRIVE </li>
<li>12: FR_NOT_ENABLED </li>
<li>13: FR_NO_FILESYSTEM </li>
<li>14: FR_MKFS_ABORTED </li>
<li>15: FR_TIMEOUT </li>
</ul>

<p>Definition at line <a class="el" href="sd__card_8h_source.html#l00325">325</a> of file <a class="el" href="sd__card_8h_source.html">sd_card.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a53258f2e1f42807f2c9238d66b8ca5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sd_card::sd_card </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This constructor sets up an SD card interface. It calls the constructor of its base class <a class="el" href="classbase__text__serial.html">base_text_serial</a> and initializes the data buffer so that the buffer is ready to accept some data. It also configures the SPI port pins so that they are ready to communicate with the card. The constructor does not initialize the card; initialization is performed in the <a class="el" href="classsd__card.html#ad62e39a6a46a6697f511d3cbef9627ae">mount()</a> method. </p>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00689">689</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="queue_8h_source.html#l00077">queue&lt; qType, qIndexType, qSize &gt;::get_p_buffer()</a>, <a class="el" href="sd__card_8h_source.html#l00332">line_buffer</a>, <a class="el" href="sd__card_8h_source.html#l00334">p_line_buffer</a>, <a class="el" href="sd__card_8h_source.html#l00089">SD_CS_DDR</a>, <a class="el" href="sd__card_8h_source.html#l00096">SD_CS_MASK</a>, <a class="el" href="sd__card_8h_source.html#l00082">SD_CS_PORT</a>, and <a class="el" href="sd__card_8cpp_source.html#l00046">STA_NOINIT</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad8edd6731e877aed7b4cd953a5f4b78d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRESULT sd_card::close_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method closes a file. If there is any data left in the buffer, it is written to the card. Then further writing to this file is prevented unless the file is opened again. </p>
<dl class="section return"><dt>Returns</dt><dd>The result code from calling f_close() to close the file </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00945">945</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="sd__card_8h_source.html#l00332">line_buffer</a>, <a class="el" href="queue_8h_source.html#l00070">queue&lt; qType, qIndexType, qSize &gt;::num_items()</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>, and <a class="el" href="sd__card_8cpp_source.html#l00780">transmit_now()</a>.</p>

</div>
</div>
<a class="anchor" id="ad62e39a6a46a6697f511d3cbef9627ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRESULT sd_card::mount </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>part_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method performs an action equivalent to "mounting" the SD card (in POSIX talk). This means that the card interface is initialized, then the card's boot record and partition table and all that oddball stuff is scanned so that we will be able to find files on the card. Partition number 0 is always mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">part_num</td><td>The number of the partition to mount &ndash; ignored, we use 0 always </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result code from attempting to open the root directory; 0 means OK </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00805">805</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="sd__card_8cpp_source.html#l00335">disk_initialize()</a>, <a class="el" href="sd__card_8h_source.html#l00345">the_dir</a>, and <a class="el" href="sd__card_8h_source.html#l00339">the_fat_fs</a>.</p>

</div>
</div>
<a class="anchor" id="aeac919f2d31c96d9e67520c28917b09e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sd_card::open_directory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method opens the given directory. The directory is identified by a path name which may go into several layers of subdirectories but must be less than 64 characters long. A valid path name might be "/data/strain.dat/recent"; note that forward slashes are used (POSIX style), not backslashes in the Windows style, and that 8.3 names are required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A character string containing the full path name of the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the directory was opened OK, or false if it couldn't be opened </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00833">833</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab322608cfd9fc6ac8544d681fe09b34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRESULT sd_card::open_file_append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method opens the given file for writing (the file can also be read). If the file doesn't yet exist, it is created; if it exists, it's opened in append mode.</p>
<p>WARNING, BUG, TODO: This method hasn't been finished yet and doesn't work.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_name</td><td>The path name to the file, including the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result code from the f_open() call attempting to open the file </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00912">912</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>.</p>

</div>
</div>
<a class="anchor" id="a90cb0c0eb0dd6e91704f11329721742b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRESULT sd_card::open_file_overwrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method opens the given file for writing (the file can also be read). It leaves the read/write pointer at the beginning of the file so that old data will be overwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_name</td><td>The path name to the file, including the directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result code from the f_open() call attempting to open the file </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00878">878</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>.</p>

<p>Referenced by <a class="el" href="sd__card_8cpp_source.html#l00979">open_new_data_file()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e81d537338e6bcb69a7623087272ca7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRESULT sd_card::open_file_readonly </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method opens the given file in read-only mode. The file must exist, and the volume in which the file exists must have already been mounted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_name</td><td>A path to the file to be opened </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An FRESULT value (see <a class="el" href="ff_8h_source.html">ff.h</a>) which tells if the file was opened successfully </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00846">846</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>.</p>

</div>
</div>
<a class="anchor" id="a01bf6f40225a91995831f6341eacccbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t sd_card::open_new_data_file </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>base_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function opens a new data file, in the card's root directory, with a name which hasn't yet been used. Names are made by putting together a path, base name, number, and extension as in "/data/file_012.txt". The base name variable includes the path and the file name together, separated by forward slashes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_name</td><td>The base name, including path, such as "/data/log_" where the file name should be at most 5 characters long because 3 digits will be added. The base name should begin with a slash to be an absolute path name on a card. </td></tr>
    <tr><td class="paramname">extension</td><td>The 3-character file name extension, such as "txt" or "csv" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number used to make the new data file's name, or 0xFFFF for failure </dd></dl>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00979">979</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="base__text__serial_8h_source.html#l00131">endl</a>, <a class="el" href="global__debug_8h_source.html#l00037">GLOB_DEBUG</a>, <a class="el" href="sd__card_8cpp_source.html#l00878">open_file_overwrite()</a>, <a class="el" href="base__text__serial_8h_source.html#l00108">PMS</a>, and <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>.</p>

</div>
</div>
<a class="anchor" id="a24780513a0db84cd83cbd5d77437981b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sd_card::putchar </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>to_put</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method puts one character into the buffer of data to be written to the card. If the buffer becomes full through this write, the buffer is automatically written to the card. This will take a long time, so it might be a good idea to control the times at which buffers full of data are written using the <a class="el" href="classsd__card.html#ac718cadb3664d40cd96bd107470b271f">transmit_now()</a> method to write data and chars_empty() to check how much space is left in the buffer. An error occurs if the buffer is full and there's no card to which to store data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_put</td><td>The character to be written into the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if everything was OK and false if data couldn't be stored </dd></dl>

<p>Reimplemented from <a class="el" href="classbase__text__serial.html#a945e2929f72e578d3c4d3f5de8087567">base_text_serial</a>.</p>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00741">741</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00332">line_buffer</a>, <a class="el" href="queue_8h_source.html#l00070">queue&lt; qType, qIndexType, qSize &gt;::num_items()</a>, <a class="el" href="queue_8h_source.html#l00122">queue&lt; qType, qIndexType, qSize &gt;::put()</a>, <a class="el" href="sd__card_8cpp_source.html#l00724">ready_to_send()</a>, <a class="el" href="sd__card_8h_source.html#l00065">SD_LINE_BUF_SIZE</a>, and <a class="el" href="sd__card_8cpp_source.html#l00780">transmit_now()</a>.</p>

<p>Referenced by <a class="el" href="sd__card_8cpp_source.html#l00768">puts()</a>.</p>

</div>
</div>
<a class="anchor" id="afadf1e3a3b449e9ab992ac147a837562"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sd_card::puts </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method writes all the characters in a string to the card buffer until it gets to the '\0' at the end. Warning: This function blocks until it's finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to be written </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classbase__text__serial.html#a1699dd6cb65575604f66abbf762a2131">base_text_serial</a>.</p>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00768">768</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8cpp_source.html#l00741">putchar()</a>.</p>

</div>
</div>
<a class="anchor" id="ace9426af93920e3819887fec13d89adb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sd_card::ready_to_send </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method checks if the card is ready, with a file opened, for some data to be sent to it. If a file is opened, the status flags will have been set properly. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there's a card ready for data and false if not </dd></dl>

<p>Reimplemented from <a class="el" href="classbase__text__serial.html#ac20fa8adfde943956f8750c4e662627c">base_text_serial</a>.</p>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00724">724</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>.</p>

<p>Referenced by <a class="el" href="sd__card_8cpp_source.html#l00741">putchar()</a>.</p>

</div>
</div>
<a class="anchor" id="ac718cadb3664d40cd96bd107470b271f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sd_card::transmit_now </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method writes the data from the buffer to the card. Because there's so much data and flash cards are slow, it takes a comparatively long time to write data. </p>

<p>Reimplemented from <a class="el" href="classbase__text__serial.html#ac576f366ad6546797a0b0367015b385d">base_text_serial</a>.</p>

<p>Definition at line <a class="el" href="sd__card_8cpp_source.html#l00780">780</a> of file <a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a>.</p>

<p>References <a class="el" href="sd__card_8h_source.html#l00342">dir_file_result</a>, <a class="el" href="queue_8h_source.html#l00105">queue&lt; qType, qIndexType, qSize &gt;::flush()</a>, <a class="el" href="sd__card_8h_source.html#l00332">line_buffer</a>, <a class="el" href="queue_8h_source.html#l00070">queue&lt; qType, qIndexType, qSize &gt;::num_items()</a>, <a class="el" href="sd__card_8h_source.html#l00334">p_line_buffer</a>, and <a class="el" href="sd__card_8h_source.html#l00348">the_file</a>.</p>

<p>Referenced by <a class="el" href="sd__card_8cpp_source.html#l00945">close_file()</a>, and <a class="el" href="sd__card_8cpp_source.html#l00741">putchar()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="sd__card_8h_source.html">sd_card.h</a></li>
<li><a class="el" href="sd__card_8cpp_source.html">sd_card.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classsd__card.html">sd_card</a></li>
    <li class="footer">Generated on Fri Sep 20 2013 14:28:00 for Polar Plotter Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
